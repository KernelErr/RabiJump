"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.byteMB = exports.byteKB = void 0;
exports.endsWith = endsWith;
exports.getFileSize = getFileSize;
exports.loopFiles = loopFiles;
exports.mapFileTree = mapFileTree;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/define-properties"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = _promise.default))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

const byteKB = 1024;
exports.byteKB = byteKB;
const byteMB = 1048576;
exports.byteMB = byteMB;

function getFileSize(number) {
  if (number < byteKB) {
    return "".concat((number / byteKB).toFixed(2), "KB");
  } else if (number >= byteKB && number < byteMB) {
    return "".concat((number / byteKB).toFixed(1), "KB");
  } else if (number >= byteMB) {
    return "".concat((number / byteMB).toFixed(1), "MB");
  }

  return undefined;
}

function endsWith(str, suffix) {
  return (0, _indexOf.default)(str).call(str, suffix, str.length - suffix.length) !== -1;
}

function loopFiles(item) {
  return __awaiter(this, void 0, void 0, function* () {
    return new _promise.default((res, rej) => {
      const dirReader = item.createReader();
      let fileList = [];

      function sequence() {
        dirReader.readEntries(entries => {
          const entryList = (0, _slice.default)(Array.prototype).apply(entries);
          fileList = (0, _concat.default)(fileList).call(fileList, entryList); // Check if all the file has been viewed

          const isFinished = !entryList.length;

          if (isFinished) {
            res(fileList);
          } else {
            sequence();
          }
        }, rej);
      }

      sequence();
    });
  });
}

function mapFileTree(items) {
  return __awaiter(this, void 0, void 0, function* () {
    const promises = [];

    const _traverseFileTree = (item, path) => __awaiter(this, void 0, void 0, function* () {
      path = path || ''; //@ts-ignore add path property into item

      item.path = path;

      if (item.isFile) {
        promises.push(new _promise.default((res, rej) => {
          item.file(file => {
            if (item.fullPath && !file.webkitRelativePath) {
              // This file is provided to the user based on the relative path of the drag and drop folder
              // If you drag the Upload folder, the path of the internal file may be Upload/File/a.png, etc
              (0, _defineProperties.default)(file, {
                webkitRelativePath: {
                  writable: true
                }
              }); //@ts-ignore add webkitRelativePath property into file

              file.webkitRelativePath = item.fullPath.replace(/^\//, '');
              (0, _defineProperties.default)(file, {
                webkitRelativePath: {
                  writable: false
                }
              });
            }

            res(file);
          }, rej);
        }));
      } else if (item.isDirectory) {
        const entries = yield loopFiles(item);

        for (let index = 0; index < entries.length; index++) {
          var _context;

          const entry = entries[index];
          yield _traverseFileTree(entry, (0, _concat.default)(_context = "".concat(path)).call(_context, item.name, "/"));
        }
      }
    });

    try {
      const batches = (0, _map.default)(items).call(items, i => _traverseFileTree(i.webkitGetAsEntry())); // Perform asynchronous operations to add the required promises to the queue

      yield _promise.default.all(batches); // Execution queue

      const result = yield _promise.default.all(promises);
      return result;
    } catch (error) {
      console.warn('Captured error while loop directory.');
      console.error(error);
      return [];
    }
  });
}