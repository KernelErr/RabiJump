"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.generateValidatesFromRules = generateValidatesFromRules;
exports.getDisplayName = getDisplayName;
exports.isRequired = isRequired;
exports.isValid = isValid;
exports.mergeOptions = mergeOptions;
exports.mergeProps = mergeProps;

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _every = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/every"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));

var _asyncValidator = _interopRequireDefault(require("async-validator"));

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && (0, _indexOf.default)(e).call(e, p) < 0) t[p] = s[p];

  if (s != null && typeof _getOwnPropertySymbols.default === "function") for (var i = 0, p = (0, _getOwnPropertySymbols.default)(s); i < p.length; i++) {
    if ((0, _indexOf.default)(e).call(e, p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
/* eslint-disable prefer-destructuring */

/* eslint-disable prefer-const */

/* eslint-disable @typescript-eslint/no-unused-vars */


/**
 *
 * @param WrappedComponent React.ComponentType | any
 */
function getDisplayName(WrappedComponent) {
  const originName = WrappedComponent.displayName || WrappedComponent.name;
  return originName ? "SemiField".concat(originName) : 'SemiField';
}

function generateValidatesFromRules(field) {
  let rules = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  const descriptor = {};
  descriptor[field] = rules;
  const validator = new _asyncValidator.default(descriptor);
  return validator;
}

function isRequired() {
  let rules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let required = false;

  if (typeof rules === 'object' && 'required' in rules) {
    required = rules.required;
  } else if ((0, _isArray.default)(rules) && rules.length) {
    (0, _forEach.default)(rules).call(rules, rule => {
      rule.required ? required = true : null;
    });
  }

  return required;
}

function isValid(errors) {
  let valid = true;

  if (typeof errors === 'string' && errors.length) {
    valid = false;
  } else if ((0, _isArray.default)(errors) && errors.length) {
    valid = (0, _every.default)(errors).call(errors, error => isValid(error));
  } else if (typeof errors === 'boolean') {
    valid = errors;
  } else if (errors && typeof errors.$$typeof === 'symbol' && errors.$$typeof.toString() === 'Symbol(react.element)') {
    // when error message is reactNode
    valid = false;
  }

  return valid;
} // Compatible with String and Array


function transformTrigger(trigger) {
  let result = [];

  if ((0, _isArray.default)(trigger)) {
    result = trigger;
  }

  if (typeof trigger === 'string') {
    result[0] = trigger;
  }

  return result;
}

function mergeOptions(opts, props) {
  // Opts: different types of component identification value, value change callback function may be inconsistent, used to adapt 1, input, select 2, radio, checkbox 3, switch
  // valueKey: input, select class component control value props are value, and checkbox, switch is checked
  // eg：checkbox、radio   { valueKey: 'checked', onKeyChangeFnName: 'onChange', valuePath: 'target.value' }
  const defaultOpts = {
    valueKey: 'value',
    onKeyChangeFnName: 'onChange',
    valuePath: '',
    maintainCursor: false,
    shouldInject: true,
    shouldMemo: true
  };
  const options = (0, _assign.default)((0, _assign.default)({}, defaultOpts), opts); // If the field attribute is declared, then the injection is carried out (mainly used to deal with the case where Checkbox and Radio are used separately from the Group); other cases are subject to options

  const shouldInject = 'field' in props ? true : options.shouldInject;
  return {
    options,
    shouldInject
  };
}

function mergeProps(props) {
  const defaultProps = {
    trigger: 'change',
    // validateStatus: 'default',
    allowEmptyString: false,
    allowEmpty: false,
    emptyValue: '',
    noLabel: false,
    noErrorMessage: false,
    isInInputGroup: false,
    stopValidateWithError: false
  };

  let _a = (0, _assign.default)((0, _assign.default)({}, defaultProps), props),
      {
    field,
    label,
    labelPosition,
    labelWidth,
    labelAlign,
    labelCol,
    wrapperCol,
    initValue,
    validate,

    /**
     * error、warning、default、success
     */
    validateStatus,

    /**
     * change、blur、custom、mount
     */
    trigger,
    allowEmptyString,
    allowEmpty,
    emptyValue,
    rules,
    onChange,
    keepState,
    // Conversion before validation
    transform,
    name,
    fieldClassName,
    fieldStyle,
    noLabel,
    noErrorMessage,
    isInInputGroup,
    stopValidateWithError,
    convert,
    showValidateIcon,
    helpText,
    extraText,
    extraTextPosition,
    pure,
    id
  } = _a,
      rest = __rest(_a, ["field", "label", "labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "initValue", "validate", "validateStatus", "trigger", "allowEmptyString", "allowEmpty", "emptyValue", "rules", "onChange", "keepState", "transform", "name", "fieldClassName", "fieldStyle", "noLabel", "noErrorMessage", "isInInputGroup", "stopValidateWithError", "convert", "showValidateIcon", "helpText", "extraText", "extraTextPosition", "pure", "id"]); // Form中的任何类型组件，初始值都统一通过initValue字段来传入，同时将可能会导致组件行为错误的props抽取出来，防止透传到组件中
  // For any type of field component in Form, the initial value is uniformly passed in through the initValue field.
  // At the same time, the props that may cause component behavior errors are extracted to prevent transparent transmission to the component.


  delete rest.defaultChecked;
  delete rest.defaultValue;
  delete rest.checked;

  if (typeof initValue !== 'undefined') {
    initValue = (0, _cloneDeep2.default)(initValue);
  }

  const required = isRequired(rules);
  trigger = transformTrigger(trigger);
  emptyValue = typeof emptyValue !== 'undefined' ? emptyValue : '';
  return {
    field,
    label,
    labelPosition,
    labelWidth,
    labelAlign,
    labelCol,
    wrapperCol,
    noLabel,
    noErrorMessage,
    isInInputGroup,
    initValue,
    validate,
    validateStatus,
    trigger,
    allowEmptyString,
    allowEmpty,
    emptyValue,
    rules,
    required,
    keepState,
    transform,
    name,
    fieldClassName,
    fieldStyle,
    convert,
    stopValidateWithError,
    showValidateIcon,
    helpText,
    extraText,
    extraTextPosition,
    pure,
    rest,
    id
  };
}

function bothEmptyArray(val, otherVal) {
  return (0, _isArray.default)(val) && (0, _isArray.default)(otherVal) && !val.length && !otherVal.length;
}