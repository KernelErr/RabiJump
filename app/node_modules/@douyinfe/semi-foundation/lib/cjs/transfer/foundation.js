"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _set = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _map2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/map"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/values"));

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _foundation = _interopRequireDefault(require("../base/foundation"));

var _constants = require("./constants");

var _transferUtils = require("./transferUtils");

var _arrayMove = _interopRequireDefault(require("../utils/arrayMove"));

// eslint-disable-next-line max-len
class TransferFoundation extends _foundation.default {
  constructor(adapter) {
    super((0, _assign.default)({}, adapter));
  }

  _generateGroupedData(dataSource) {
    return (0, _transferUtils._generateGroupedData)(dataSource);
  }

  _generateTreeData(dataSource) {
    return (0, _transferUtils._generateTreeData)(dataSource);
  }

  _generatePath(item) {
    const {
      path = []
    } = item;
    return (0, _map.default)(path).call(path, p => p.label).join(' > ');
  }

  handleInputChange(inputVal) {
    const {
      data
    } = this.getStates();
    const {
      filter,
      type
    } = this.getProps();

    if (type === _constants.strings.TYPE_TREE_TO_LIST) {
      const searchResult = new _set.default((0, _map.default)(data).call(data, item => item.key));

      this._adapter.searchTree(inputVal);

      this._adapter.notifySearch(inputVal);

      this._adapter.updateInput(inputVal);

      this._adapter.updateSearchResult(searchResult);

      return;
    }

    const filterFunc = typeof filter === 'function' ? item => filter(inputVal, item) : item => {
      var _context;

      return typeof item.label === 'string' && (0, _includes.default)(_context = item.label).call(_context, inputVal);
    };
    const searchData = (0, _filter.default)(data).call(data, filterFunc);
    const searchResult = new _set.default((0, _map.default)(searchData).call(searchData, item => item.key));

    this._adapter.notifySearch(inputVal);

    this._adapter.updateInput(inputVal);

    this._adapter.updateSearchResult(searchResult);
  } // Select or cancel all unhidden items


  handleAll(wantAllChecked) {
    const {
      disabled,
      type
    } = this.getProps();
    const {
      selectedItems,
      data,
      searchResult,
      inputValue
    } = this.getStates();

    if (disabled) {
      return;
    }

    const inSearchMode = inputValue !== '';
    let operateData = [];
    operateData = inSearchMode ? (0, _filter.default)(data).call(data, item => searchResult.has(item.key)) : data;
    operateData = type === _constants.strings.TYPE_TREE_TO_LIST ? data : operateData;
    let newSelectedItems = new _map2.default();

    switch (true) {
      case !wantAllChecked:
        newSelectedItems = new _map2.default(selectedItems);
        (0, _forEach.default)(operateData).call(operateData, item => {
          // If the item is disabled, keep it
          if (!item.disabled) {
            newSelectedItems.delete(item.key);
          }
        });
        break;

      case wantAllChecked:
        newSelectedItems = new _map2.default(selectedItems);
        (0, _forEach.default)(operateData).call(operateData, item => {
          if (item.disabled) {
            // The disabled item, judge whether it is selected, if it is selected, still need to add the selection
            if (selectedItems.has(item.key)) {
              newSelectedItems.set(item.key, item);
            }

            return;
          }

          newSelectedItems.set(item.key, item);
        });
        break;

      default:
        break;
    }

    if (!this._isControlledComponent()) {
      this._adapter.updateSelected(newSelectedItems);
    }

    this._notifyChange(newSelectedItems);
  }

  handleClear() {
    const {
      disabled
    } = this.getProps();
    const {
      selectedItems,
      data
    } = this.getStates();

    if (disabled) {
      return;
    }

    const newSelectedItems = new _map2.default(selectedItems);
    (0, _forEach.default)(data).call(data, item => {
      // If the item is disabled, keep it
      if (!item.disabled) {
        newSelectedItems.delete(item.key);
      }
    });

    if (!this._isControlledComponent()) {
      this._adapter.updateSelected(newSelectedItems);
    }

    this._notifyChange(newSelectedItems);
  }

  handleSelectOrRemove(item) {
    const {
      disabled
    } = this.getProps();

    const selectedItems = this._adapter.getSelected();

    if (disabled || item.disabled) {
      return;
    }

    if (selectedItems.has(item.key)) {
      selectedItems.delete(item.key);

      this._adapter.notifyDeselect(item);
    } else {
      selectedItems.set(item.key, item);

      this._adapter.notifySelect(item);
    }

    if (!this._isControlledComponent()) {
      this._adapter.updateSelected(selectedItems);
    }

    this._notifyChange(selectedItems);
  }

  handleSelect(values) {
    const {
      disabled
    } = this.getProps();

    const selectedItems = this._adapter.getSelected();

    const {
      data
    } = this.getStates();
    const dataItems = (0, _map.default)(data).call(data, d => [d.value, d]);
    const allItemsMap = new _map2.default(dataItems);
    const nextSelectedItemsMap = new _map2.default();

    if (disabled) {
      return;
    }

    (0, _forEach.default)(values).call(values, value => {
      const node = allItemsMap.get(value); // The value passed in is an array of the value used, but the internal selectedItems stores a map of keys

      if (selectedItems.has(node.key)) {
        nextSelectedItemsMap.set(node.key, node);
        return;
      }

      if (node.disabled) {
        return;
      }

      nextSelectedItemsMap.set(node.key, node);
      return;
    });

    if (!this._isControlledComponent()) {
      this._adapter.updateSelected(nextSelectedItemsMap);
    }

    this._notifyChange(nextSelectedItemsMap);
  }

  getValuesAndItemsFromMap(selectedItems) {
    const {
      type
    } = this.getProps();
    const items = [];
    const values = [];

    for (const item of selectedItems) {
      const obj = type === _constants.strings.TYPE_GROUP_LIST ? (0, _omit2.default)(item[1], '_parent') : item[1];
      items.push(obj);
      values.push(obj.value);
    }

    return {
      items,
      values
    };
  }

  _notifyChange(selectedItems) {
    const {
      items,
      values
    } = this.getValuesAndItemsFromMap(selectedItems);

    this._adapter.notifyChange(values, items);
  }

  handleSortEnd(callbackProps) {
    const {
      oldIndex,
      newIndex
    } = callbackProps;

    const selectedItems = this._adapter.getSelected();

    let selectedArr = [...(0, _values.default)(selectedItems).call(selectedItems)];
    selectedArr = (0, _arrayMove.default)(selectedArr, oldIndex, newIndex);
    let newSelectedItems = new _map2.default();
    (0, _forEach.default)(selectedArr).call(selectedArr, option => {
      newSelectedItems = newSelectedItems.set(option.key, option);
    });

    this._adapter.updateSelected(newSelectedItems);

    this._notifyChange(newSelectedItems);
  }

}

exports.default = TransferFoundation;