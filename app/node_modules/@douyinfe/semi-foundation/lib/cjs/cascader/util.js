"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.calcMergeType = calcMergeType;
exports.convertDataToEntities = convertDataToEntities;
exports.findKeysForValues = findKeysForValues;
exports.isValid = isValid;
exports.normalizedArr = normalizedArr;

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/values"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _isUndefined2 = _interopRequireDefault(require("lodash/isUndefined"));

var _isNull2 = _interopRequireDefault(require("lodash/isNull"));

var _constants = require("./constants");

function getPosition(level, index) {
  var _context;

  return (0, _concat.default)(_context = "".concat(level, "-")).call(_context, index);
}

function isValid(val) {
  return !(0, _isNull2.default)(val) && !(0, _isUndefined2.default)(val);
}

function normalizedArr(val) {
  if (!(0, _isArray.default)(val)) {
    return [val];
  } else {
    return val;
  }
}
/**
 * Traverse all the data by `treeData`.
 */


function traverseDataNodes(treeNodes, callback) {
  const processNode = (node, ind, parent) => {
    const children = node ? node.children : treeNodes;
    let item = null; // Process node if is not root

    if (node) {
      const key = parent ? getPosition(parent.key, ind) : "".concat(ind);
      item = {
        data: (0, _assign.default)({}, node),
        ind,
        key,
        level: parent ? parent.level + 1 : 0,
        parentKey: parent ? parent.key : null,
        path: parent ? [...parent.path, key] : [key],
        valuePath: parent ? [...parent.valuePath, node.value] : [node.value]
      };
      callback(item);
    } // Process children node


    if (children) {
      (0, _forEach.default)(children).call(children, (subNode, subIndex) => {
        processNode(subNode, subIndex, item);
      });
    }
  };

  processNode(null);
}

function convertDataToEntities(dataNodes) {
  const keyEntities = {};
  traverseDataNodes(dataNodes, data => {
    const {
      key,
      parentKey
    } = data;
    const entity = (0, _assign.default)({}, data);
    keyEntities[key] = entity; // Fill children

    entity.parent = keyEntities[parentKey];

    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
  });
  return keyEntities;
}

function findKeysForValues(value, keyEntities) {
  var _context2, _context3;

  const valuePath = normalizedArr(value);
  const res = (0, _map.default)(_context2 = (0, _filter.default)(_context3 = (0, _values.default)(keyEntities)).call(_context3, item => (0, _isEqual2.default)(item.valuePath, valuePath))).call(_context2, item => item.key);
  return res;
}

function calcMergeType(autoMergeValue, leafOnly) {
  let mergeType;

  if (leafOnly) {
    mergeType = _constants.strings.LEAF_ONLY_MERGE_TYPE;
  } else if (autoMergeValue) {
    mergeType = _constants.strings.AUTO_MERGE_VALUE_MERGE_TYPE;
  } else {
    mergeType = _constants.strings.NONE_MERGE_TYPE;
  }

  return mergeType;
}