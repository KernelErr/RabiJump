"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/map"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _findIndex = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/find-index"));

var _splice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/splice"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _isNullOrUndefined = _interopRequireDefault(require("./isNullOrUndefined"));

class Event {
  constructor() {
    this._eventMap = new _map.default();
  }

  on(event, callback) {
    if (event && typeof callback === 'function') {
      this._eventMap.has(event) || this._eventMap.set(event, []);

      this._eventMap.get(event).push(callback);
    }

    return this;
  }

  once(event, callback) {
    var _this = this;

    if (event && typeof callback === 'function') {
      const fn = function () {
        callback(...arguments);

        _this.off(event, fn);
      };

      this.on(event, fn);
    }
  }

  off(event, callback) {
    if (event) {
      if (typeof callback === 'function') {
        const callbacks = this._eventMap.get(event);

        if ((0, _isArray.default)(callbacks) && callbacks.length) {
          let index = -1; // eslint-disable-next-line max-depth

          while ((index = (0, _findIndex.default)(callbacks).call(callbacks, cb => cb === callback)) > -1) {
            (0, _splice.default)(callbacks).call(callbacks, index, 1);
          }
        }
      } else if ((0, _isNullOrUndefined.default)(callback)) {
        this._eventMap.delete(event);
      }
    }

    return this;
  }

  emit(event) {
    var _context;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (!this._eventMap.has(event)) {
      return false;
    }

    (0, _forEach.default)(_context = this._eventMap.get(event)).call(_context, callback => callback(...args));
    return true;
  }

}

exports.default = Event;