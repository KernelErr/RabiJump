"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.empty = empty;
exports.forwardStatics = forwardStatics;
exports.get = get;
exports.has = has;
exports.remove = remove;
exports.set = set;

var _isInteger = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/is-integer"));

var _every = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/every"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _entries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/entries"));

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

var _isNumber2 = _interopRequireDefault(require("lodash/isNumber"));

var _values2 = _interopRequireDefault(require("lodash/values"));

var _unset2 = _interopRequireDefault(require("lodash/unset"));

var _toPath2 = _interopRequireDefault(require("lodash/toPath"));

var _has2 = _interopRequireDefault(require("lodash/has"));

var _set2 = _interopRequireDefault(require("lodash/set"));

var _get2 = _interopRequireDefault(require("lodash/get"));

const pathToArrayElem = path => {
  const pathArray = (0, _toPath2.default)(path); // internal-issues:673

  const justNumber = (0, _isNumber2.default)(path) && pathArray.length === 1;
  return justNumber ? false : (0, _isInteger.default)(+pathArray[pathArray.length - 1]);
};

function isEmptyObject(target) {
  /**
   *  var a = {};
   *  var b = { c: undefined }
   *  var d = {
   *      e: function(){},
   *      f: Symbol(''),
   *  }
   *  the result of JSON.stringify(a/b/d) are same: '{}'
   *  We can use the above features to remove keys with empty values in Form
   *  But we cannot use JSON.stringify() directly, because if the input parameter of JSON.stringify includes fiberNode, it will cause an TypeError: 'Converting circular structure to JSON'
   *  So we have to mock it's behavior, also, the form value cannot have Symbol or function type, it can be ignored
   */
  if (!(0, _isObject2.default)(target)) {
    return false;
  } else {
    const valuesOfTarget = (0, _values2.default)(target); // values(a)  ->   []
    // values(b)  ->   [undefined]

    if (!valuesOfTarget.length) {
      return true; // like target: {}
    } else {
      return (0, _every.default)(valuesOfTarget).call(valuesOfTarget, item => typeof item === 'undefined');
    }
  }
}

function cleanup(obj, path) {
  let pull = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  if (path.length === 0) {
    return;
  }

  const target = (0, _get2.default)(obj, path); // remove undefined from array
  // if (Array.isArray(target) && pull) {
  //     // only remove undefined form array from right to left
  //     // Remove undefined from right to left
  //     let lastIndex = findLastIndex(target, item => !isUndefined(item));
  //     lodashRemove(target, (value, index, array) => index > lastIndex);
  // }
  // Delete object if its empty
  // eslint-disable-next-line

  if ((0, _isArray.default)(target) && (0, _every.default)(target).call(target, e => e == null)) {
    (0, _unset2.default)(obj, path);
  } else if (isEmptyObject(target)) {
    (0, _unset2.default)(obj, path);
  } // Recur


  cleanup(obj, (0, _slice.default)(path).call(path, 0, path.length - 1), pull);
}

function empty(object) {
  return (0, _values2.default)(object).length === 0;
}

function get(object, path) {
  return (0, _get2.default)(object, path);
}

function remove(object, path) {
  (0, _unset2.default)(object, path); // a.b => [a, b]
  // arr[11].a => [arr, 11, a]

  let pathArray = (0, _toPath2.default)(path);
  pathArray = (0, _slice.default)(pathArray).call(pathArray, 0, pathArray.length - 1);
  cleanup(object, pathArray, false);
}

function set(object, path, value, allowEmpty) {
  if (allowEmpty) {
    return (0, _set2.default)(object, path, value);
  }

  if (value !== undefined) {
    return (0, _set2.default)(object, path, value);
  } else {
    // If the path is to an array leaf then we want to set to undefined
    // 将数组的叶子节点置为undefined时，例如 a.b[0]  a.b[1]  a.b[99]
    if (pathToArrayElem(path) && get(object, path) !== undefined) {
      (0, _set2.default)(object, path, undefined);
      let pathArray = (0, _toPath2.default)(path);
      pathArray = (0, _slice.default)(pathArray).call(pathArray, 0, pathArray.length - 1);
      cleanup(object, pathArray, false);
    } else if (!pathToArrayElem(path) && get(object, path) !== undefined) {
      // Only delete the field if it needs to be deleted and its not a path to an array ( array leaf )
      // eg:

      /*
          When the non-array leaf node is set to undefined
          for example: a.b.c
      */
      remove(object, path);
    }
  }
}

function has(object, path) {
  return (0, _has2.default)(object, path);
}
/**
 * set static properties from `srcObj` to `obj`
 * @param {object|Function} obj
 * @param {object|Function} srcObj
 * @returns {object|Function}
 */


function forwardStatics(obj, srcObj) {
  if (obj && (typeof obj === 'function' || typeof obj === 'object') && srcObj && (typeof srcObj === 'function' || typeof srcObj === 'object')) {
    var _context;

    (0, _forEach.default)(_context = (0, _entries.default)(srcObj)).call(_context, _ref => {
      let [key, value] = _ref;
      obj[key] = value;
    });
  }

  return obj;
}