"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _from = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/from"));

var _findIndex2 = _interopRequireDefault(require("lodash/findIndex"));

var _find2 = _interopRequireDefault(require("lodash/find"));

var _slice2 = _interopRequireDefault(require("lodash/slice"));

var _foundation = _interopRequireDefault(require("../base/foundation"));

var _isElement = _interopRequireDefault(require("../utils/isElement"));

var _dom = require("../utils/dom");

class ItemFoundation extends _foundation.default {
  constructor() {
    super(...arguments);
    this._cachedSelectedNode = null;
  }

  selectIndex(index, listWrapper) {
    const {
      type,
      list
    } = this.getProps();

    if (index > -1 && (0, _isArray.default)(list) && list.length && (0, _isElement.default)(listWrapper)) {
      const indexInData = index % list.length;
      const item = list[indexInData];
      const node = listWrapper.children[index];

      this._adapter.setSelectedNode(node);

      this._adapter.notifySelectItem((0, _assign.default)((0, _assign.default)({}, item), {
        value: item.value,
        type,
        index: indexInData
      }));
    }
  }

  selectNode(node, listWrapper) {
    const {
      type,
      list: data
    } = this.getProps();

    if ((0, _isElement.default)(node) && (0, _isElement.default)(listWrapper)) {
      const indexInList = (0, _findIndex2.default)(listWrapper.children, ele => ele === node);
      const indexInData = indexInList % data.length;
      const cachedIndexInList = (0, _findIndex2.default)(listWrapper.children, ele => ele === this._cachedSelectedNode);
      const cachedIndexData = cachedIndexInList % data.length;
      const item = data[indexInData];

      this._adapter.setSelectedNode(node);

      this._adapter.scrollToCenter(node); // Avoid triggerring notifySelectItem twice,
      // because that scroll event will be trigger
      // when you click to select an item.


      if (this._cachedSelectedNode !== node) {
        this._cachedSelectedNode = node;

        if (cachedIndexData !== indexInData) {
          this._adapter.notifySelectItem((0, _assign.default)((0, _assign.default)({}, item), {
            value: item.value,
            type,
            index: indexInData
          }));
        }
      }
    }
  }
  /**
   *
   * @param {HTMLElement} listWrapper
   * @param {HTMLElement} scrollWrapper
   * @param {number} ratio
   * @returns {boolean}
   */


  shouldAppend(listWrapper, scrollWrapper) {
    let ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
    const tag = 'li';

    if ((0, _isElement.default)(listWrapper) && (0, _isElement.default)(scrollWrapper)) {
      const itemNodes = listWrapper.querySelectorAll(tag);
      const lastNode = itemNodes[itemNodes.length - 1];
      const {
        list
      } = this.getProps();

      if (lastNode) {
        const scrollRect = scrollWrapper.getBoundingClientRect();
        const lastRect = lastNode.getBoundingClientRect();
        const listHeight = lastRect.height * list.length;
        let baseTop = lastRect.top;
        let count = 0;

        while (baseTop <= scrollRect.top + scrollRect.height * ratio) {
          count += 1;
          baseTop += listHeight;
        }

        return count;
      }
    }

    return false;
  }
  /**
   *
   * @param {HTMLElement} listWrapper
   * @param {HTMLElement} scrollWrapper
   * @param {number} ratio
   *
   * @returns {boolean}
   */


  shouldPrepend(listWrapper, scrollWrapper) {
    let ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
    const tag = 'li';

    if ((0, _isElement.default)(listWrapper) && (0, _isElement.default)(scrollWrapper)) {
      const itemNodes = listWrapper.querySelectorAll(tag);
      const firstNode = itemNodes[0];
      const {
        list
      } = this.getProps();

      if (firstNode) {
        const scrollRect = scrollWrapper.getBoundingClientRect();
        const firstRect = firstNode.getBoundingClientRect();
        const listHeight = firstRect.height * list.length;
        let baseTop = firstRect.top;
        let count = 0;

        while (baseTop + firstRect.height >= scrollRect.top - scrollRect.height * ratio) {
          count += 1;
          baseTop -= listHeight;
        }

        return count;
      }
    }

    return 0;
  }
  /**
   *
   * @param {HTMLElement} listWrapper
   * @param {HTMLElement} wrapper
   * @param {Function} [callback]
   */


  initWheelList(listWrapper, wrapper, callback) {
    const {
      list
    } = this.getProps();

    if ((0, _isElement.default)(wrapper) && (0, _isElement.default)(listWrapper) && list && list.length) {
      const allNodes = listWrapper.children;
      const baseNodes = (0, _slice2.default)(allNodes, 0, list.length);
      const prependCount = this.shouldPrepend(listWrapper, wrapper);
      const appendCount = this.shouldAppend(listWrapper, wrapper); // this._adapter.setPrependCount(prependCount);
      // this._adapter.setAppendCount(appendCount);

      this._adapter.setState({
        prependCount,
        appendCount
      }, callback);
    }
  }
  /**
   *
   * @param {HTMLElement} listWrapper
   * @param {HTMLElement} wrapper
   * @param {HTMLElement} [nearestNode]
   */


  adjustInfiniteList(listWrapper, wrapper, nearestNode) {
    const {
      list
    } = this.getProps();
    const nodeTag = 'li';

    if ((0, _isElement.default)(wrapper) && (0, _isElement.default)(listWrapper) && list && list.length) {
      const allNodes = listWrapper.querySelectorAll(nodeTag);
      const total = allNodes.length;
      const ratio = 1;
      const prependCount = this.shouldPrepend(listWrapper, wrapper, ratio);
      const appendCount = this.shouldAppend(listWrapper, wrapper, ratio); // while (this.shouldPrepend(listWrapper, wrapper, nearestNode)) {

      if (prependCount) {
        // move last nodes to first position
        for (let i = 0; i < prependCount; i++) {
          const nodes = (0, _slice2.default)(allNodes, total - list.length * (i + 1), total - list.length * i);
          (0, _dom.prepend)(listWrapper, ...nodes);
        }
      } // while (this.shouldAppend(listWrapper, wrapper, nearestNode)) {


      if (appendCount) {
        for (let i = 0; i < appendCount; i++) {
          const nodes = (0, _slice2.default)(allNodes, i * list.length, (i + 1) * list.length);
          (0, _dom.append)(listWrapper, ...nodes);
        }
      }
    }
  }
  /**
   *
   * @param {HTMLElement} listWrapper
   * @param {HTMLElement} selector
   *
   */


  getNearestNodeInfo(listWrapper, selector) {
    if ((0, _isElement.default)(listWrapper) && (0, _isElement.default)(selector)) {
      var _context;

      const selectorRect = selector.getBoundingClientRect();
      const selectorTop = selectorRect.top;
      const itemNodes = listWrapper.querySelectorAll('li');
      let nearestNode = null;
      let nearestIndex = -1;
      let nearestDistance = Infinity;
      (0, _map.default)(_context = (0, _from.default)(itemNodes)).call(_context, (node, index) => {
        const rect = node.getBoundingClientRect();
        const rectTop = rect.top;
        const absDistance = Math.abs(rectTop - selectorTop);

        if (absDistance < nearestDistance && !this._adapter.isDisabledIndex(index)) {
          nearestDistance = absDistance;
          nearestNode = node;
          nearestIndex = index;
        }
      });
      return {
        nearestNode,
        nearestIndex
      };
    }

    return undefined;
  }
  /**
   *
   * @param {HTMLElement} listWrapper
   *
   * @param {HTMLElement|null}
   */


  getTargetNode(e, listWrapper) {
    if (e && (0, _isElement.default)(listWrapper)) {
      const targetTagName = 'li';
      const currentTarget = e.target;
      const itemNodes = listWrapper.querySelectorAll(targetTagName);
      const list = this.getProp('list');
      const length = (0, _isArray.default)(list) ? list.length : 0;
      let targetIndex = -1;
      let indexInList = -1;
      let infoInList = null;
      const targetNode = (0, _find2.default)(itemNodes, (node, index) => {
        if (node === currentTarget || node.contains(currentTarget)) {
          targetIndex = index;

          if (length > 0) {
            indexInList = index % length;
          }

          return true;
        }

        return undefined;
      });

      if (indexInList > -1) {
        infoInList = list[indexInList];
      }

      return {
        targetNode,
        targetIndex,
        indexInList,
        infoInList
      };
    }

    return null;
  }

}

exports.default = ItemFoundation;