"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _lastIndexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/last-index-of"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/values"));

var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _foundation = _interopRequireDefault(require("../base/foundation"));

var _constants = require("./constants");

const Boundary = _constants.strings.BOUNDARY_MAP;
const OverflowDirection = _constants.strings.OVERFLOW_DIR;

class OverflowListFoundation extends _foundation.default {
  constructor(adapter) {
    super((0, _assign.default)({}, adapter));
    this.previousY = undefined;

    this.isScrollMode = () => {
      const {
        renderMode
      } = this.getProps();
      return renderMode === 'scroll';
    };
  }

  getOverflowItem() {
    const {
      items
    } = this.getProps();
    const {
      visibleState,
      overflow
    } = this.getStates();

    if (!this.isScrollMode()) {
      return overflow;
    }

    const visibleStateArr = (0, _map.default)(items).call(items, _ref => {
      let {
        key
      } = _ref;
      return Boolean(visibleState.get(key));
    });
    const visibleStart = (0, _indexOf.default)(visibleStateArr).call(visibleStateArr, true);
    const visibleEnd = (0, _lastIndexOf.default)(visibleStateArr).call(visibleStateArr, true);
    const overflowList = [];
    overflowList[0] = visibleStart >= 0 ? (0, _slice.default)(items).call(items, 0, visibleStart) : [];
    overflowList[1] = visibleEnd >= 0 ? (0, _slice.default)(items).call(items, visibleEnd + 1, items.length) : items;
    return overflowList;
  }

  handleIntersect(entries) {
    const visibleState = (0, _cloneDeep2.default)(this.getState('visibleState'));
    const res = {};
    (0, _forEach.default)(entries).call(entries, entry => {
      const itemKey = (0, _get2.default)(entry, 'target.dataset.scrollkey');
      const visible = entry.isIntersecting;
      res[itemKey] = entry;
      visibleState.set(itemKey, visible);
    });
    let someItemVisible = false;

    for (const value of (0, _values.default)(visibleState).call(visibleState)) {
      if (value) {
        someItemVisible = true;
        break;
      }
    } // Any item is visible, indicating that the List is visible


    const wholeListVisible = someItemVisible; // If scrolling in the vertical direction makes the List invisible, no processing is required. 
    // If this.previousY is undefined, it means that the List is mounted for the first time and will not be processed.

    const [entry1] = entries;
    const currentY = entry1.boundingClientRect.y;

    if (!wholeListVisible && this.previousY !== undefined && currentY !== this.previousY) {
      this.previousY = currentY;
      return;
    }

    this.previousY = currentY;

    this._adapter.updateVisibleState(visibleState);

    this._adapter.notifyIntersect(res);
  }

  handlePartition(growing) {
    const {
      direction,
      overflow,
      lastOverflowCount,
      visible
    } = this.getStates();
    const {
      minVisibleItems,
      collapseFrom,
      items
    } = this.getProps();
    let updateState = {};

    if (growing === OverflowDirection.NONE) {
      updateState = {
        direction: OverflowDirection.NONE
      };
    }

    if (growing === OverflowDirection.GROW) {
      const updatedOverflowCount = direction === OverflowDirection.NONE ? overflow.length : lastOverflowCount;
      updateState = {
        direction: OverflowDirection.GROW,
        lastOverflowCount: updatedOverflowCount,
        overflow: [],
        visible: items
      };
    }

    if (growing === OverflowDirection.SHRINK && visible.length > minVisibleItems) {
      const collapseFromStart = collapseFrom === Boundary.START;
      const newVisible = (0, _slice.default)(visible).call(visible);
      const next = collapseFromStart ? newVisible.shift() : newVisible.pop();

      if (next !== undefined) {
        updateState = {
          // set SHRINK mode unless a GROW is already in progress.
          // GROW shows all items then shrinks until it settles, so we
          // preserve the fact that the original trigger was a GROW.
          direction: direction !== OverflowDirection.GROW ? OverflowDirection.SHRINK : direction,
          overflow: collapseFromStart ? [...overflow, next] : [next, ...overflow],
          visible: newVisible
        };
      }
    }

    this._adapter.updateStates(updateState);
  }

}

var _default = OverflowListFoundation;
exports.default = _default;