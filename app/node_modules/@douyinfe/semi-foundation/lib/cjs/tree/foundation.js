"use strict";

var _filterInstanceProperty2 = require("@babel/runtime-corejs3/core-js-stable/instance/filter");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _set = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/values"));

var _some = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/some"));

var _every = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/every"));

var _setTimeout2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set-timeout"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));

var _pick2 = _interopRequireDefault(require("lodash/pick"));

var _difference2 = _interopRequireDefault(require("lodash/difference"));

var _isUndefined2 = _interopRequireDefault(require("lodash/isUndefined"));

var _foundation = _interopRequireDefault(require("../base/foundation"));

var _treeUtil = require("./treeUtil");

class TreeFoundation extends _foundation.default {
  constructor(adapter) {
    super((0, _assign.default)({}, adapter));

    this.clearDragState = () => {
      this._adapter.updateState({
        dragOverNodeKey: '',
        dragging: false
      });
    };
  }

  _isMultiple() {
    return this.getProp('multiple');
  }

  _isAnimated() {
    return this.getProp('motion');
  }

  _isDisabled() {
    let treeNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this.getProp('disabled') || treeNode.disabled;
  }

  _isExpandControlled() {
    return !(0, _isUndefined2.default)(this.getProp('expandedKeys'));
  }

  _isLoadControlled() {
    return !(0, _isUndefined2.default)(this.getProp('loadedKeys'));
  }

  _isFilterable() {
    // filter can be boolean or function
    return Boolean(this.getProp('filterTreeNode'));
  }

  _showFilteredOnly() {
    const {
      inputValue
    } = this.getStates();
    const {
      showFilteredOnly
    } = this.getProps();
    return Boolean(inputValue) && showFilteredOnly;
  }

  getCopyFromState(items) {
    var _context;

    const res = {};
    (0, _forEach.default)(_context = (0, _treeUtil.normalizedArr)(items)).call(_context, key => {
      res[key] = (0, _cloneDeep2.default)(this.getState(key));
    });
    return res;
  }

  getTreeNodeProps(key) {
    const {
      expandedKeys = new _set.default([]),
      selectedKeys = [],
      checkedKeys = new _set.default([]),
      halfCheckedKeys = new _set.default([]),
      realCheckedKeys = new _set.default([]),
      keyEntities = {},
      filteredKeys = new _set.default([]),
      inputValue = '',
      loadedKeys = new _set.default([]),
      loadingKeys = new _set.default([]),
      filteredExpandedKeys = new _set.default([]),
      disabledKeys = new _set.default([])
    } = this.getStates();
    const {
      treeNodeFilterProp,
      checkRelation
    } = this.getProps();
    const entity = keyEntities[key];
    const notExist = !entity;

    if (notExist) {
      return null;
    } // if checkRelation is invalid, the checked status of node will be false


    let realChecked = false;
    let realHalfChecked = false;

    if (checkRelation === 'related') {
      realChecked = checkedKeys.has(key);
      realHalfChecked = halfCheckedKeys.has(key);
    } else if (checkRelation === 'unRelated') {
      realChecked = realCheckedKeys.has(key);
      realHalfChecked = false;
    }

    const isSearching = Boolean(inputValue);
    const treeNodeProps = {
      eventKey: key,
      expanded: isSearching ? filteredExpandedKeys.has(key) : expandedKeys.has(key),
      selected: (0, _includes.default)(selectedKeys).call(selectedKeys, key),
      checked: realChecked,
      halfChecked: realHalfChecked,
      pos: String(entity ? entity.pos : ''),
      level: entity.level,
      filtered: filteredKeys.has(key),
      loading: loadingKeys.has(key) && !loadedKeys.has(key),
      loaded: loadedKeys.has(key),
      keyword: inputValue,
      treeNodeFilterProp
    };

    if (this.getProp('disableStrictly') && disabledKeys.has(key)) {
      treeNodeProps.disabled = true;
    }

    return treeNodeProps;
  }

  notifyJsonChange(key, e) {
    var _context2;

    const data = this.getProp('treeDataSimpleJson');
    const selectedPath = (0, _map.default)(_context2 = (0, _treeUtil.normalizedArr)(key)).call(_context2, i => i.replace('-', '.'));
    const value = (0, _pick2.default)(data, selectedPath);

    this._adapter.notifyChange(value);
  }

  notifyMultipleChange(key, e) {
    const {
      keyEntities
    } = this.getStates();
    const {
      leafOnly,
      checkRelation
    } = this.getProps();
    let value;
    let keyList = [];

    if (checkRelation === 'related') {
      keyList = (0, _treeUtil.normalizeKeyList)(key, keyEntities, leafOnly);
    } else if (checkRelation === 'unRelated') {
      keyList = key;
    }

    if (this.getProp('onChangeWithObject')) {
      value = (0, _map.default)(keyList).call(keyList, itemKey => keyEntities[itemKey].data);
    } else {
      value = (0, _treeUtil.getValueOrKey)((0, _map.default)(keyList).call(keyList, itemKey => keyEntities[itemKey].data));
    }

    this._adapter.notifyChange(value);
  }

  notifyChange(key, e) {
    const isMultiple = this._isMultiple();

    const {
      keyEntities
    } = this.getStates();

    if (this.getProp('treeDataSimpleJson')) {
      this.notifyJsonChange(key, e);
    } else if (isMultiple) {
      this.notifyMultipleChange(key, e);
    } else {
      let value;

      if (this.getProp('onChangeWithObject')) {
        value = (0, _get2.default)(keyEntities, key).data;
      } else {
        const {
          data
        } = (0, _get2.default)(keyEntities, key);
        value = (0, _treeUtil.getValueOrKey)(data);
      }

      this._adapter.notifyChange(value);
    }
  }

  handleInputChange(sugInput) {
    // Input is a controlled component, so the value value needs to be updated
    this._adapter.updateInputValue(sugInput);

    const {
      expandedKeys,
      selectedKeys,
      keyEntities,
      treeData
    } = this.getStates();
    const {
      showFilteredOnly,
      filterTreeNode,
      treeNodeFilterProp
    } = this.getProps();
    let filteredOptsKeys = [];
    let expandedOptsKeys = [];
    let flattenNodes = [];
    let filteredShownKeys = new _set.default([]);

    if (!sugInput) {
      expandedOptsKeys = (0, _treeUtil.findAncestorKeys)(selectedKeys, keyEntities);
      (0, _forEach.default)(expandedOptsKeys).call(expandedOptsKeys, item => expandedKeys.add(item));
      flattenNodes = (0, _treeUtil.flattenTreeData)(treeData, expandedKeys);
    } else {
      var _context3, _context4;

      filteredOptsKeys = (0, _map.default)(_context3 = (0, _filter.default)(_context4 = (0, _values.default)(keyEntities)).call(_context4, item => (0, _filterInstanceProperty2(_treeUtil))(sugInput, item.data, filterTreeNode, treeNodeFilterProp))).call(_context3, item => item.key);
      expandedOptsKeys = (0, _treeUtil.findAncestorKeys)(filteredOptsKeys, keyEntities, false);
      const shownChildKeys = (0, _treeUtil.findDescendantKeys)(filteredOptsKeys, keyEntities, true);
      filteredShownKeys = new _set.default([...shownChildKeys, ...expandedOptsKeys]);
      flattenNodes = (0, _treeUtil.flattenTreeData)(treeData, new _set.default(expandedOptsKeys), showFilteredOnly && filteredShownKeys);
    }

    this._adapter.notifySearch(sugInput);

    this._adapter.updateState({
      expandedKeys,
      flattenNodes,
      motionKeys: new _set.default([]),
      filteredKeys: new _set.default(filteredOptsKeys),
      filteredExpandedKeys: new _set.default(expandedOptsKeys),
      filteredShownKeys
    });
  }

  handleNodeSelect(e, treeNode) {
    const isDisabled = this._isDisabled(treeNode);

    if (isDisabled) {
      return;
    }

    if (!this._isMultiple()) {
      this.handleSingleSelect(e, treeNode);
    } else {
      this.handleMultipleSelect(e, treeNode);
    }
  }

  handleNodeRightClick(e, treeNode) {
    this._adapter.notifyRightClick(e, treeNode.data);
  }

  handleNodeDoubleClick(e, treeNode) {
    this._adapter.notifyDoubleClick(e, treeNode.data);
  }

  handleSingleSelect(e, treeNode) {
    let {
      selectedKeys
    } = this.getCopyFromState('selectedKeys');
    const {
      selected,
      eventKey,
      data
    } = treeNode;
    const targetSelected = !selected;

    this._adapter.notifySelect(eventKey, true, data);

    if (!targetSelected) {
      return;
    }

    if (!(0, _includes.default)(selectedKeys).call(selectedKeys, eventKey)) {
      selectedKeys = [eventKey];
      this.notifyChange(eventKey, e);

      if (!this._isControlledComponent()) {
        this._adapter.updateState({
          selectedKeys
        });
      }
    }
  }

  calcCheckedKeys(eventKey, targetStatus) {
    const {
      keyEntities
    } = this.getStates();
    const {
      checkedKeys,
      halfCheckedKeys
    } = this.getCopyFromState(['checkedKeys', 'halfCheckedKeys']);
    return targetStatus ? (0, _treeUtil.calcCheckedKeysForChecked)(eventKey, keyEntities, checkedKeys, halfCheckedKeys) : (0, _treeUtil.calcCheckedKeysForUnchecked)(eventKey, keyEntities, checkedKeys, halfCheckedKeys);
  }
  /*
  * Compute the checked state of the node
  */


  calcCheckedStatus(targetStatus, eventKey) {
    // From checked to unchecked, you can change it directly
    if (!targetStatus) {
      return targetStatus;
    } // Starting from unchecked, you need to judge according to the descendant nodes


    const {
      checkedKeys,
      keyEntities,
      disabledKeys
    } = this.getStates();
    const descendantKeys = (0, _treeUtil.normalizeKeyList)((0, _treeUtil.findDescendantKeys)([eventKey], keyEntities, false), keyEntities, true);
    const hasDisabled = (0, _some.default)(descendantKeys).call(descendantKeys, key => disabledKeys.has(key)); // If the descendant nodes are not disabled, they will be directly changed to checked

    if (!hasDisabled) {
      return targetStatus;
    } // If all descendant nodes that are not disabled are selected, return unchecked, otherwise, return checked


    const nonDisabledKeys = (0, _filter.default)(descendantKeys).call(descendantKeys, key => !disabledKeys.has(key));
    const allChecked = (0, _every.default)(nonDisabledKeys).call(nonDisabledKeys, key => checkedKeys.has(key));
    return !allChecked;
  }
  /*
  * In strict disable mode, calculate the nodes of checked and halfCheckedKeys and return their corresponding keys
  */


  calcNonDisabledCheckedKeys(eventKey, targetStatus) {
    const {
      keyEntities,
      disabledKeys
    } = this.getStates();
    const {
      checkedKeys
    } = this.getCopyFromState(['checkedKeys']);
    const descendantKeys = (0, _treeUtil.normalizeKeyList)((0, _treeUtil.findDescendantKeys)([eventKey], keyEntities, false), keyEntities, true);
    const hasDisabled = (0, _some.default)(descendantKeys).call(descendantKeys, key => disabledKeys.has(key)); // If none of the descendant nodes are disabled, follow the normal logic

    if (!hasDisabled) {
      return this.calcCheckedKeys(eventKey, targetStatus);
    }

    const nonDisabled = (0, _filter.default)(descendantKeys).call(descendantKeys, key => !disabledKeys.has(key));
    const newCheckedKeys = targetStatus ? [...nonDisabled, ...checkedKeys] : (0, _difference2.default)((0, _treeUtil.normalizeKeyList)([...checkedKeys], keyEntities, true), nonDisabled);
    return (0, _treeUtil.calcCheckedKeys)(newCheckedKeys, keyEntities);
  }
  /*
  * Handle the selection event in the case of multiple selection
  */


  handleMultipleSelect(e, treeNode) {
    const {
      disableStrictly,
      checkRelation
    } = this.getProps();
    const {
      realCheckedKeys
    } = this.getStates(); // eventKey: The key value of the currently clicked node

    const {
      checked,
      eventKey,
      data
    } = treeNode;

    if (checkRelation === 'related') {
      // Find the checked state of the current node
      const targetStatus = disableStrictly ? this.calcCheckedStatus(!checked, eventKey) : !checked;
      const {
        checkedKeys,
        halfCheckedKeys
      } = disableStrictly ? this.calcNonDisabledCheckedKeys(eventKey, targetStatus) : this.calcCheckedKeys(eventKey, targetStatus);

      this._adapter.notifySelect(eventKey, targetStatus, data);

      this.notifyChange([...checkedKeys], e);

      if (!this._isControlledComponent()) {
        this._adapter.updateState({
          checkedKeys,
          halfCheckedKeys
        });
      }
    } else if (checkRelation === 'unRelated') {
      const newRealCheckedKeys = new _set.default(realCheckedKeys);
      let targetStatus;

      if (realCheckedKeys.has(eventKey)) {
        newRealCheckedKeys.delete(eventKey);
        targetStatus = false;
      } else {
        newRealCheckedKeys.add(eventKey);
        targetStatus = true;
      }

      this._adapter.notifySelect(eventKey, targetStatus, data);

      this.notifyChange([...newRealCheckedKeys], e);

      if (!this._isControlledComponent()) {
        this._adapter.updateState({
          realCheckedKeys: newRealCheckedKeys
        });
      }
    }
  }

  setExpandedStatus(treeNode) {
    const {
      inputValue,
      treeData,
      filteredShownKeys,
      keyEntities
    } = this.getStates();
    const isSearching = Boolean(inputValue);

    const showFilteredOnly = this._showFilteredOnly();

    const expandedStateKey = isSearching ? 'filteredExpandedKeys' : 'expandedKeys';
    const expandedKeys = this.getCopyFromState(expandedStateKey)[expandedStateKey];
    let motionType = 'show';
    const {
      eventKey,
      expanded,
      data
    } = treeNode;

    if (!expanded) {
      expandedKeys.add(eventKey);
    } else if (expandedKeys.has(eventKey)) {
      expandedKeys.delete(eventKey);
      motionType = 'hide';
    }

    this._adapter.cacheFlattenNodes(motionType === 'hide' && this._isAnimated());

    if (!this._isExpandControlled()) {
      const flattenNodes = (0, _treeUtil.flattenTreeData)(treeData, expandedKeys, isSearching && showFilteredOnly && filteredShownKeys);
      const motionKeys = this._isAnimated() ? (0, _treeUtil.getMotionKeys)(eventKey, expandedKeys, keyEntities) : [];
      const newState = {
        [expandedStateKey]: expandedKeys,
        flattenNodes,
        motionKeys: new _set.default(motionKeys),
        motionType
      };

      this._adapter.updateState(newState);
    }

    return {
      expandedKeys,
      expanded: !expanded,
      data
    };
  }

  handleNodeExpand(e, treeNode) {
    const {
      loadData
    } = this.getProps();

    if (!loadData && (!treeNode.children || !treeNode.children.length)) {
      return;
    }

    const {
      expandedKeys,
      data,
      expanded
    } = this.setExpandedStatus(treeNode);

    this._adapter.notifyExpand(expandedKeys, {
      expanded,
      node: data
    });
  } // eslint-disable-next-line max-len


  handleNodeLoad(loadedKeys, loadingKeys, data, resolve) {
    const {
      loadData,
      onLoad
    } = this.getProps();
    const {
      key
    } = data;

    if (!loadData || loadedKeys.has(key) || loadingKeys.has(key)) {
      return {};
    } // Process the loaded data


    loadData(data).then(() => {
      const {
        loadedKeys: prevLoadedKeys,
        loadingKeys: prevLoadingKeys
      } = this.getCopyFromState(['loadedKeys', 'loadingKeys']);
      const newLoadedKeys = prevLoadedKeys.add(key);
      const newLoadingKeys = new _set.default([...prevLoadingKeys]);
      newLoadingKeys.delete(key); // onLoad should be triggered before internal setState to avoid `loadData` being triggered twice

      onLoad && onLoad(newLoadedKeys, data);

      if (!this._isLoadControlled()) {
        this._adapter.updateState({
          loadedKeys: newLoadedKeys
        });
      }

      this._adapter.setState({
        loadingKeys: newLoadingKeys
      });

      resolve();
    });
    return {
      loadingKeys: loadingKeys.add(key)
    };
  } // Drag and drop related processing logic


  getDragEventNodeData(node) {
    return (0, _assign.default)((0, _assign.default)({}, node.data), (0, _pick2.default)(node, ['expanded', 'pos', 'children']));
  }

  triggerDragEvent(name, event, node) {
    let extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const callEvent = this.getProp(name);
    callEvent && callEvent((0, _assign.default)({
      event,
      node: this.getDragEventNodeData(node)
    }, extra));
  }

  handleNodeDragStart(e, treeNode) {
    const {
      keyEntities
    } = this.getStates();
    const {
      hideDraggingNode,
      renderDraggingNode
    } = this.getProps();
    const {
      eventKey,
      nodeInstance,
      data
    } = treeNode;

    if (hideDraggingNode || renderDraggingNode) {
      let dragImg;

      if (typeof renderDraggingNode === 'function') {
        dragImg = renderDraggingNode(nodeInstance, data);
      } else if (hideDraggingNode) {
        dragImg = nodeInstance.cloneNode(true);
        dragImg.style.opacity = 0;
      }

      document.body.appendChild(dragImg);
      e.dataTransfer.setDragImage(dragImg, 0, 0);
    }

    this._adapter.setDragNode(treeNode);

    this._adapter.updateState({
      dragging: true,
      dragNodesKeys: new _set.default((0, _treeUtil.getDragNodesKeys)(eventKey, keyEntities))
    });

    this.triggerDragEvent('onDragStart', e, treeNode);
  }

  handleNodeDragEnter(e, treeNode, dragNode) {
    const {
      dragging,
      dragNodesKeys
    } = this.getStates();
    const {
      autoExpandWhenDragEnter
    } = this.getProps();
    const {
      pos,
      eventKey,
      expanded
    } = treeNode;

    if (!dragNode || dragNodesKeys.has(eventKey)) {
      return;
    }

    const dropPosition = (0, _treeUtil.calcDropRelativePosition)(e, treeNode); // If the drag node is itself, skip

    if (dragNode.eventKey === eventKey && dropPosition === 0) {
      this._adapter.updateState({
        dragOverNodeKey: '',
        dropPosition: null
      });

      return;
    } // Trigger dragenter after clearing the prev state in dragleave


    (0, _setTimeout2.default)(() => {
      var _context5;

      this._adapter.updateState({
        dragOverNodeKey: eventKey,
        dropPosition
      }); // If autoExpand is already expanded or not allowed, trigger the event and return


      if (!autoExpandWhenDragEnter || expanded) {
        this.triggerDragEvent('onDragEnter', e, treeNode);
        return;
      } // Side effects of delayed drag


      if (!this.delayedDragEnterLogic) {
        this.delayedDragEnterLogic = {};
      }

      (0, _forEach.default)(_context5 = (0, _keys.default)(this.delayedDragEnterLogic)).call(_context5, key => {
        clearTimeout(this.delayedDragEnterLogic[key]);
      });
      this.delayedDragEnterLogic[pos] = (0, _setTimeout2.default)(() => {
        if (!dragging) {
          return;
        }

        const {
          expandedKeys: newExpandedKeys
        } = this.setExpandedStatus(treeNode);
        this.triggerDragEvent('onDragEnter', e, treeNode, {
          expandedKeys: [...newExpandedKeys]
        });
      }, 400);
    }, 0);
  }

  handleNodeDragOver(e, treeNode, dragNode) {
    const {
      dropPosition,
      dragNodesKeys,
      dragOverNodeKey
    } = this.getStates();
    const {
      eventKey
    } = treeNode;

    if (dragNodesKeys.has(eventKey)) {
      return;
    } // Update the drag position


    if (dragNode && eventKey === dragOverNodeKey) {
      const newPos = (0, _treeUtil.calcDropRelativePosition)(e, treeNode);

      if (dropPosition === newPos) {
        return;
      }

      this._adapter.updateState({
        dropPosition: newPos
      });
    }

    this.triggerDragEvent('onDragOver', e, treeNode);
  }

  handleNodeDragLeave(e, treeNode) {
    this._adapter.updateState({
      dragOverNodeKey: ''
    });

    this.triggerDragEvent('onDragLeave', e, treeNode);
  }

  handleNodeDragEnd(e, treeNode) {
    this.clearDragState();
    this.triggerDragEvent('onDragEnd', e, treeNode);

    this._adapter.setDragNode(null);
  }

  handleNodeDrop(e, treeNode, dragNode) {
    const {
      dropPosition,
      dragNodesKeys
    } = this.getStates();
    const {
      eventKey,
      pos
    } = treeNode;
    this.clearDragState();

    if (dragNodesKeys.has(eventKey)) {
      return;
    }

    const dropRes = {
      dragNode: dragNode ? this.getDragEventNodeData(dragNode) : null,
      dragNodesKeys: [...dragNodesKeys],
      dropPosition: (0, _treeUtil.calcDropActualPosition)(pos, dropPosition),
      dropToGap: dropPosition !== 0
    };
    this.triggerDragEvent('onDrop', e, treeNode, dropRes);

    this._adapter.setDragNode(null);
  }

}

exports.default = TreeFoundation;