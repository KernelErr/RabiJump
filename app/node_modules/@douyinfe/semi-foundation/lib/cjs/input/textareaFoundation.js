"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));

var _isString2 = _interopRequireDefault(require("lodash/isString"));

var _isNumber2 = _interopRequireDefault(require("lodash/isNumber"));

var _isFunction2 = _interopRequireDefault(require("lodash/isFunction"));

var _noop2 = _interopRequireDefault(require("lodash/noop"));

var _foundation = _interopRequireDefault(require("../base/foundation"));

var _calculateNodeHeight = _interopRequireDefault(require("./util/calculateNodeHeight"));

var _getSizingData = _interopRequireDefault(require("./util/getSizingData"));

class TextAreaFoundation extends _foundation.default {
  constructor(adapter) {
    super((0, _assign.default)((0, _assign.default)({}, TextAreaFoundation.textAreaDefaultAdapter), adapter));

    this.resizeTextarea = cb => {
      const {
        height
      } = this.getStates();
      const {
        rows
      } = this.getProps();

      const node = this._adapter.getRef().current;

      const nodeSizingData = (0, _getSizingData.default)(node);

      if (!nodeSizingData) {
        cb && cb();
        return;
      }

      const newHeight = (0, _calculateNodeHeight.default)(nodeSizingData, node.value || node.placeholder || 'x', rows // maxRows,
      );

      if (height !== newHeight) {
        this._adapter.notifyHeightUpdate(newHeight);

        node.style.height = "".concat(newHeight, "px");
        return;
      }

      cb && cb();
    };
  }

  static get textAreaDefaultAdapter() {
    return {
      notifyChange: _noop2.default,
      setValue: _noop2.default,
      toggleFocusing: _noop2.default,
      toggleHovering: _noop2.default,
      notifyFocus: _noop2.default,
      notifyBlur: _noop2.default,
      notifyKeyDown: _noop2.default,
      notifyEnterPress: _noop2.default
    };
  }

  init() {
    this.setInitValue();
  } // eslint-disable-next-line


  destroy() {}

  setInitValue() {
    const {
      defaultValue,
      value
    } = this.getProps();
    let v = defaultValue;

    if (this._isControlledComponent()) {
      v = value;
    }

    this._adapter.setValue(v);
  }

  handleValueChange(v) {
    this._adapter.setValue(v);
  }

  handleChange(value, e) {
    const {
      maxLength,
      minLength,
      getValueLength
    } = this._adapter.getProps();

    let nextValue = value;

    if (maxLength && (0, _isFunction2.default)(getValueLength)) {
      nextValue = this.handleVisibleMaxLength(value);
    }

    if (minLength && (0, _isFunction2.default)(getValueLength)) {
      this.handleVisibleMinLength(nextValue);
    }

    if (this._isControlledComponent()) {
      this._adapter.notifyChange(nextValue, e);
    } else {
      this._adapter.setValue(nextValue);

      this._adapter.notifyChange(nextValue, e);
    }
  }
  /**
   * Modify minLength to trigger browser check for minimum length
   * Controlled mode is not checked
   * @param {String} value
   */


  handleVisibleMinLength(value) {
    const {
      minLength,
      getValueLength
    } = this._adapter.getProps();

    const {
      minLength: stateMinLength
    } = this._adapter.getStates();

    if ((0, _isNumber2.default)(minLength) && minLength >= 0 && (0, _isFunction2.default)(getValueLength) && (0, _isString2.default)(value)) {
      const valueLength = getValueLength(value);

      if (valueLength < minLength) {
        const newMinLength = value.length + (minLength - valueLength);
        newMinLength !== stateMinLength && this._adapter.setMinLength(newMinLength);
      } else {
        stateMinLength !== minLength && this._adapter.setMinLength(minLength);
      }
    }
  }
  /**
   * Handle input emoji characters beyond maxLength
   * Controlled mode is not checked
   * @param {String} value
   */


  handleVisibleMaxLength(value) {
    const {
      maxLength,
      getValueLength
    } = this._adapter.getProps();

    if ((0, _isNumber2.default)(maxLength) && maxLength >= 0 && (0, _isFunction2.default)(getValueLength) && (0, _isString2.default)(value)) {
      const valueLength = getValueLength(value);

      if (valueLength > maxLength) {
        // eslint-disable-next-line max-len
        console.warn('[Semi TextArea] The input character is truncated because the input length exceeds the maximum length limit');
        const truncatedValue = this.handleTruncateValue(value, maxLength);
        return truncatedValue;
      } else {
        return value;
      }
    }

    return undefined;
  }
  /**
   * Truncate textarea values based on maximum length
   * @param {String} value
   * @param {Number} maxLength
   * @returns {String}
   */


  handleTruncateValue(value, maxLength) {
    const {
      getValueLength
    } = this._adapter.getProps();

    if ((0, _isFunction2.default)(getValueLength)) {
      let truncatedValue = '';

      for (let i = 1, len = value.length; i <= len; i++) {
        const currentValue = (0, _slice.default)(value).call(value, 0, i);

        if (getValueLength(currentValue) > maxLength) {
          return truncatedValue;
        } else {
          truncatedValue = currentValue;
        }
      }

      return truncatedValue;
    } else {
      return (0, _slice.default)(value).call(value, 0, maxLength);
    }
  }

  handleFocus(e) {
    const {
      value
    } = this.getStates();

    this._adapter.toggleFocusing(true);

    this._adapter.notifyFocus(value, e);
  }

  handleBlur(e) {
    const {
      value
    } = this.getStates();

    this._adapter.toggleFocusing(false);

    this._adapter.notifyBlur(value, e);
  }

  handleKeyDown(e) {
    this._adapter.notifyKeyDown(e);

    if (e.keyCode === 13) {
      this._adapter.notifyPressEnter(e);
    }
  }

  handleMouseEnter(e) {
    this._adapter.toggleHovering(true);
  }

  handleMouseLeave(e) {
    this._adapter.toggleHovering(false);
  }

  isAllowClear() {
    const {
      value,
      isFocus,
      isHover
    } = this._adapter.getStates();

    const {
      showClear,
      disabled,
      readonly
    } = this._adapter.getProps();

    const allowClear = value && showClear && !disabled && (isFocus || isHover) && !readonly;
    return allowClear;
  }

  handleClear(e) {
    const {
      isFocus
    } = this.getStates();

    if (this._isControlledComponent('value')) {
      this._adapter.setState({
        isFocus: false
      });
    } else {
      this._adapter.setState({
        value: '',
        isFocus: false
      });
    }

    if (isFocus) {
      this._adapter.notifyBlur('', e);
    }

    this._adapter.notifyChange('', e);

    this._adapter.notifyClear(e);

    this.stopPropagation(e);
  }

}

exports.default = TextAreaFoundation;