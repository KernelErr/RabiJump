"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _findIndex = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/find-index"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

var _findLastIndex2 = _interopRequireDefault(require("lodash/findLastIndex"));

var _isMap2 = _interopRequireDefault(require("lodash/isMap"));

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _foundation = _interopRequireDefault(require("../base/foundation"));

var _constants = require("./constants");

var _utils = require("./utils");

class TableBodyFoundation extends _foundation.default {
  init() {
    this.initVirtualizedData();
    this.initExpandBtnShouldInRow();
  }

  destroy() {
    this.unobserveBodyResize();
  }

  initVirtualizedData(cb) {
    this._adapter.setVirtualizedData(this.flattenData(this.getProp('dataSource')), cb);
  }

  initExpandBtnShouldInRow(newExpandRelatedProps) {
    const props = this.getProps(); // TODO check: this._adapter.getProps -> this.getProps

    const cachedExpandBtnShouldInRow = (0, _utils.expandBtnShouldInRow)(props);

    this._adapter.setCachedExpandBtnShouldInRow(cachedExpandBtnShouldInRow);

    if (!(0, _isObject2.default)(newExpandRelatedProps) && !newExpandRelatedProps) {
      const expandRelatedProps = _constants.strings.EXPAND_RELATED_PROPS; // eslint-disable-next-line no-param-reassign

      newExpandRelatedProps = (0, _map.default)(expandRelatedProps).call(expandRelatedProps, key => (0, _get2.default)(props, key, undefined));
    }

    this._adapter.setCachedExpandRelatedProps(newExpandRelatedProps);
  }

  flattenData() {
    let dataSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let parentKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    let childrenKeys = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    const flattenData = [];
    const {
      rowKey,
      childrenRecordName,
      expandedRowRender,
      expandedRowKeys,
      groups
    } = this.getProps();

    if (level === 0 && (0, _isMap2.default)(groups)) {
      (0, _forEach.default)(groups).call(groups, (set, key) => {
        const firstIndex = (0, _findIndex.default)(dataSource).call(dataSource, record => set.has((0, _utils.getRecordKey)(record, rowKey)));

        if (firstIndex > -1) {
          const lastIndex = (0, _findLastIndex2.default)(dataSource, record => set.has((0, _utils.getRecordKey)(record, rowKey)));
          const expanded = (0, _includes2.default)(expandedRowKeys, key);
          flattenData.push({
            key,
            level,
            sectionRow: true,
            group: set,
            groupKey: key,
            expanded
          });

          if (expanded) {
            flattenData.push(...this.flattenData((0, _slice.default)(dataSource).call(dataSource, firstIndex, lastIndex + 1), level + 1, [...parentKeys], [...childrenKeys]));
          }
        }
      });
    } else {
      (0, _forEach.default)(dataSource).call(dataSource, (record, index) => {
        const recordKey = (0, _utils.getRecordKey)(record, rowKey);
        const children = (0, _utils.getRecordChildren)(record, childrenRecordName);

        if (level) {
          childrenKeys.push(recordKey);
        }

        const item = {
          key: recordKey,
          record,
          level,
          parentKeys: [...parentKeys],
          childrenKeys: [...childrenKeys]
        };
        flattenData.push(item);
        const extras = [];

        if ((0, _includes2.default)(expandedRowKeys, recordKey)) {
          if ((0, _isArray.default)(children) && children.length) {
            extras.push(...this.flattenData(children, level + 1, [...item.parentKeys], [...item.childrenKeys]));
          } else if (expandedRowRender) {
            extras.push({
              key: (0, _utils.genExpandedRowKey)(recordKey),
              level,
              expandedRow: true,
              record
            });
          }

          flattenData.push(...extras);
        }
      });
    }

    return flattenData;
  }
  /**
   * Use ResizeObserver to monitor changes in the size of the body content area, and notify Table to recalculate if it changes. columns #1219
   * (Only monitor the scroll.y scene, other scenes are not monitored, because the header of the scroll.y scene is a separate table, and a scrollbar column will be inserted)
   */


  observeBodyResize(bodyDOM) {
    const {
      scroll
    } = this.getProps(); // TODO check: this._adapter.getProps -> this.getProps

    if ((0, _get2.default)(scroll, 'y')) {
      return this._adapter.observeBodyResize(bodyDOM);
    }
  }

  unobserveBodyResize() {
    return this._adapter.unobserveBodyResize();
  }

}

exports.default = TableBodyFoundation;