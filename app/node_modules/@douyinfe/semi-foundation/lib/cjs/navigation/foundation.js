"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _set = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _foundation = _interopRequireDefault(require("../base/foundation"));

var _NavItem = _interopRequireDefault(require("./NavItem"));

var _constants = require("./constants");

var _isNullOrUndefined = _interopRequireDefault(require("../utils/isNullOrUndefined"));

/* eslint-disable max-depth */

/* eslint-disable max-len */
class NavigationFoundation extends _foundation.default {
  constructor(adapter) {
    super((0, _assign.default)({}, adapter));
  }
  /* istanbul ignore next */


  static getZeroParentKeys() {
    let itemKeysMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const willAddKeys = [];

    for (var _len = arguments.length, itemKeys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      itemKeys[_key - 1] = arguments[_key];
    }

    if (itemKeys.length) {
      for (const itemKey of itemKeys) {
        if ((0, _isArray.default)(itemKeysMap[itemKey]) && itemKeysMap[itemKey].length) {
          const levelZeroParentKey = itemKeysMap[itemKey][0];

          if (!(0, _isNullOrUndefined.default)(levelZeroParentKey)) {
            willAddKeys.push(levelZeroParentKey);
          }
        }
      }
    }

    return willAddKeys;
  }

  static buildItemKeysMap() {
    let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let keysMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let parentKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    let keyPropName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'itemKey';

    if ((0, _isArray.default)(items) && items.length) {
      for (const item of items) {
        if ((0, _isArray.default)(item)) {
          NavigationFoundation.buildItemKeysMap(item, keysMap, [...parentKeys], keyPropName);
        } else {
          let itemKey;

          if (item && typeof item === 'object') {
            itemKey = item[keyPropName] || item.props && item.props[keyPropName];
          }

          if (itemKey) {
            keysMap[itemKey] = [...parentKeys];

            if ((0, _isArray.default)(item.items) && item.items.length) {
              NavigationFoundation.buildItemKeysMap(item.items, keysMap, [...parentKeys, itemKey], keyPropName);
            } else if (item.props && item.props.children) {
              const children = (0, _isArray.default)(item.props.children) ? item.props.children : [item.props.children];
              NavigationFoundation.buildItemKeysMap(children, keysMap, [...parentKeys, itemKey], keyPropName);
            }
          }
        }
      }
    }

    return keysMap;
  }
  /**
   * init is called in constructor and componentDidMount.
   * if you want to update state in constructor, please add it to return object;
   * if you want to update state in componentDidMount, please call adapter in else logic.
   * @param {*} lifecycle
   * @returns
   */


  init(lifecycle) {
    const {
      defaultSelectedKeys,
      selectedKeys
    } = this.getProps();
    let willSelectedKeys = selectedKeys || defaultSelectedKeys || [];
    const {
      itemKeysMap,
      willOpenKeys,
      formattedItems
    } = this.getCalcState();
    const parentSelectKeys = this.selectLevelZeroParentKeys(itemKeysMap, willSelectedKeys);
    willSelectedKeys = (0, _concat.default)(willSelectedKeys).call(willSelectedKeys, parentSelectKeys);

    if (lifecycle === 'constructor') {
      return {
        selectedKeys: willSelectedKeys,
        itemKeysMap,
        openKeys: willOpenKeys,
        items: formattedItems
      };
    } else {
      this._adapter.updateSelectedKeys(willSelectedKeys);

      this._adapter.setItemKeysMap(itemKeysMap);

      this._adapter.updateOpenKeys(willOpenKeys);

      this._adapter.updateItems(formattedItems);

      this._adapter.setItemsChanged(true);
    }

    return undefined;
  }
  /**
   * Get the state to be calculated
   */


  getCalcState() {
    const {
      itemKeysMap,
      formattedItems
    } = this.getFormattedItems();
    const willOpenKeys = this.getWillOpenKeys(itemKeysMap);
    return {
      itemKeysMap,
      willOpenKeys,
      formattedItems
    };
  }
  /**
   * Calculate formatted items and itemsKeyMap
   */


  getFormattedItems() {
    const {
      items,
      children
    } = this.getProps();
    const formattedItems = this.formatItems(items);
    const willHandleItems = (0, _isArray.default)(items) && items.length ? formattedItems : children;
    const itemKeysMap = NavigationFoundation.buildItemKeysMap(willHandleItems);
    return {
      itemKeysMap,
      formattedItems
    };
  }
  /**
   * Calculate the keys that will need to be opened soon
   * @param {*} itemKeysMap
   */


  getWillOpenKeys(itemKeysMap) {
    const {
      defaultOpenKeys,
      openKeys,
      defaultSelectedKeys,
      selectedKeys,
      mode
    } = this.getProps();
    let willOpenKeys = openKeys || defaultOpenKeys || [];

    if (!((0, _isArray.default)(defaultOpenKeys) || (0, _isArray.default)(openKeys)) && mode === _constants.strings.MODE_VERTICAL && ((0, _isArray.default)(defaultSelectedKeys) || (0, _isArray.default)(selectedKeys))) {
      const currentSelectedKeys = (0, _isArray.default)(selectedKeys) ? selectedKeys : defaultSelectedKeys;
      willOpenKeys = this.getShouldOpenKeys(itemKeysMap, currentSelectedKeys);
    }

    return [...willOpenKeys];
  }

  getItemKey(item) {
    let keyPropName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'itemKey';

    if (item && typeof item === 'object') {
      return item[keyPropName];
    }

    return item;
  }

  getShouldOpenKeys() {
    let itemKeysMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let selectedKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    const willOpenKeySet = new _set.default();

    if ((0, _isArray.default)(selectedKeys) && selectedKeys.length) {
      (0, _forEach.default)(selectedKeys).call(selectedKeys, item => {
        if (item) {
          const parentKeys = (0, _get2.default)(itemKeysMap, this.getItemKey(item));

          if ((0, _isArray.default)(parentKeys)) {
            (0, _forEach.default)(parentKeys).call(parentKeys, k => willOpenKeySet.add(k));
          }
        }
      });
    }

    return [...willOpenKeySet];
  }

  destroy() {} // eslint-disable-line


  selectLevelZeroParentKeys(itemKeysMap) {
    const _itemKeysMap = (0, _isNullOrUndefined.default)(itemKeysMap) ? this.getState('itemKeysMap') : itemKeysMap; // console.log(itemKeysMap);


    const willAddKeys = [];

    for (var _len2 = arguments.length, itemKeys = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      itemKeys[_key2 - 1] = arguments[_key2];
    }

    if (itemKeys.length) {
      for (const itemKey of itemKeys) {
        if ((0, _isArray.default)(_itemKeysMap[itemKey]) && _itemKeysMap[itemKey].length) {
          const levelZeroParentKey = _itemKeysMap[itemKey][0];

          if (!(0, _isNullOrUndefined.default)(levelZeroParentKey)) {
            willAddKeys.push(levelZeroParentKey);
          }
        }
      }
    }

    if (willAddKeys.length) {
      return willAddKeys;
    }

    return [];
  }

  formatItems() {
    let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    const formattedItems = [];

    for (const item of items) {
      formattedItems.push(new _NavItem.default(item));
    }

    return formattedItems;
  }

  handleSelect(data) {
    this._adapter.notifySelect(data);
  }
  /* istanbul ignore next */


  judgeIfOpen(openKeys, items) {
    let shouldBeOpen = false;

    const _openKeys = (0, _isArray.default)(openKeys) ? openKeys : openKeys && [openKeys];

    if (_openKeys && (0, _isArray.default)(items) && items.length) {
      for (const item of items) {
        shouldBeOpen = (0, _includes.default)(_openKeys).call(_openKeys, item.itemKey) || this.judgeIfOpen(_openKeys, item.items);

        if (shouldBeOpen) {
          break;
        }
      }
    }

    return shouldBeOpen;
  }

  handleCollapseChange() {
    const isCollapsed = !this.getState('isCollapsed');

    if (!this._isControlledComponent('isCollapsed')) {
      this._adapter.setIsCollapsed(isCollapsed);
    }

    this._adapter.notifyCollapseChange(isCollapsed);
  }

  handleItemsChange(isChanged) {
    this._adapter.setItemsChanged(isChanged);
  }

}

exports.default = NavigationFoundation;