import BaseFoundation, { DefaultAdapter } from '../base/foundation';
export interface InputNumberAdapter extends DefaultAdapter {
    setValue: (value: number | string, cb?: (...args: any[]) => void) => void;
    setNumber: (number: number | null, cb?: (...args: any[]) => void) => void;
    setFocusing: (focusing: boolean, cb?: (...args: any[]) => void) => void;
    setHovering: (hovering: boolean) => void;
    notifyChange: (value: string | number, e?: any) => void;
    notifyNumberChange: (value: number, e?: any) => void;
    notifyBlur: (e: any) => void;
    notifyFocus: (e: any) => void;
    notifyUpClick: (value: string, e: any) => void;
    notifyDownClick: (value: string, e: any) => void;
    notifyKeyDown: (e: any) => void;
    registerGlobalEvent: (eventName: string, handler: (...args: any[]) => void) => void;
    unregisterGlobalEvent: (eventName: string) => void;
    recordCursorPosition: () => void;
    restoreByAfter: (str?: string) => boolean;
    restoreCursor: (str?: string) => boolean;
    fixCaret: (start: number, end: number) => void;
    setClickUpOrDown: (clicked: boolean) => void;
    updateStates: (states: BaseInputNumberState, callback?: () => void) => void;
}
export interface BaseInputNumberState {
    value?: number | string;
    number?: number | null;
    focusing?: boolean;
    hovering?: boolean;
}
declare class InputNumberFoundation extends BaseFoundation<InputNumberAdapter> {
    _intervalHasRegistered: boolean;
    _interval: any;
    _timerHasRegistered: boolean;
    _timer: any;
    init(): void;
    destroy(): void;
    isControlled(): boolean;
    _doInput(v?: string, event?: any, updateCb?: any): void;
    _registerInterval(cb?: (...args: any) => void): void;
    _unregisterInterval(): void;
    _registerTimer(cb: (...args: any[]) => void): void;
    _unregisterTimer(): void;
    handleInputFocus(e: any): void;
    /**
     * Input box content update processing
     * @param {String} value
     * @param {*} event
     */
    handleInputChange(value: string, event: any): void;
    handleInputKeyDown(event: any): void;
    handleInputBlur(e: any): void;
    handleInputMouseEnter(event?: any): void;
    handleInputMouseLeave(event?: any): void;
    handleInputMouseMove(event?: any): void;
    handleMouseUp(e?: any): void;
    handleUpClick(event: any): void;
    handleDownClick(event: any): void;
    /**
     * Whether it is a left mouse button click
     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
     */
    _isMouseButtonLeft(event: any): boolean;
    _preventDefault(event: any): void;
    handleMouseLeave(event: any): void;
    upClick(event: any): void;
    downClick(event: any): void;
    _setInitValue(): void;
    add(step?: number, event?: any): string;
    minus(step?: number, event?: any): string;
    /**
     * get decimal length
     * @param {number} num
     * @returns {number}
     */
    _getPrecLen(num: string | number): number;
    _adjustPrec(num: string | number): string;
    /**
     * format number to string
     * @param {string|number} value
     * @param {boolean} needAdjustPrec
     * @returns {string}
     */
    doFormat(value?: string | number, needAdjustPrec?: boolean): string;
    /**
     *
     * @param {number} current
     * @returns {number}
     */
    fetchMinOrMax(current: number): any;
    /**
     * parse to number
     * @param {string|number} value
     * @param {boolean} needCheckPrec
     * @param {boolean} needAdjustPrec
     * @param {boolean} needAdjustMaxMin
     * @returns {number}
     */
    doParse(value: string | number, needCheckPrec?: boolean, needAdjustPrec?: boolean, needAdjustMaxMin?: boolean): any;
    /**
     * Parsing the input value
     * @param {string} value
     * @returns {string}
     */
    afterParser(value: string): string;
    toNumber(value: number | string, needAdjustPrec?: boolean): number;
    /**
     * Returning true requires both:
     * 1.type is number and not equal to NaN
     * 2.min < = value < = max
     * 3.length after decimal point requires < = precision | | No precision
     * @param {*} um
     * @param {*} needCheckPrec
     * @returns
     */
    isValidNumber(num: number, needCheckPrec?: boolean): boolean;
    isValidString(str: string): boolean;
    notifyChange(value: string, e: any): void;
    notifyNumberChange(value: number, e: any): void;
    updateStates(states: BaseInputNumberState, callback?: () => void): void;
}
export default InputNumberFoundation;
