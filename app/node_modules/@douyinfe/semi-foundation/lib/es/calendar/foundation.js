import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _Date$now from "@babel/runtime-corejs3/core-js-stable/date/now";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _keysInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/keys";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _sortInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/sort";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _entriesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/entries";
import _Map from "@babel/runtime-corejs3/core-js-stable/map";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _sliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/slice";
import BaseFoundation from '../base/foundation';
import { format, getWeeksInMonth, getWeekOfMonth, isSameMonth, startOfMonth, endOfMonth, isBefore, isAfter, addDays, startOfWeek, differenceInCalendarDays, isSameDay, startOfDay, isSameWeek } from 'date-fns';
import { parseEvent, parseAllDayEvent, calcWeekData, getCurrDate, parseWeeklyAllDayEvent, sortDate, collectDailyEvents, round, getPos, convertEventsArrToMap, filterWeeklyEvents, renderDailyEvent, calcRangeData, filterEvents, parseRangeAllDayEvent, checkWeekend } from './eventUtil';
export default class CalendarFoundation extends BaseFoundation {
  constructor(adapter) {
    super(_Object$assign({}, adapter));
  } // eslint-disable-next-line @typescript-eslint/no-empty-function


  init() {}

  destroy() {
    this.raf && cancelAnimationFrame(this.raf);
  }

  initCurrTime() {
    const {
      showCurrTime,
      displayValue
    } = this.getProps();

    if (showCurrTime && isSameDay(displayValue, getCurrDate())) {
      this._adapter.updateShowCurrTime();

      this.getCurrLocation();
    }
  }

  notifyScrollHeight(height) {
    this._adapter.updateScrollHeight(height);
  }

  closeCard(e, key) {
    this._adapter.unregisterClickOutsideHandler();

    this._adapter.notifyClose(e, key);
  }

  _getDate() {
    const {
      displayValue
    } = this.getProps();
    return displayValue || getCurrDate();
  }

  showCard(e, key) {
    this._adapter.unregisterClickOutsideHandler();

    const bodyWidth = document.querySelector('body').clientWidth;
    const popoverWidth = 110;
    const spacing = bodyWidth - e.target.getBoundingClientRect().right - popoverWidth;

    this._adapter.openCard(key, spacing > 0);

    this._adapter.registerClickOutsideHandler(key, () => {
      this.closeCard(null, key);
    });
  }

  formatCbValue(val) {
    const date = val.shift();
    const dateArr = [date.getFullYear(), date.getMonth(), date.getDate(), ...val]; // @ts-ignore skip

    return new Date(...dateArr);
  }
  /**
   *
   * find the location of showCurrTime red line
   */


  getCurrLocation() {
    let startTime = null;
    let pos = getPos(getCurrDate());

    this._adapter.updateCurrPos(round(pos));

    const frameFunc = () => {
      const timestamp = _Date$now();

      if (!startTime) {
        startTime = timestamp;
      }

      const time = timestamp - startTime;

      if (time > 30000) {
        pos = getPos(getCurrDate());

        this._adapter.updateCurrPos(round(pos));

        startTime = timestamp;
      }

      this.raf = requestAnimationFrame(frameFunc);
    };

    this.raf = requestAnimationFrame(frameFunc);
  }

  getWeeklyData(value, dateFnsLocale) {
    const data = {};
    data.month = format(value, 'LLL', {
      locale: dateFnsLocale
    });
    data.week = calcWeekData(value, 'week', dateFnsLocale);

    this._adapter.setWeeklyData(data);

    return data;
  }

  getRangeData(value, dateFnsLocale) {
    const data = {};
    const {
      range
    } = this.getProps();
    const len = differenceInCalendarDays(range[1], range[0]);
    data.month = format(value, 'LLL', {
      locale: dateFnsLocale
    });
    data.week = calcRangeData(value, range[0], len, 'week', dateFnsLocale);

    this._adapter.setRangeData(data);

    return data;
  }

  getMonthlyData(value, dateFnsLocale) {
    var _context, _context2;

    const monthStart = startOfMonth(value);
    const data = {};
    const numberOfWeek = getWeeksInMonth(value);

    _mapInstanceProperty(_context = [..._keysInstanceProperty(_context2 = Array(numberOfWeek)).call(_context2)]).call(_context, ind => {
      data[ind] = calcWeekData(addDays(monthStart, ind * 7), 'month', dateFnsLocale);
    });

    this._adapter.setMonthlyData(data);

    return data;
  } // ================== Daily Event ==================


  _parseEvents(events) {
    var _context3;

    const parsed = {
      allDay: [],
      day: []
    };

    _forEachInstanceProperty(_context3 = _mapInstanceProperty(events).call(events, event => parseEvent(event))).call(_context3, item => {
      _forEachInstanceProperty(item).call(item, i => {
        i.allDay ? parsed.allDay.push(i) : parsed.day.push(i);
      });
    });

    return parsed;
  }

  getParseDailyEvents(events, date) {
    var _context4;

    if (!date) {
      date = this._getDate();
    }

    const parsed = this._parseEvents(events);

    const {
      displayValue
    } = this.getProps();
    const key = startOfDay(date).toString();
    parsed.allDay = convertEventsArrToMap(parsed.allDay, 'date', startOfDay, displayValue).get(key);
    parsed.day = convertEventsArrToMap(parsed.day, 'date', null, displayValue).get(key);

    if (!parsed.allDay) {
      parsed.allDay = [];
    }

    if (!parsed.day) {
      parsed.day = [];
    }

    parsed.day = _mapInstanceProperty(_context4 = parsed.day).call(_context4, item => renderDailyEvent(item));
    return parsed;
  }

  parseDailyEvents() {
    const {
      events,
      displayValue
    } = this.getProps();
    const parsed = this.getParseDailyEvents(events, displayValue);

    this._adapter.setParsedEvents(parsed);

    this._adapter.cacheEventKeys(_mapInstanceProperty(events).call(events, i => i.key));
  } // ================== Weekly Event ==================


  _parseWeeklyEvents(events, weekStart) {
    var _context5, _context6;

    let parsed = [[]];
    const filtered = filterWeeklyEvents(events, weekStart);

    _forEachInstanceProperty(_context5 = _sortInstanceProperty(_context6 = [..._keysInstanceProperty(filtered).call(filtered)]).call(_context6, (a, b) => sortDate(a, b))).call(_context5, item => {
      var _context7;

      const startDate = new Date(item);

      const curr = _filterInstanceProperty(_context7 = filtered.get(item)).call(_context7, event => isSameDay(event.date, startDate));

      parsed = parseWeeklyAllDayEvent(curr, startDate, weekStart, parsed);
    });

    return parsed;
  }

  _renderWeeklyAllDayEvent(events) {
    const res = [];

    _forEachInstanceProperty(events).call(events, row => {
      const event = _filterInstanceProperty(row).call(row, item => 'leftPos' in item);

      res.push(...event);
    });

    return res;
  } // return parsed weekly allday events


  parseWeeklyAllDayEvents(events) {
    const {
      week
    } = this._adapter.getWeeklyData();

    const weekStart = week[0].date;

    const parsed = this._parseWeeklyEvents(events, weekStart);

    const res = this._renderWeeklyAllDayEvent(parsed);

    return res;
  }

  getParsedWeeklyEvents(events) {
    const parsed = this._parseEvents(events);

    const {
      displayValue
    } = this.getProps();
    const result = {};
    result.allDay = convertEventsArrToMap(parsed.allDay, 'start', startOfDay, displayValue);
    result.day = convertEventsArrToMap(parsed.day, 'date', null, displayValue);
    return result;
  } // return parsed weekly allday events


  parseWeeklyEvents() {
    const {
      events
    } = this.getProps();
    const parsed = this.getParsedWeeklyEvents(events);

    this._adapter.setParsedEvents(parsed);

    this._adapter.cacheEventKeys(_mapInstanceProperty(events).call(events, i => i.key));
  } // ================== Monthly Event ==================


  pushDayEventIntoWeekMap(item, index, map) {
    if (index in map) {
      map[index].push(item);
    } else {
      map[index] = [item];
    }
  }

  convertMapToArray(weekMap, weekStart) {
    const eventArray = [];

    for (const entry of _entriesInstanceProperty(weekMap).call(weekMap)) {
      const [key, value] = entry;
      const map = new _Map();
      map.set(key, value);

      const weekEvents = this._parseWeeklyEvents(map, weekStart);

      eventArray.push(...weekEvents);
    }

    return eventArray;
  }

  getParseMonthlyEvents(itemLimit) {
    var _context8, _context9;

    const parsed = {};
    const {
      displayValue,
      events
    } = this.getProps();

    const currDate = this._getDate();

    const firstDayOfMonth = startOfMonth(displayValue);
    const lastDayOfMonth = endOfMonth(displayValue);
    const res = [];

    _forEachInstanceProperty(_context8 = _sortInstanceProperty(events).call(events, (prev, next) => {
      if (isBefore(prev.start, next.start)) {
        return -1;
      }

      if (isAfter(prev.start, next.start)) {
        return 1;
      }

      return 0;
    })).call(_context8, event => {
      const parsedEvent = parseAllDayEvent(event, event.allDay, currDate);
      res.push(...parsedEvent);
    });

    _filterInstanceProperty(res).call(res, item => isSameMonth(item.date, displayValue));

    _forEachInstanceProperty(res).call(res, item => {
      // WeekInd calculation error, need to consider the boundary situation at the beginning/end of the month
      // When the date falls within the month
      if (isSameMonth(item.date, displayValue)) {
        const weekInd = getWeekOfMonth(item.date) - 1;
        this.pushDayEventIntoWeekMap(item, weekInd, parsed);
        return;
      } // When the date is within the previous month


      if (isBefore(item.date, firstDayOfMonth)) {
        if (isSameWeek(item.date, firstDayOfMonth)) {
          this.pushDayEventIntoWeekMap(item, 0, parsed);
        }

        return;
      } // When the date is within the next month


      if (isAfter(item.date, lastDayOfMonth)) {
        if (isSameWeek(item.date, lastDayOfMonth)) {
          const weekInd = getWeekOfMonth(lastDayOfMonth) - 1;
          this.pushDayEventIntoWeekMap(item, weekInd, parsed);
        }

        return;
      }
    });

    _forEachInstanceProperty(_context9 = _Object$keys(parsed)).call(_context9, key => {
      const week = parsed[key];
      parsed[key] = {};
      const weekStart = startOfWeek(week[0].date);
      const weekMap = convertEventsArrToMap(week, 'start', startOfDay); // When there are multiple events in a week, multiple events should be parsed
      // const oldParsedWeeklyEvent = this._parseWeeklyEvents(weekMap, weekStart);

      const parsedWeeklyEvent = this.convertMapToArray(weekMap, weekStart);
      parsed[key].day = collectDailyEvents(parsedWeeklyEvent);
      parsed[key].display = this._renderDisplayEvents(parsedWeeklyEvent);
    });

    return parsed;
  }

  parseMonthlyEvents(itemLimit) {
    const {
      events
    } = this.getProps();
    const parsed = this.getParseMonthlyEvents(itemLimit);

    this._adapter.setParsedEvents(parsed);

    this._adapter.setItemLimit(itemLimit);

    this._adapter.cacheEventKeys(_mapInstanceProperty(events).call(events, i => i.key));
  }

  _renderDisplayEvents(events) {
    // Limits should not be added when calculating the relative position of each event, because there will be calculations that separate two events in the middle of the week
    let displayEvents = _sliceInstanceProperty(events).call(events);

    if (displayEvents.length) {
      displayEvents = this._renderWeeklyAllDayEvent(displayEvents);
    }

    return displayEvents;
  } // ================== Range Event ==================


  _parseRangeEvents(events) {
    var _context10, _context11;

    let parsed = [[]];
    const [start, end] = this.getProp('range');
    const filtered = filterEvents(events, start, end);

    _forEachInstanceProperty(_context10 = _sortInstanceProperty(_context11 = [..._keysInstanceProperty(filtered).call(filtered)]).call(_context11, (a, b) => sortDate(a, b))).call(_context10, item => {
      var _context12;

      const startDate = new Date(item);

      const curr = _filterInstanceProperty(_context12 = filtered.get(item)).call(_context12, event => isSameDay(event.date, startDate));

      parsed = parseRangeAllDayEvent(curr, startDate, start, end, parsed);
    });

    return parsed;
  }

  _renderRangeAllDayEvent(events) {
    let res = [];

    _forEachInstanceProperty(events).call(events, row => {
      const event = _filterInstanceProperty(row).call(row, item => 'leftPos' in item);

      res = [...res, ...event];
    });

    return res;
  } // return parsed weekly allday events


  parseRangeAllDayEvents(events) {
    const parsed = this._parseRangeEvents(events);

    const res = this._renderRangeAllDayEvent(parsed);

    return res;
  }

  getParsedRangeEvents(events) {
    const parsed = this._parseEvents(events);

    const [start] = this.getProp('range');
    parsed.allDay = convertEventsArrToMap(parsed.allDay, 'start', startOfDay, start);
    parsed.day = convertEventsArrToMap(parsed.day, 'date', null, start);
    return parsed;
  } // return parsed weekly allday events


  parseRangeEvents() {
    const {
      events
    } = this.getProps();
    const parsed = this.getParsedRangeEvents(events);

    this._adapter.setParsedEvents(parsed);

    this._adapter.cacheEventKeys(_mapInstanceProperty(events).call(events, i => i.key));
  }

  checkWeekend(val) {
    return checkWeekend(val);
  }

}