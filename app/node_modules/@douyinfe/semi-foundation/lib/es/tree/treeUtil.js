import _get from "lodash/get";
import _pick from "lodash/pick";
import _isEmpty from "lodash/isEmpty";
import _isUndefined from "lodash/isUndefined";
import _isNull from "lodash/isNull";
import _isObject from "lodash/isObject";
import _max from "lodash/max";
import _uniq from "lodash/uniq";
import _difference from "lodash/difference";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$entries from "@babel/runtime-corejs3/core-js-stable/object/entries";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
import _Set from "@babel/runtime-corejs3/core-js-stable/set";
import _everyInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/every";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _someInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/some";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Object$values from "@babel/runtime-corejs3/core-js-stable/object/values";
const DRAG_OFFSET = 0.45;

function getPosition(level, index) {
  var _context;

  return _concatInstanceProperty(_context = "".concat(level, "-")).call(_context, index);
}

function isValid(val) {
  return !_isNull(val) && !_isUndefined(val);
}
/**
 * Flat nest tree data into flatten list. This is used for virtual list render.
 * @param treeNodeList Origin data node list
 * @param expandedKeys
 * @param filteredShownKeys
 * need expanded keys, provides `true` means all expanded
 */
// eslint-disable-next-line max-len


export function flattenTreeData(treeNodeList, expandedKeys) {
  let filteredShownKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const flattenList = [];
  const filterSearch = Boolean(filteredShownKeys);

  function flatten(list) {
    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return _mapInstanceProperty(list).call(list, (treeNode, index) => {
      const pos = getPosition(parent ? parent.pos : '0', index);
      const mergedKey = treeNode.key; // Add FlattenDataNode into list

      const flattenNode = _Object$assign(_Object$assign({}, _pick(treeNode, ['key', 'label', 'value', 'icon', 'disabled', 'isLeaf'])), {
        parent,
        pos,
        children: null,
        data: treeNode,
        _innerDataTag: true
      });

      const isBooleanFilteredShownKeys = typeof filteredShownKeys === 'boolean';

      if (!filterSearch || !isBooleanFilteredShownKeys && filteredShownKeys.has(mergedKey)) {
        flattenList.push(flattenNode);
      } // Loop treeNode children
      // eslint-disable-next-line max-len


      if (expandedKeys.has(mergedKey) && (!filterSearch || !isBooleanFilteredShownKeys && filteredShownKeys.has(mergedKey))) {
        flattenNode.children = flatten(treeNode.children || [], flattenNode);
      } else {
        flattenNode.children = [];
      }

      return flattenNode;
    });
  }

  flatten(treeNodeList);
  return flattenList;
}
export function convertJsonToData(treeJson) {
  var _context3;

  const treeData = [];

  const traverseNode = (key, children, path, res) => {
    const currPath = [...path, key];
    const itemKey = currPath.join('-');
    const newNode = {
      key: itemKey,
      label: key,
      value: children
    };

    if (_isObject(children)) {
      var _context2;

      const newChildren = [];

      _forEachInstanceProperty(_context2 = _Object$entries(children)).call(_context2, c => {
        traverseNode(c[0], c[1], currPath, newChildren);
      });

      newNode.children = newChildren;
    }

    res.push(newNode);
  };

  _forEachInstanceProperty(_context3 = _Object$entries(treeJson)).call(_context3, item => traverseNode(item[0], item[1], [], treeData));

  return treeData;
}
/**
 * Traverse all the data by `treeData`.
 */

export function traverseDataNodes(treeNodes, callback) {
  const processNode = (node, ind, parent) => {
    const children = node ? node.children : treeNodes;
    const pos = node ? getPosition(parent.pos, ind) : '0'; // Process node if is not root

    if (node) {
      const data = {
        data: _Object$assign({}, node),
        ind,
        pos,
        key: node.key !== null ? node.key : pos,
        parentPos: parent.node ? parent.pos : null,
        level: Number(parent.level) + 1
      };
      callback(data);
    } // Process children node


    if (children) {
      _forEachInstanceProperty(children).call(children, (subNode, subIndex) => {
        processNode(subNode, subIndex, {
          node,
          pos,
          level: parent ? Number(parent.level) + 1 : -1
        });
      });
    }
  };

  processNode(null);
}
/* Convert data to entities map */

export function convertDataToEntities(dataNodes) {
  const posEntities = {};
  const keyEntities = {};
  const valueEntities = {};
  const wrapper = {
    posEntities,
    keyEntities,
    valueEntities
  };
  traverseDataNodes(dataNodes, data => {
    const {
      pos,
      key,
      parentPos
    } = data;

    const entity = _Object$assign({}, data);

    const value = _get(entity, 'data.value', null);

    if (value !== null) {
      valueEntities[value] = key;
    }

    posEntities[pos] = entity;
    keyEntities[key] = entity; // Fill children

    entity.parent = posEntities[parentPos];

    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
  });
  return wrapper;
}
/* Get key by value */

export function findKeysForValues(valueList, valueEntities) {
  let isMultiple = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!isValid(valueList)) {
    return [];
  }

  if (!isMultiple && _Array$isArray(valueList)) {
    valueList = valueList.length ? [valueList[0]] : [];
  } else if (!_Array$isArray(valueList)) {
    valueList = [valueList];
  }

  if (_isEmpty(valueEntities)) {
    return valueList;
  }

  const res = [];

  _forEachInstanceProperty(valueList).call(valueList, val => {
    if (val in valueEntities) {
      res.push(valueEntities[val]);
    }
  });

  return res;
}
export function findDescendantKeys(selectedKeys, options) {
  let self = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  const res = [];

  const findChild = item => {
    if (!item) {
      return;
    }

    const {
      children
    } = item;
    const hasChildren = isValid(children);

    if (hasChildren) {
      _forEachInstanceProperty(children).call(children, child => {
        res.push(child.key);
        findChild(options[child.key]);
      });
    }
  };

  _forEachInstanceProperty(selectedKeys).call(selectedKeys, item => {
    if (self) {
      res.push(item);
    }

    findChild(options[item]);
  });

  return res;
}
export function findChildKeys(keys, options) {
  let omitKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  const res = [];
  keys && _forEachInstanceProperty(keys).call(keys, key => {
    var _context4;

    const opts = options[key];
    opts && opts.children && _forEachInstanceProperty(_context4 = opts.children).call(_context4, child => {
      if (!omitKeys.length || !_includesInstanceProperty(omitKeys).call(omitKeys, child.key)) {
        res.push(child.key);
      }
    });
  });
  return res;
}
/* istanbul ignore next */

export function findLeafKeys(keys, options) {
  const res = [];

  const findChild = item => {
    if (!item) {
      return;
    }

    const {
      children
    } = item;
    const isLeaf = !isValid(children);

    if (isLeaf) {
      res.push(item.key);
    } else {
      _forEachInstanceProperty(children).call(children, child => {
        findChild(options[child.key]);
      });
    }
  };

  _forEachInstanceProperty(keys).call(keys, item => {
    findChild(options[item]);
  });

  return res;
}
export function findSiblingKeys(selectedKeys, options) {
  let self = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  const par = [];

  _forEachInstanceProperty(selectedKeys).call(selectedKeys, item => {
    if (options[item] && options[item].parent) {
      par.push(options[item].parent.key);
    }
  });

  const res = findChildKeys(_uniq(par), options, self ? [] : selectedKeys);
  return res;
}
export function findAncestorKeys(selectedKeys, options) {
  let self = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  const res = []; // Recursively find the parent element

  const findPar = item => {
    if (item.parent) {
      res.push(item.parent.key);
      findPar(item.parent);
    }
  };

  _forEachInstanceProperty(selectedKeys).call(selectedKeys, item => {
    options[item] && findPar(options[item]);

    if (self) {
      res.push(item);
    }
  });

  return res;
}

function getSortedKeyList(keyList, keyEntities) {
  const levelMap = {};

  _forEachInstanceProperty(keyList).call(keyList, key => {
    if (!keyEntities[key]) {
      return;
    }

    const {
      level
    } = keyEntities[key];

    if (levelMap[level]) {
      levelMap[level].push(key);
    } else {
      levelMap[level] = [key];
    }
  });

  return levelMap;
}

export function calcCheckedKeys(values, keyEntities) {
  const keyList = _Array$isArray(values) ? values : [values];
  const descendantKeys = findDescendantKeys(keyList, keyEntities, true);
  /**
   * Recursively find the parent element. Because the incoming nodes are all checked,
   * their descendants must be checked. That is to say, if the descendant nodes have
   *  disabled+unchecked nodes, their ancestor nodes will definitely not be checked
   */

  const checkedKeys = new _Set([...descendantKeys]);
  let halfCheckedKeys = new _Set([]);
  let visited = [];
  const levelMap = getSortedKeyList(keyList, keyEntities);

  const calcCurrLevel = node => {
    const {
      key,
      parent,
      level
    } = node; // If the node does not have a parent node, or the node has been processed just now, no processing is done

    if (!parent || _includesInstanceProperty(visited).call(visited, key)) {
      return;
    }

    const siblingKeys = findSiblingKeys([key], keyEntities); // visited for caching to avoid double counting

    visited = [...visited, ...siblingKeys];

    const allChecked = _everyInstanceProperty(siblingKeys).call(siblingKeys, siblingKey => checkedKeys.has(siblingKey));

    if (!allChecked) {
      const ancestorKeys = findAncestorKeys([key], keyEntities, false);
      halfCheckedKeys = new _Set([...halfCheckedKeys, ...ancestorKeys]);
    } else {
      checkedKeys.add(parent.key); // IMPORTANT! parent level may not exist in original level map; if add to the end directly may destroy the hierarchical order

      if (level - 1 in levelMap && level) {
        levelMap[level - 1].push(parent.key);
      } else {
        levelMap[level - 1] = [parent.key];
      }
    }
  }; // Loop keyList from deepest Level to topLevel, bottom up


  while (!_isEmpty(levelMap)) {
    var _context5, _context6;

    const maxLevel = _max(_mapInstanceProperty(_context5 = _Object$keys(levelMap)).call(_context5, key => Number(key)));

    _forEachInstanceProperty(_context6 = levelMap[maxLevel]).call(_context6, key => calcCurrLevel(keyEntities[key]));

    delete levelMap[maxLevel];
  }

  return {
    checkedKeys,
    halfCheckedKeys
  };
}
/* Calculate the expanded node by key */

export function calcExpandedKeys() {
  let keyList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let keyEntities = arguments.length > 1 ? arguments[1] : undefined;
  let autoExpandParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  if (!_Array$isArray(keyList)) {
    keyList = [keyList];
  }

  if (autoExpandParent) {
    const ancestorKeys = findAncestorKeys(keyList, keyEntities, true);
    return new _Set(ancestorKeys);
  }

  return new _Set(keyList);
}
/* Calculate the expanded node by value */
// eslint-disable-next-line max-len

export function calcExpandedKeysForValues(value, keyEntities, isMultiple, valueEntities) {
  const keys = findKeysForValues(value, valueEntities, isMultiple);
  return new _Set(findAncestorKeys(keys, keyEntities, false));
}
export function calcMotionKeys(oldKeySet, newKeySet, keyEntities) {
  let motionType = 'show';
  const oldKeys = [...oldKeySet];
  const newKeys = [...newKeySet];

  if (Math.abs(oldKeys.length - newKeys.length) !== 1) {
    return {
      motionType,
      motionKeys: []
    };
  }

  let diffKeys = [];

  if (oldKeys.length > newKeys.length) {
    motionType = 'hide';
    diffKeys = _difference(oldKeys, newKeys);
  } else {
    diffKeys = _difference(newKeys, oldKeys);
  }

  return {
    motionType: diffKeys.length === 1 ? motionType : 'show',
    motionKeys: diffKeys.length === 1 ? findDescendantKeys(diffKeys, keyEntities, false) : []
  };
}
/**
 * @returns whether option includes sugInput.
 * When filterTreeNode is a function,returns the result of filterTreeNode which called with (sugInput, option).
 */

export function filter(sugInput, option, filterTreeNode, filterProps) {
  if (!filterTreeNode) {
    return true;
  }

  let filterFn = filterTreeNode;
  let target = option;

  if (typeof filterTreeNode === 'boolean') {
    filterFn = (targetVal, val) => {
      var _context7;

      const input = targetVal.toLowerCase();
      return _includesInstanceProperty(_context7 = val.toString().toLowerCase()).call(_context7, input);
    };
  }

  if (filterProps) {
    target = option[filterProps];
  }

  return filterFn(sugInput, target);
}
export function normalizedArr(val) {
  if (!_Array$isArray(val)) {
    return [val];
  } else {
    return val;
  }
}
export function normalizeKeyList(keyList, keyEntities) {
  let leafOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const res = [];
  const keyListSet = new _Set(keyList);

  if (!leafOnly) {
    _forEachInstanceProperty(keyList).call(keyList, key => {
      if (!keyEntities[key]) {
        return;
      }

      const {
        parent
      } = keyEntities[key];

      if (parent && keyListSet.has(parent.key)) {
        return;
      }

      res.push(key);
    });
  } else {
    _forEachInstanceProperty(keyList).call(keyList, key => {
      if (keyEntities[key] && !isValid(keyEntities[key].children)) {
        res.push(key);
      }
    });
  }

  return res;
}
export function getMotionKeys(eventKey, expandedKeys, keyEntities) {
  const res = [];

  const getChild = itemKey => {
    var _context8;

    keyEntities[itemKey].children && _forEachInstanceProperty(_context8 = keyEntities[itemKey].children).call(_context8, item => {
      const {
        key
      } = item;
      res.push(key);

      if (expandedKeys.has(key)) {
        getChild(key);
      }
    });
  };

  getChild(eventKey);
  return res;
} // eslint-disable-next-line max-len

export function calcCheckedKeysForChecked(key, keyEntities, checkedKeys, halfCheckedKeys) {
  const descendantKeys = findDescendantKeys([key], keyEntities, true);
  const nodeItem = keyEntities[key];
  checkedKeys = new _Set([...checkedKeys, key]);

  const calcCurrLevel = node => {
    if (!node.parent) {
      return;
    } // eslint-disable-next-line @typescript-eslint/no-shadow


    const {
      key
    } = node;
    const siblingKeys = findSiblingKeys([key], keyEntities); // eslint-disable-next-line @typescript-eslint/no-shadow

    const allChecked = _everyInstanceProperty(siblingKeys).call(siblingKeys, key => checkedKeys.has(key));

    if (!allChecked) {
      const ancestorKeys = findAncestorKeys([key], keyEntities, false);
      halfCheckedKeys = new _Set([...halfCheckedKeys, ...ancestorKeys]);
    } else {
      const par = node.parent;
      checkedKeys.add(par.key);
      calcCurrLevel(par);
    }
  };

  calcCurrLevel(nodeItem);
  return {
    checkedKeys: new _Set([...checkedKeys, ...descendantKeys]),
    halfCheckedKeys
  };
} // eslint-disable-next-line max-len

export function calcCheckedKeysForUnchecked(key, keyEntities, checkedKeys, halfCheckedKeys) {
  const descendantKeys = findDescendantKeys([key], keyEntities, true);
  const nodeItem = keyEntities[key];

  _forEachInstanceProperty(descendantKeys).call(descendantKeys, descendantKey => {
    if (checkedKeys.has(descendantKey)) {
      checkedKeys.delete(descendantKey);
    }

    if (halfCheckedKeys.has(descendantKey)) {
      halfCheckedKeys.delete(descendantKey);
    }
  });

  const calcCurrLevel = node => {
    const par = node.parent; // no parent

    if (!par) {
      return;
    } // Has a parent node, and the parent node is not checked or halfChecked


    if (!checkedKeys.has(par.key) && !halfCheckedKeys.has(par.key)) {
      return;
    } // Has a parent node, and the parent node is checked or halfChecked
    // eslint-disable-next-line @typescript-eslint/no-shadow


    const {
      key
    } = node;
    const siblingKeys = findSiblingKeys([key], keyEntities); // eslint-disable-next-line @typescript-eslint/no-shadow

    const anyChecked = _someInstanceProperty(siblingKeys).call(siblingKeys, key => checkedKeys.has(key) || halfCheckedKeys.has(key));

    const ancestorKeys = findAncestorKeys([key], keyEntities, false); // If there is checked or halfChecked in the sibling node, you need to change the parent node to halfChecked

    if (anyChecked) {
      _forEachInstanceProperty(ancestorKeys).call(ancestorKeys, itemKey => {
        if (checkedKeys.has(itemKey)) {
          checkedKeys.delete(itemKey);
          halfCheckedKeys.add(itemKey);
        }
      }); // If there is no checked or halfChecked in the sibling node, you need to change the parent node to unchecked

    } else {
      if (checkedKeys.has(par.key)) {
        checkedKeys.delete(par.key);
      }

      if (halfCheckedKeys.has(par.key)) {
        halfCheckedKeys.delete(par.key);
      }

      calcCurrLevel(par);
    }
  };

  calcCurrLevel(nodeItem);
  return {
    checkedKeys,
    halfCheckedKeys
  };
}
export function filterTreeData(info) {
  var _context9, _context10;

  const {
    showFilteredOnly,
    keyEntities,
    inputValue,
    treeData,
    filterTreeNode,
    filterProps,
    prevExpandedKeys
  } = info;
  let filteredOptsKeys = [];
  filteredOptsKeys = _mapInstanceProperty(_context9 = _filterInstanceProperty(_context10 = _Object$values(keyEntities)).call(_context10, item => filter(inputValue, item.data, filterTreeNode, filterProps))).call(_context9, item => item.key);
  let expandedOptsKeys = findAncestorKeys(filteredOptsKeys, keyEntities, false);

  if (prevExpandedKeys.length) {
    const prevExpandedValidKeys = _filterInstanceProperty(prevExpandedKeys).call(prevExpandedKeys, key => Boolean(keyEntities[key]));

    expandedOptsKeys = _concatInstanceProperty(expandedOptsKeys).call(expandedOptsKeys, prevExpandedValidKeys);
  }

  const shownChildKeys = findDescendantKeys(filteredOptsKeys, keyEntities, true);
  const filteredShownKeys = new _Set([...shownChildKeys, ...expandedOptsKeys]);
  const flattenNodes = flattenTreeData(treeData, new _Set(expandedOptsKeys), showFilteredOnly && filteredShownKeys);
  return {
    flattenNodes,
    filteredKeys: new _Set(filteredOptsKeys),
    filteredExpandedKeys: new _Set(expandedOptsKeys),
    filteredShownKeys
  };
} // return data.value if data.value exist else fall back to key

export function getValueOrKey(data) {
  if (_Array$isArray(data)) {
    return _mapInstanceProperty(data).call(data, item => _get(item, 'value', item.key));
  }

  return _get(data, 'value', data.key);
}
/* Convert value to string */

export function normalizeValue(value, withObject) {
  if (withObject && isValid(value)) {
    return getValueOrKey(value);
  } else {
    return value;
  }
}
export function updateKeys(keySet, keyEntities) {
  const keyArr = [...keySet];
  return _filterInstanceProperty(keyArr).call(keyArr, key => key in keyEntities);
}
export function calcDisabledKeys(keyEntities) {
  var _context11;

  const disabledKeys = _filterInstanceProperty(_context11 = _Object$keys(keyEntities)).call(_context11, key => keyEntities[key].data.disabled);

  const {
    checkedKeys
  } = calcCheckedKeys(disabledKeys, keyEntities);
  return checkedKeys;
}
export function calcDropRelativePosition(event, treeNode) {
  const {
    clientY
  } = event;
  const {
    top,
    bottom,
    height
  } = treeNode.nodeInstance.getBoundingClientRect(); // eslint-disable-next-line @typescript-eslint/restrict-plus-operands

  if (clientY <= top + height * DRAG_OFFSET) {
    return -1;
  }

  if (clientY >= bottom - height * DRAG_OFFSET) {
    return 1;
  }

  return 0;
}
export function getDragNodesKeys(key, keyEntities) {
  return findDescendantKeys([key], keyEntities, true);
}
export function calcDropActualPosition(pos, relativeDropPos) {
  const posArr = pos.split('-'); // eslint-disable-next-line @typescript-eslint/restrict-plus-operands

  return relativeDropPos + Number(posArr[posArr.length - 1]);
}