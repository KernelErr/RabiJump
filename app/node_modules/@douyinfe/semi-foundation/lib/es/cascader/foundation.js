import _includes from "lodash/includes";
import _isNumber from "lodash/isNumber";
import _isEmpty from "lodash/isEmpty";
import _cloneDeep from "lodash/cloneDeep";
import _assign from "lodash/assign";
import _isUndefined from "lodash/isUndefined";
import _difference from "lodash/difference";
import _get from "lodash/get";
import _isEqual from "lodash/isEqual";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _someInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/some";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _Array$from from "@babel/runtime-corejs3/core-js-stable/array/from";
import _Set from "@babel/runtime-corejs3/core-js-stable/set";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _everyInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/every";
import _Object$values from "@babel/runtime-corejs3/core-js-stable/object/values";
import _sortInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/sort";
import _parseInt from "@babel/runtime-corejs3/core-js-stable/parse-int";
import BaseFoundation from '../base/foundation';
import { filter, findAncestorKeys, calcCheckedKeysForUnchecked, calcCheckedKeysForChecked, calcCheckedKeys, findDescendantKeys, normalizeKeyList } from '../tree/treeUtil';
import { convertDataToEntities, findKeysForValues, normalizedArr, isValid, calcMergeType } from './util';
import { strings } from './constants';
import isEnterPress from '../utils/isEnterPress'; // eslint-disable-next-line max-len

export default class CascaderFoundation extends BaseFoundation {
  constructor(adapter) {
    var _this;

    super(_Object$assign({}, adapter));
    _this = this;

    this.getMergedMotion = () => {
      const {
        motion
      } = this.getProps();
      const {
        isSearching
      } = this.getStates();

      if (isSearching) {
        const mergedMotion = typeof motion === 'undefined' || motion ? _Object$assign(_Object$assign({}, motion), {
          didLeave: function () {
            const didLeave = _get(motion, 'didLeave');

            if (typeof didLeave === 'function') {
              didLeave(...arguments);
            }

            _this._adapter.updateStates({
              isSearching: false
            });
          }
        }) : false;
        return mergedMotion;
      }

      return motion;
    };
  }

  init() {
    const isOpen = this.getProp('open') || this.getProp('defaultOpen');
    this.collectOptions(true);

    if (isOpen && !this._isDisabled()) {
      this.open();
    }
  }

  destroy() {
    this._adapter.unregisterClickOutsideHandler();
  }

  _isDisabled() {
    return this.getProp('disabled');
  }

  _isFilterable() {
    return Boolean(this.getProp('filterTreeNode')); // filter can be boolean or function
  }

  _notifyChange(item) {
    const {
      onChangeWithObject,
      multiple
    } = this.getProps();
    const valueProp = onChangeWithObject ? [] : 'value';

    if (multiple) {
      const valuePath = []; // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore 

      _forEachInstanceProperty(item).call(item, checkedKey => {
        const valuePathItem = this.getItemPropPath(checkedKey, valueProp);
        valuePath.push(valuePathItem);
      });

      this._adapter.notifyChange(valuePath);
    } else {
      const valuePath = _isUndefined(item) || !('key' in item) ? [] : this.getItemPropPath(item.key, valueProp);

      this._adapter.notifyChange(valuePath);
    }
  }

  _isLeaf(item) {
    if (this.getProp('loadData')) {
      return Boolean(item.isLeaf);
    }

    return !item.children || !item.children.length;
  }

  _clearInput() {
    this._adapter.updateInputValue('');
  } // Scenes that may trigger blur:
  //  1、clickOutSide


  _notifyBlur(e) {
    this._adapter.notifyBlur(e);
  } // Scenes that may trigger focus:
  //  1、click selection


  _notifyFocus(e) {
    this._adapter.notifyFocus(e);
  }

  _isOptionDisabled(key, keyEntities) {
    var _context;

    const isDisabled = _someInstanceProperty(_context = findAncestorKeys([key], keyEntities, true)).call(_context, item => keyEntities[item].data.disabled);

    return isDisabled;
  }

  getCopyFromState(items) {
    var _context2;

    const res = {};

    _forEachInstanceProperty(_context2 = normalizedArr(items)).call(_context2, key => {
      res[key] = _cloneDeep(this.getState(key));
    });

    return res;
  } // prop: is array, return all data


  getItemPropPath(selectedKey, prop, keyEntities) {
    const searchMap = keyEntities || this.getState('keyEntities');
    const selectedItem = searchMap[selectedKey];
    let path = [];

    if (!selectedItem) {// do nothing
    } else if (selectedItem._notExist) {
      path = selectedItem.path;
    } else {
      const keyPath = selectedItem.path;
      path = _Array$isArray(prop) ? _mapInstanceProperty(keyPath).call(keyPath, key => searchMap[key].data) : _mapInstanceProperty(keyPath).call(keyPath, key => searchMap[key].data[prop]);
    }

    return path;
  }

  _getCacheValue(keyEntities) {
    const {
      selectedKeys
    } = this.getStates();

    const selectedKey = _Array$from(selectedKeys)[0];

    let cacheValue;
    /* selectedKeys does not match keyEntities */

    if (_isEmpty(keyEntities[selectedKey])) {
      if (_includes(selectedKey, 'not-exist-')) {
        /* Get the value behind not-exist- */
        // eslint-disable-next-line prefer-destructuring
        const targetValue = selectedKey.match(/not-exist-(\S*)/)[1]; // eslint-disable-next-line max-depth

        if (_isEmpty(keyEntities[targetValue])) {
          cacheValue = targetValue;
        } else {
          /**
           * 典型的场景是: 假设我们选中了 0-0 这个节点，此时 selectedKeys=Set('0-0')，
           * 输入框会显示 0-0 的 label。当 treeData 发生更新，假设此时 0-0 在 treeData
           * 中不存在，则 selectedKeys=Set('not-exist-0-0')，此时输入框显示的是 0-0，
           * 也就是显示 not-exist- 后的内容。当treeData再次更新，假设此时 0-0 在 treeData
           * 中存在，则 selectedKeys=Set('0-0')，此时输入框显示 0-0 的 label。 这个地
           * 方做的操作就是，为了例子中第二次更新后 0-0 label 能够正常显示。
           */

          /**
           * The typical scenario is: suppose we select the 0-0 node, at this time
           *  selectedKeys=Set('0-0'), the input box will display a 0-0 label. When
           *  treeData is updated, assuming 0-0 does not exist in treeData at this
           *  time, then selectedKeys=Set('not-exist-0-0'), at this time the input
           *  box displays 0-0, which means not-exist -After the content. When treeData
           *  is updated again, assuming that 0-0 exists in treeData at this time,
           *  then selectedKeys=Set('0-0'), and the input box displays a label of
           *  0-0 at this time. The operation done here is for the 0-0 label to be
           *  displayed normally after the second update in the example.
           */
          cacheValue = keyEntities[targetValue].valuePath;
        }
      } else {
        cacheValue = selectedKey;
      }
      /* selectedKeys match keyEntities */

    } else {
      /* selectedKeys match keyEntities */
      cacheValue = keyEntities[selectedKey].valuePath;
    }

    return cacheValue;
  }

  collectOptions() {
    let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const {
      treeData,
      value,
      defaultValue
    } = this.getProps();
    const keyEntities = convertDataToEntities(treeData);

    this._adapter.rePositionDropdown();

    let cacheValue;
    /* when mount */

    if (init) {
      cacheValue = defaultValue;
    } else if (!_isEmpty(keyEntities)) {
      cacheValue = this._getCacheValue(keyEntities);
    }

    const selectedValue = !this._isControlledComponent() ? cacheValue : value;

    if (isValid(selectedValue)) {
      this.updateSelectedKey(selectedValue, keyEntities);
    } else {
      this._adapter.updateStates({
        keyEntities
      });
    }
  } // call when props.value change


  handleValueChange(value) {
    const {
      keyEntities
    } = this.getStates();
    const {
      multiple
    } = this.getProps();
    !multiple && this.updateSelectedKey(value, keyEntities);
  }
  /**
   * When single selection, the clear objects of
   * selectedKeys, activeKeys, filteredKeys, input, etc.
   */


  _getClearSelectedKey(filterable) {
    const updateStates = {};
    const {
      searchPlaceholder,
      placeholder,
      multiple
    } = this.getProps();
    updateStates.selectedKeys = new _Set([]);
    updateStates.activeKeys = new _Set([]);
    updateStates.filteredKeys = new _Set([]);

    if (filterable && !multiple) {
      updateStates.inputPlaceHolder = searchPlaceholder || placeholder || '';
      updateStates.inputValue = '';
    }

    return updateStates;
  }

  updateSelectedKey(value, keyEntities) {
    var _context3, _context4;

    const {
      changeOnSelect,
      onChangeWithObject,
      multiple
    } = this.getProps();
    const {
      activeKeys,
      loadingKeys,
      loading,
      keyEntities: keyEntityState,
      selectedKeys: selectedKeysState
    } = this.getStates();

    const filterable = this._isFilterable();

    const loadingActive = _filterInstanceProperty(_context3 = [...activeKeys]).call(_context3, i => loadingKeys.has(i));

    const valuePath = onChangeWithObject ? _mapInstanceProperty(_context4 = normalizedArr(value)).call(_context4, i => i.value) : normalizedArr(value);
    const selectedKeys = findKeysForValues(valuePath, keyEntities);
    let updateStates = {};

    if (selectedKeys.length) {
      const selectedKey = selectedKeys[0];
      const selectedItem = keyEntities[selectedKey];
      /**
       * When changeOnSelect is turned on, or the target option is a leaf option,
       * the option is considered to be selected, even if the option is disabled
       */

      if (changeOnSelect || this._isLeaf(selectedItem.data)) {
        updateStates.selectedKeys = new _Set([selectedKey]);

        if (!loadingActive.length) {
          updateStates.activeKeys = new _Set(selectedItem.path);
        }

        if (filterable && !multiple) {
          const displayText = this.renderDisplayText(selectedKey, keyEntities);
          updateStates.inputPlaceHolder = displayText;
          updateStates.inputValue = displayText;
        }
        /**
         * If selectedKeys does not meet the update conditions,
         * and state.selectedKeys is the same as selectedKeys
         * at this time, state.selectedKeys should be cleared.
         * A typical scenario is:
         * The originally selected node is the leaf node, but
         * after props.treeData is dynamically updated, the node
         * is a non-leaf node. At this point, selectedKeys should
         * be cleared.
         */

      } else if (_isEqual(selectedKeys, _Array$from(selectedKeysState))) {
        updateStates = this._getClearSelectedKey(filterable);
      }
    } else if (value && value.length) {
      const val = valuePath[valuePath.length - 1];
      const key = "not-exist-".concat(val);
      const optionNotExist = {
        data: {
          label: val,
          value: val
        },
        key,
        path: valuePath,
        _notExist: true
      };
      updateStates.selectedKeys = new _Set([key]);

      if (filterable && !multiple) {
        const displayText = this._defaultRenderText(valuePath);

        updateStates.inputPlaceHolder = displayText;
        updateStates.inputValue = displayText;
      }

      keyEntities[key] = optionNotExist; // Fix: 1155, if the data is loaded asynchronously to update treeData, the emptying operation should not be done when entering the updateSelectedKey method
    } else if (loading) {
      // Use assign to avoid overwriting the'not-exist- * 'property of keyEntities after asynchronous loading
      // Overwriting'not-exist- * 'will cause selectionContent to be emptied unexpectedly when clicking on a dropDown item
      updateStates.keyEntities = _assign(keyEntityState, keyEntities);

      this._adapter.updateStates(updateStates);

      return;
    } else {
      updateStates = this._getClearSelectedKey(filterable);
    }

    updateStates.keyEntities = keyEntities;

    this._adapter.updateStates(updateStates);
  }

  open() {
    const filterable = this._isFilterable();

    const {
      multiple
    } = this.getProps();

    this._adapter.openMenu();

    if (filterable) {
      this._clearInput();

      !multiple && this.toggle2SearchInput(true);
    }

    if (this._isControlledComponent()) {
      this.reCalcActiveKeys();
    }

    this._adapter.notifyDropdownVisibleChange(true);

    this._adapter.registerClickOutsideHandler(e => this.close(e));
  }

  reCalcActiveKeys() {
    const {
      selectedKeys,
      activeKeys,
      keyEntities
    } = this.getStates();
    const selectedKey = [...selectedKeys][0];
    const selectedItem = keyEntities[selectedKey];

    if (!selectedItem) {
      return;
    }

    const newActiveKeys = new _Set(selectedItem.path);

    if (!_isEqual(newActiveKeys, activeKeys)) {
      this._adapter.updateStates({
        activeKeys: newActiveKeys
      });
    }
  }

  close(e, key) {
    const {
      multiple
    } = this.getProps();

    this._adapter.closeMenu();

    this._adapter.notifyDropdownVisibleChange(false);

    this._adapter.unregisterClickOutsideHandler();

    if (this._isFilterable()) {
      const {
        selectedKeys
      } = this.getStates();
      let inputValue = '';

      if (key && !multiple) {
        inputValue = this.renderDisplayText(key);
      } else if (selectedKeys.size && !multiple) {
        inputValue = this.renderDisplayText([...selectedKeys][0]);
      }

      this._adapter.updateStates({
        inputValue
      });

      !multiple && this.toggle2SearchInput(false);
      !multiple && this._adapter.updateFocusState(false);
    }

    this._notifyBlur(e);
  }

  toggle2SearchInput(isShow) {
    if (isShow) {
      this._adapter.toggleInputShow(isShow, () => this.focusInput());
    } else {
      this._adapter.toggleInputShow(isShow, () => undefined);
    }
  }

  focusInput() {
    this._adapter.focusInput();

    this._adapter.updateFocusState(true);
  }

  handleItemClick(e, item) {
    const isDisabled = this._isDisabled();

    if (isDisabled) {
      return;
    }

    this.handleSingleSelect(e, item);

    this._adapter.rePositionDropdown();
  }

  handleItemHover(e, item) {
    const isDisabled = this._isDisabled();

    if (isDisabled) {
      return;
    }

    this.handleShowNextByHover(item);
  }

  handleShowNextByHover(item) {
    const {
      keyEntities
    } = this.getStates();
    const {
      data,
      key
    } = item;

    const isLeaf = this._isLeaf(data);

    const activeKeys = keyEntities[key].path;

    this._adapter.updateStates({
      activeKeys: new _Set(activeKeys)
    });

    if (!isLeaf) {
      this.notifyIfLoadData(item);
    }
  }

  onItemCheckboxClick(item) {
    const isDisabled = this._isDisabled();

    if (isDisabled) {
      return;
    }

    this._handleMultipleSelect(item);

    this._adapter.rePositionDropdown();
  }

  handleClick(e) {
    const isDisabled = this._isDisabled();

    const isFilterable = this._isFilterable();

    const {
      isOpen
    } = this.getStates();

    if (isDisabled) {
      return;
    } else if (!isOpen) {
      this.open();

      this._notifyFocus(e);
    } else if (isOpen && !isFilterable) {
      this.close(e);
    }
  }
  /**
   * A11y: simulate selection click
   */

  /* istanbul ignore next */


  handleSelectionEnterPress(keyboardEvent) {
    if (isEnterPress(keyboardEvent)) {
      this.handleClick(keyboardEvent);
    }
  }

  toggleHoverState(bool) {
    this._adapter.toggleHovering(bool);
  }

  _defaultRenderText(path, displayRender) {
    const separator = this.getProp('separator');

    if (displayRender && typeof displayRender === 'function') {
      return displayRender(path);
    } else {
      return path.join(separator);
    }
  }

  renderDisplayText(targetKey, keyEntities) {
    const renderFunc = this.getProp('displayRender');
    const displayProp = this.getProp('displayProp');
    const displayPath = this.getItemPropPath(targetKey, displayProp, keyEntities);
    return this._defaultRenderText(displayPath, renderFunc);
  }

  handleNodeLoad(item) {
    const {
      data,
      key
    } = item;
    const {
      loadedKeys: prevLoadedKeys,
      loadingKeys: prevLoadingKeys
    } = this.getCopyFromState(['loadedKeys', 'loadingKeys']);
    const newLoadedKeys = prevLoadedKeys.add(key);
    const newLoadingKeys = new _Set([...prevLoadingKeys]);
    newLoadingKeys.delete(key); // onLoad should trigger before internal setState to avoid `loadData` trigger twice.

    this._adapter.notifyOnLoad(newLoadedKeys, data);

    this._adapter.updateStates({
      loadingKeys: newLoadingKeys
    });
  }

  notifyIfLoadData(item) {
    const {
      data,
      key
    } = item;

    this._adapter.updateStates({
      loading: false
    });

    if (!data.isLeaf && !data.children && this.getProp('loadData')) {
      var _context5;

      const {
        loadedKeys,
        loadingKeys
      } = this.getCopyFromState(['loadedKeys', 'loadingKeys']);

      if (loadedKeys.has(key) || loadingKeys.has(key)) {
        return;
      }

      this._adapter.updateStates({
        loading: true
      });

      const {
        keyEntities
      } = this.getStates();
      const optionPath = this.getItemPropPath(key, [], keyEntities);

      this._adapter.updateStates({
        loadingKeys: loadingKeys.add(key)
      });

      this._adapter.notifyLoadData(optionPath, _bindInstanceProperty(_context5 = this.handleNodeLoad).call(_context5, this, item));
    }
  }

  handleSingleSelect(e, item) {
    const {
      changeOnSelect: allowChange,
      filterLeafOnly,
      multiple,
      enableLeafClick
    } = this.getProps();
    const {
      keyEntities,
      selectedKeys,
      isSearching
    } = this.getStates();

    const filterable = this._isFilterable();

    const {
      data,
      key
    } = item;

    const isLeaf = this._isLeaf(data);

    const activeKeys = keyEntities[key].path;
    const selectedKey = [key];
    const hasChanged = key !== [...selectedKeys][0];

    if (!isLeaf && !allowChange && !isSearching) {
      this._adapter.updateStates({
        activeKeys: new _Set(activeKeys)
      });

      this.notifyIfLoadData(item);
      return;
    }

    if (multiple) {
      this._adapter.updateStates({
        activeKeys: new _Set(activeKeys)
      });

      if (isLeaf && enableLeafClick) {
        this.onItemCheckboxClick(item);
      }
    } else {
      this._adapter.notifySelect(data.value);

      if (hasChanged) {
        this._notifyChange(item);

        this.notifyIfLoadData(item);

        if (this._isControlledComponent()) {
          this._adapter.updateStates({
            activeKeys: new _Set(activeKeys)
          });

          if (isLeaf) {
            this.close(e);
          }

          return;
        }

        this._adapter.updateStates({
          activeKeys: new _Set(activeKeys),
          selectedKeys: new _Set(selectedKey)
        });

        const displayText = this.renderDisplayText(key);

        if (filterable) {
          this._adapter.updateInputPlaceHolder(displayText);
        }

        if (isLeaf) {
          this.close(e, key);
        } else if (!filterLeafOnly && isSearching) {
          this.close(e, key);
        }
      } else {
        this.close(e);
      }
    }
  }

  _handleMultipleSelect(item) {
    const {
      key
    } = item;
    const {
      checkedKeys,
      keyEntities,
      resolvedCheckedKeys
    } = this.getStates();
    const {
      autoMergeValue,
      max,
      disableStrictly,
      leafOnly
    } = this.getProps(); // prev checked status

    const prevCheckedStatus = checkedKeys.has(key); // next checked status

    const curCheckedStatus = disableStrictly ? this.calcCheckedStatus(!prevCheckedStatus, key) : !prevCheckedStatus; // calculate all key of nodes that are checked or half checked

    const {
      checkedKeys: curCheckedKeys,
      halfCheckedKeys: curHalfCheckedKeys
    } = disableStrictly ? this.calcNonDisabledCheckedKeys(key, curCheckedStatus) : this.calcCheckedKeys(key, curCheckedStatus);
    const mergeType = calcMergeType(autoMergeValue, leafOnly);
    const isLeafOnlyMerge = mergeType === strings.LEAF_ONLY_MERGE_TYPE;
    const isNoneMerge = mergeType === strings.NONE_MERGE_TYPE;
    const curResolvedCheckedKeys = new _Set(normalizeKeyList(curCheckedKeys, keyEntities, isLeafOnlyMerge));
    const curRealCheckedKeys = isNoneMerge ? curCheckedKeys : curResolvedCheckedKeys;

    if (_isNumber(max)) {
      if (!isNoneMerge) {
        // When it exceeds max, the quantity is allowed to be reduced, and no further increase is allowed
        if (resolvedCheckedKeys.size < curResolvedCheckedKeys.size && curResolvedCheckedKeys.size > max) {
          const checkedEntities = [];

          _forEachInstanceProperty(curResolvedCheckedKeys).call(curResolvedCheckedKeys, itemKey => {
            checkedEntities.push(keyEntities[itemKey]);
          });

          this._adapter.notifyOnExceed(checkedEntities);

          return;
        }
      } else {
        // When it exceeds max, the quantity is allowed to be reduced, and no further increase is allowed
        if (checkedKeys.size < curCheckedKeys.size && curCheckedKeys.size > max) {
          const checkedEntities = [];

          _forEachInstanceProperty(curCheckedKeys).call(curCheckedKeys, itemKey => {
            checkedEntities.push(keyEntities[itemKey]);
          });

          this._adapter.notifyOnExceed(checkedEntities);

          return;
        }
      }
    }

    if (!this._isControlledComponent()) {
      this._adapter.updateStates({
        checkedKeys: curCheckedKeys,
        halfCheckedKeys: curHalfCheckedKeys,
        resolvedCheckedKeys: curResolvedCheckedKeys
      });
    } // The click event during multiple selection will definitely cause the checked state of node to change,
    // so there is no need to judge the value to change.


    this._notifyChange(curRealCheckedKeys);

    if (curCheckedStatus) {
      this._notifySelect(curRealCheckedKeys);
    }

    this._adapter.updateStates({
      inputValue: ''
    });
  }

  calcNonDisabledCheckedKeys(eventKey, targetStatus) {
    const {
      keyEntities,
      disabledKeys
    } = this.getStates();
    const {
      checkedKeys
    } = this.getCopyFromState(['checkedKeys']);
    const descendantKeys = normalizeKeyList(findDescendantKeys([eventKey], keyEntities, false), keyEntities, true);

    const hasDisabled = _someInstanceProperty(descendantKeys).call(descendantKeys, key => disabledKeys.has(key));

    if (!hasDisabled) {
      return this.calcCheckedKeys(eventKey, targetStatus);
    }

    const nonDisabled = _filterInstanceProperty(descendantKeys).call(descendantKeys, key => !disabledKeys.has(key));

    const newCheckedKeys = targetStatus ? [...nonDisabled, ...checkedKeys] : _difference(normalizeKeyList([...checkedKeys], keyEntities, true), nonDisabled);
    return calcCheckedKeys(newCheckedKeys, keyEntities);
  }

  calcCheckedStatus(targetStatus, eventKey) {
    if (!targetStatus) {
      return targetStatus;
    }

    const {
      checkedKeys,
      keyEntities,
      disabledKeys
    } = this.getStates();
    const descendantKeys = normalizeKeyList(findDescendantKeys([eventKey], keyEntities, false), keyEntities, true);

    const hasDisabled = _someInstanceProperty(descendantKeys).call(descendantKeys, key => disabledKeys.has(key));

    if (!hasDisabled) {
      return targetStatus;
    }

    const nonDisabledKeys = _filterInstanceProperty(descendantKeys).call(descendantKeys, key => !disabledKeys.has(key));

    const allChecked = _everyInstanceProperty(nonDisabledKeys).call(nonDisabledKeys, key => checkedKeys.has(key));

    return !allChecked;
  }

  _notifySelect(keys) {
    const {
      keyEntities
    } = this.getStates();
    const values = [];

    _forEachInstanceProperty(keys).call(keys, key => {
      if (!_isEmpty(keyEntities) && !_isEmpty(keyEntities[key])) {
        const valueItem = keyEntities[key].data.value;
        values.push(valueItem);
      }
    });

    const formatValue = values.length === 1 ? values[0] : values;

    this._adapter.notifySelect(formatValue);
  }
  /**
   * calculate all key of nodes that are checked or half checked
   * @param {string} key key of node
   * @param {boolean} curCheckedStatus checked status of node
   */


  calcCheckedKeys(key, curCheckedStatus) {
    const {
      keyEntities
    } = this.getStates();
    const {
      checkedKeys,
      halfCheckedKeys
    } = this.getCopyFromState(['checkedKeys', 'halfCheckedKeys']);
    return curCheckedStatus ? calcCheckedKeysForChecked(key, keyEntities, checkedKeys, halfCheckedKeys) : calcCheckedKeysForUnchecked(key, keyEntities, checkedKeys, halfCheckedKeys);
  }

  handleInputChange(sugInput) {
    this._adapter.updateInputValue(sugInput);

    const {
      keyEntities
    } = this.getStates();
    const {
      treeNodeFilterProp,
      filterTreeNode,
      filterLeafOnly
    } = this.getProps();
    let filteredKeys = [];

    if (sugInput) {
      var _context6, _context7, _context8;

      filteredKeys = _mapInstanceProperty(_context6 = _filterInstanceProperty(_context7 = _filterInstanceProperty(_context8 = _Object$values(keyEntities)).call(_context8, item => {
        const {
          key,
          _notExist
        } = item;

        if (_notExist) {
          return false;
        }

        const filteredPath = this.getItemPropPath(key, treeNodeFilterProp).join();
        return filter(sugInput, filteredPath, filterTreeNode, false);
      })).call(_context7, item => filterTreeNode && !filterLeafOnly || this._isLeaf(item))).call(_context6, item => item.key);
    }

    this._adapter.updateStates({
      isSearching: Boolean(sugInput),
      filteredKeys: new _Set(filteredKeys)
    });

    this._adapter.notifyOnSearch(sugInput);
  }

  handleClear() {
    const {
      isSearching
    } = this.getStates();
    const {
      searchPlaceholder,
      placeholder,
      multiple
    } = this.getProps();

    const isFilterable = this._isFilterable();

    const isControlled = this._isControlledComponent();

    const newState = {};

    if (multiple) {
      this._adapter.updateInputValue('');

      this._adapter.notifyOnSearch('');

      newState.checkedKeys = new _Set([]);
      newState.halfCheckedKeys = new _Set([]);
      newState.selectedKeys = new _Set([]);
      newState.activeKeys = new _Set([]);
      newState.resolvedCheckedKeys = new _Set([]);

      this._adapter.notifyChange([]);
    } else {
      // if click clearBtn when not searching, clear selected and active values as well
      if (isFilterable && isSearching) {
        newState.isSearching = false;

        this._adapter.updateInputValue('');

        this._adapter.notifyOnSearch('');
      } else {
        if (isFilterable) {
          newState.inputValue = '';
          newState.inputPlaceHolder = searchPlaceholder || placeholder || '';

          this._adapter.updateInputValue('');

          this._adapter.notifyOnSearch('');
        }

        if (!isControlled) {
          newState.selectedKeys = new _Set([]);
        }

        newState.activeKeys = new _Set([]);
        newState.filteredKeys = new _Set([]);

        this._adapter.notifyChange([]);
      }
    }

    this._adapter.updateStates(newState);

    this._adapter.notifyClear();

    this._adapter.rePositionDropdown();
  }
  /**
   * A11y: simulate clear button click
   */

  /* istanbul ignore next */


  handleClearEnterPress(keyboardEvent) {
    if (isEnterPress(keyboardEvent)) {
      this.handleClear();
    }
  }

  getRenderData() {
    var _context9, _context10;

    const {
      keyEntities,
      isSearching
    } = this.getStates();

    const isFilterable = this._isFilterable();

    if (isSearching && isFilterable) {
      return this.getFilteredData();
    }

    return _sortInstanceProperty(_context9 = _filterInstanceProperty(_context10 = _Object$values(keyEntities)).call(_context10, item => item.parentKey === null && !item._notExist) // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    ).call(_context9, (a, b) => _parseInt(a.ind, 10) - _parseInt(b.ind, 10));
  }

  getFilteredData() {
    const {
      treeNodeFilterProp
    } = this.getProps();
    const {
      filteredKeys,
      keyEntities
    } = this.getStates();
    const filteredList = [];
    const filteredKeyArr = [...filteredKeys];

    _forEachInstanceProperty(filteredKeyArr).call(filteredKeyArr, key => {
      const item = keyEntities[key];

      if (!item) {
        return;
      }

      const itemSearchPath = this.getItemPropPath(key, treeNodeFilterProp);

      const isDisabled = this._isOptionDisabled(key, keyEntities);

      filteredList.push({
        data: item.data,
        key,
        disabled: isDisabled,
        searchText: itemSearchPath
      });
    });

    return filteredList;
  }

  handleListScroll(e, ind) {
    const {
      activeKeys,
      keyEntities
    } = this.getStates();
    const lastActiveKey = [...activeKeys][activeKeys.size - 1];
    const data = lastActiveKey ? _get(keyEntities, [lastActiveKey, 'data'], null) : null;

    this._adapter.notifyListScroll(e, {
      panelIndex: ind,
      activeNode: data
    });
  }

  handleTagRemove(e, tagValuePath) {
    var _context11;

    const {
      keyEntities
    } = this.getStates();
    const {
      disabled
    } = this.getProps();

    if (disabled) {
      /* istanbul ignore next */
      return;
    }

    const removedItem = _filterInstanceProperty(_context11 = _Object$values(keyEntities)).call(_context11, item => _isEqual(item.valuePath, tagValuePath))[0];

    !_isEmpty(removedItem) && !removedItem.data.disabled && this._handleMultipleSelect(removedItem);
  }

}