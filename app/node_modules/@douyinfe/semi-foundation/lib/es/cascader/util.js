import _isEqual from "lodash/isEqual";
import _isUndefined from "lodash/isUndefined";
import _isNull from "lodash/isNull";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Object$values from "@babel/runtime-corejs3/core-js-stable/object/values";
import { strings } from './constants';

function getPosition(level, index) {
  var _context;

  return _concatInstanceProperty(_context = "".concat(level, "-")).call(_context, index);
}

export function isValid(val) {
  return !_isNull(val) && !_isUndefined(val);
}
export function normalizedArr(val) {
  if (!_Array$isArray(val)) {
    return [val];
  } else {
    return val;
  }
}
/**
 * Traverse all the data by `treeData`.
 */

function traverseDataNodes(treeNodes, callback) {
  const processNode = (node, ind, parent) => {
    const children = node ? node.children : treeNodes;
    let item = null; // Process node if is not root

    if (node) {
      const key = parent ? getPosition(parent.key, ind) : "".concat(ind);
      item = {
        data: _Object$assign({}, node),
        ind,
        key,
        level: parent ? parent.level + 1 : 0,
        parentKey: parent ? parent.key : null,
        path: parent ? [...parent.path, key] : [key],
        valuePath: parent ? [...parent.valuePath, node.value] : [node.value]
      };
      callback(item);
    } // Process children node


    if (children) {
      _forEachInstanceProperty(children).call(children, (subNode, subIndex) => {
        processNode(subNode, subIndex, item);
      });
    }
  };

  processNode(null);
}

export function convertDataToEntities(dataNodes) {
  const keyEntities = {};
  traverseDataNodes(dataNodes, data => {
    const {
      key,
      parentKey
    } = data;

    const entity = _Object$assign({}, data);

    keyEntities[key] = entity; // Fill children

    entity.parent = keyEntities[parentKey];

    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
  });
  return keyEntities;
}
export function findKeysForValues(value, keyEntities) {
  var _context2, _context3;

  const valuePath = normalizedArr(value);

  const res = _mapInstanceProperty(_context2 = _filterInstanceProperty(_context3 = _Object$values(keyEntities)).call(_context3, item => _isEqual(item.valuePath, valuePath))).call(_context2, item => item.key);

  return res;
}
export function calcMergeType(autoMergeValue, leafOnly) {
  let mergeType;

  if (leafOnly) {
    mergeType = strings.LEAF_ONLY_MERGE_TYPE;
  } else if (autoMergeValue) {
    mergeType = strings.AUTO_MERGE_VALUE_MERGE_TYPE;
  } else {
    mergeType = strings.NONE_MERGE_TYPE;
  }

  return mergeType;
}