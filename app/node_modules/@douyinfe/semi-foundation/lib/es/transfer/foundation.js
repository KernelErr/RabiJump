import _omit from "lodash/omit";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _Set from "@babel/runtime-corejs3/core-js-stable/set";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Map from "@babel/runtime-corejs3/core-js-stable/map";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _valuesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/values";
import BaseFoundation from '../base/foundation';
import { strings } from './constants';
import { _generateGroupedData, _generateTreeData } from './transferUtils';
import arrayMove from '../utils/arrayMove'; // eslint-disable-next-line max-len

export default class TransferFoundation extends BaseFoundation {
  constructor(adapter) {
    super(_Object$assign({}, adapter));
  }

  _generateGroupedData(dataSource) {
    return _generateGroupedData(dataSource);
  }

  _generateTreeData(dataSource) {
    return _generateTreeData(dataSource);
  }

  _generatePath(item) {
    const {
      path = []
    } = item;
    return _mapInstanceProperty(path).call(path, p => p.label).join(' > ');
  }

  handleInputChange(inputVal) {
    const {
      data
    } = this.getStates();
    const {
      filter,
      type
    } = this.getProps();

    if (type === strings.TYPE_TREE_TO_LIST) {
      const searchResult = new _Set(_mapInstanceProperty(data).call(data, item => item.key));

      this._adapter.searchTree(inputVal);

      this._adapter.notifySearch(inputVal);

      this._adapter.updateInput(inputVal);

      this._adapter.updateSearchResult(searchResult);

      return;
    }

    const filterFunc = typeof filter === 'function' ? item => filter(inputVal, item) : item => {
      var _context;

      return typeof item.label === 'string' && _includesInstanceProperty(_context = item.label).call(_context, inputVal);
    };

    const searchData = _filterInstanceProperty(data).call(data, filterFunc);

    const searchResult = new _Set(_mapInstanceProperty(searchData).call(searchData, item => item.key));

    this._adapter.notifySearch(inputVal);

    this._adapter.updateInput(inputVal);

    this._adapter.updateSearchResult(searchResult);
  } // Select or cancel all unhidden items


  handleAll(wantAllChecked) {
    const {
      disabled,
      type
    } = this.getProps();
    const {
      selectedItems,
      data,
      searchResult,
      inputValue
    } = this.getStates();

    if (disabled) {
      return;
    }

    const inSearchMode = inputValue !== '';
    let operateData = [];
    operateData = inSearchMode ? _filterInstanceProperty(data).call(data, item => searchResult.has(item.key)) : data;
    operateData = type === strings.TYPE_TREE_TO_LIST ? data : operateData;
    let newSelectedItems = new _Map();

    switch (true) {
      case !wantAllChecked:
        newSelectedItems = new _Map(selectedItems);

        _forEachInstanceProperty(operateData).call(operateData, item => {
          // If the item is disabled, keep it
          if (!item.disabled) {
            newSelectedItems.delete(item.key);
          }
        });

        break;

      case wantAllChecked:
        newSelectedItems = new _Map(selectedItems);

        _forEachInstanceProperty(operateData).call(operateData, item => {
          if (item.disabled) {
            // The disabled item, judge whether it is selected, if it is selected, still need to add the selection
            if (selectedItems.has(item.key)) {
              newSelectedItems.set(item.key, item);
            }

            return;
          }

          newSelectedItems.set(item.key, item);
        });

        break;

      default:
        break;
    }

    if (!this._isControlledComponent()) {
      this._adapter.updateSelected(newSelectedItems);
    }

    this._notifyChange(newSelectedItems);
  }

  handleClear() {
    const {
      disabled
    } = this.getProps();
    const {
      selectedItems,
      data
    } = this.getStates();

    if (disabled) {
      return;
    }

    const newSelectedItems = new _Map(selectedItems);

    _forEachInstanceProperty(data).call(data, item => {
      // If the item is disabled, keep it
      if (!item.disabled) {
        newSelectedItems.delete(item.key);
      }
    });

    if (!this._isControlledComponent()) {
      this._adapter.updateSelected(newSelectedItems);
    }

    this._notifyChange(newSelectedItems);
  }

  handleSelectOrRemove(item) {
    const {
      disabled
    } = this.getProps();

    const selectedItems = this._adapter.getSelected();

    if (disabled || item.disabled) {
      return;
    }

    if (selectedItems.has(item.key)) {
      selectedItems.delete(item.key);

      this._adapter.notifyDeselect(item);
    } else {
      selectedItems.set(item.key, item);

      this._adapter.notifySelect(item);
    }

    if (!this._isControlledComponent()) {
      this._adapter.updateSelected(selectedItems);
    }

    this._notifyChange(selectedItems);
  }

  handleSelect(values) {
    const {
      disabled
    } = this.getProps();

    const selectedItems = this._adapter.getSelected();

    const {
      data
    } = this.getStates();

    const dataItems = _mapInstanceProperty(data).call(data, d => [d.value, d]);

    const allItemsMap = new _Map(dataItems);
    const nextSelectedItemsMap = new _Map();

    if (disabled) {
      return;
    }

    _forEachInstanceProperty(values).call(values, value => {
      const node = allItemsMap.get(value); // The value passed in is an array of the value used, but the internal selectedItems stores a map of keys

      if (selectedItems.has(node.key)) {
        nextSelectedItemsMap.set(node.key, node);
        return;
      }

      if (node.disabled) {
        return;
      }

      nextSelectedItemsMap.set(node.key, node);
      return;
    });

    if (!this._isControlledComponent()) {
      this._adapter.updateSelected(nextSelectedItemsMap);
    }

    this._notifyChange(nextSelectedItemsMap);
  }

  getValuesAndItemsFromMap(selectedItems) {
    const {
      type
    } = this.getProps();
    const items = [];
    const values = [];

    for (const item of selectedItems) {
      const obj = type === strings.TYPE_GROUP_LIST ? _omit(item[1], '_parent') : item[1];
      items.push(obj);
      values.push(obj.value);
    }

    return {
      items,
      values
    };
  }

  _notifyChange(selectedItems) {
    const {
      items,
      values
    } = this.getValuesAndItemsFromMap(selectedItems);

    this._adapter.notifyChange(values, items);
  }

  handleSortEnd(callbackProps) {
    const {
      oldIndex,
      newIndex
    } = callbackProps;

    const selectedItems = this._adapter.getSelected();

    let selectedArr = [..._valuesInstanceProperty(selectedItems).call(selectedItems)];
    selectedArr = arrayMove(selectedArr, oldIndex, newIndex);
    let newSelectedItems = new _Map();

    _forEachInstanceProperty(selectedArr).call(selectedArr, option => {
      newSelectedItems = newSelectedItems.set(option.key, option);
    });

    this._adapter.updateSelected(newSelectedItems);

    this._notifyChange(newSelectedItems);
  }

}