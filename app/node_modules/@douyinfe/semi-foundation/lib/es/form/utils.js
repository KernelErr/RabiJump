import _cloneDeep from "lodash/cloneDeep";
import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _everyInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/every";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && _indexOfInstanceProperty(e).call(e, p) < 0) t[p] = s[p];

  if (s != null && typeof _Object$getOwnPropertySymbols === "function") for (var i = 0, p = _Object$getOwnPropertySymbols(s); i < p.length; i++) {
    if (_indexOfInstanceProperty(e).call(e, p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
/* eslint-disable prefer-destructuring */

/* eslint-disable prefer-const */

/* eslint-disable @typescript-eslint/no-unused-vars */


import AsyncValidator from 'async-validator';

/**
 *
 * @param WrappedComponent React.ComponentType | any
 */
export function getDisplayName(WrappedComponent) {
  const originName = WrappedComponent.displayName || WrappedComponent.name;
  return originName ? "SemiField".concat(originName) : 'SemiField';
}
export function generateValidatesFromRules(field) {
  let rules = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  const descriptor = {};
  descriptor[field] = rules;
  const validator = new AsyncValidator(descriptor);
  return validator;
}
export function isRequired() {
  let rules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let required = false;

  if (typeof rules === 'object' && 'required' in rules) {
    required = rules.required;
  } else if (_Array$isArray(rules) && rules.length) {
    _forEachInstanceProperty(rules).call(rules, rule => {
      rule.required ? required = true : null;
    });
  }

  return required;
}
export function isValid(errors) {
  let valid = true;

  if (typeof errors === 'string' && errors.length) {
    valid = false;
  } else if (_Array$isArray(errors) && errors.length) {
    valid = _everyInstanceProperty(errors).call(errors, error => isValid(error));
  } else if (typeof errors === 'boolean') {
    valid = errors;
  } else if (errors && typeof errors.$$typeof === 'symbol' && errors.$$typeof.toString() === 'Symbol(react.element)') {
    // when error message is reactNode
    valid = false;
  }

  return valid;
} // Compatible with String and Array

function transformTrigger(trigger) {
  let result = [];

  if (_Array$isArray(trigger)) {
    result = trigger;
  }

  if (typeof trigger === 'string') {
    result[0] = trigger;
  }

  return result;
}

export function mergeOptions(opts, props) {
  // Opts: different types of component identification value, value change callback function may be inconsistent, used to adapt 1, input, select 2, radio, checkbox 3, switch
  // valueKey: input, select class component control value props are value, and checkbox, switch is checked
  // eg：checkbox、radio   { valueKey: 'checked', onKeyChangeFnName: 'onChange', valuePath: 'target.value' }
  const defaultOpts = {
    valueKey: 'value',
    onKeyChangeFnName: 'onChange',
    valuePath: '',
    maintainCursor: false,
    shouldInject: true,
    shouldMemo: true
  };

  const options = _Object$assign(_Object$assign({}, defaultOpts), opts); // If the field attribute is declared, then the injection is carried out (mainly used to deal with the case where Checkbox and Radio are used separately from the Group); other cases are subject to options


  const shouldInject = 'field' in props ? true : options.shouldInject;
  return {
    options,
    shouldInject
  };
}
export function mergeProps(props) {
  const defaultProps = {
    trigger: 'change',
    // validateStatus: 'default',
    allowEmptyString: false,
    allowEmpty: false,
    emptyValue: '',
    noLabel: false,
    noErrorMessage: false,
    isInInputGroup: false,
    stopValidateWithError: false
  };

  let _a = _Object$assign(_Object$assign({}, defaultProps), props),
      {
    field,
    label,
    labelPosition,
    labelWidth,
    labelAlign,
    labelCol,
    wrapperCol,
    initValue,
    validate,

    /**
     * error、warning、default、success
     */
    validateStatus,

    /**
     * change、blur、custom、mount
     */
    trigger,
    allowEmptyString,
    allowEmpty,
    emptyValue,
    rules,
    onChange,
    keepState,
    // Conversion before validation
    transform,
    name,
    fieldClassName,
    fieldStyle,
    noLabel,
    noErrorMessage,
    isInInputGroup,
    stopValidateWithError,
    convert,
    showValidateIcon,
    helpText,
    extraText,
    extraTextPosition,
    pure,
    id
  } = _a,
      rest = __rest(_a, ["field", "label", "labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "initValue", "validate", "validateStatus", "trigger", "allowEmptyString", "allowEmpty", "emptyValue", "rules", "onChange", "keepState", "transform", "name", "fieldClassName", "fieldStyle", "noLabel", "noErrorMessage", "isInInputGroup", "stopValidateWithError", "convert", "showValidateIcon", "helpText", "extraText", "extraTextPosition", "pure", "id"]); // Form中的任何类型组件，初始值都统一通过initValue字段来传入，同时将可能会导致组件行为错误的props抽取出来，防止透传到组件中
  // For any type of field component in Form, the initial value is uniformly passed in through the initValue field.
  // At the same time, the props that may cause component behavior errors are extracted to prevent transparent transmission to the component.


  delete rest.defaultChecked;
  delete rest.defaultValue;
  delete rest.checked;

  if (typeof initValue !== 'undefined') {
    initValue = _cloneDeep(initValue);
  }

  const required = isRequired(rules);
  trigger = transformTrigger(trigger);
  emptyValue = typeof emptyValue !== 'undefined' ? emptyValue : '';
  return {
    field,
    label,
    labelPosition,
    labelWidth,
    labelAlign,
    labelCol,
    wrapperCol,
    noLabel,
    noErrorMessage,
    isInInputGroup,
    initValue,
    validate,
    validateStatus,
    trigger,
    allowEmptyString,
    allowEmpty,
    emptyValue,
    rules,
    required,
    keepState,
    transform,
    name,
    fieldClassName,
    fieldStyle,
    convert,
    stopValidateWithError,
    showValidateIcon,
    helpText,
    extraText,
    extraTextPosition,
    pure,
    rest,
    id
  };
}

function bothEmptyArray(val, otherVal) {
  return _Array$isArray(val) && _Array$isArray(otherVal) && !val.length && !otherVal.length;
}