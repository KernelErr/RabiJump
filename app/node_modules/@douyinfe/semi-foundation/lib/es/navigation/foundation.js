import _get from "lodash/get";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _Set from "@babel/runtime-corejs3/core-js-stable/set";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";

/* eslint-disable max-depth */

/* eslint-disable max-len */
import BaseFoundation from '../base/foundation';
import NavItem from './NavItem';
import { strings } from './constants';
import isNullOrUndefined from '../utils/isNullOrUndefined';
export default class NavigationFoundation extends BaseFoundation {
  constructor(adapter) {
    super(_Object$assign({}, adapter));
  }
  /* istanbul ignore next */


  static getZeroParentKeys() {
    let itemKeysMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const willAddKeys = [];

    for (var _len = arguments.length, itemKeys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      itemKeys[_key - 1] = arguments[_key];
    }

    if (itemKeys.length) {
      for (const itemKey of itemKeys) {
        if (_Array$isArray(itemKeysMap[itemKey]) && itemKeysMap[itemKey].length) {
          const levelZeroParentKey = itemKeysMap[itemKey][0];

          if (!isNullOrUndefined(levelZeroParentKey)) {
            willAddKeys.push(levelZeroParentKey);
          }
        }
      }
    }

    return willAddKeys;
  }

  static buildItemKeysMap() {
    let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let keysMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let parentKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    let keyPropName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'itemKey';

    if (_Array$isArray(items) && items.length) {
      for (const item of items) {
        if (_Array$isArray(item)) {
          NavigationFoundation.buildItemKeysMap(item, keysMap, [...parentKeys], keyPropName);
        } else {
          let itemKey;

          if (item && typeof item === 'object') {
            itemKey = item[keyPropName] || item.props && item.props[keyPropName];
          }

          if (itemKey) {
            keysMap[itemKey] = [...parentKeys];

            if (_Array$isArray(item.items) && item.items.length) {
              NavigationFoundation.buildItemKeysMap(item.items, keysMap, [...parentKeys, itemKey], keyPropName);
            } else if (item.props && item.props.children) {
              const children = _Array$isArray(item.props.children) ? item.props.children : [item.props.children];
              NavigationFoundation.buildItemKeysMap(children, keysMap, [...parentKeys, itemKey], keyPropName);
            }
          }
        }
      }
    }

    return keysMap;
  }
  /**
   * init is called in constructor and componentDidMount.
   * if you want to update state in constructor, please add it to return object;
   * if you want to update state in componentDidMount, please call adapter in else logic.
   * @param {*} lifecycle
   * @returns
   */


  init(lifecycle) {
    const {
      defaultSelectedKeys,
      selectedKeys
    } = this.getProps();
    let willSelectedKeys = selectedKeys || defaultSelectedKeys || [];
    const {
      itemKeysMap,
      willOpenKeys,
      formattedItems
    } = this.getCalcState();
    const parentSelectKeys = this.selectLevelZeroParentKeys(itemKeysMap, willSelectedKeys);
    willSelectedKeys = _concatInstanceProperty(willSelectedKeys).call(willSelectedKeys, parentSelectKeys);

    if (lifecycle === 'constructor') {
      return {
        selectedKeys: willSelectedKeys,
        itemKeysMap,
        openKeys: willOpenKeys,
        items: formattedItems
      };
    } else {
      this._adapter.updateSelectedKeys(willSelectedKeys);

      this._adapter.setItemKeysMap(itemKeysMap);

      this._adapter.updateOpenKeys(willOpenKeys);

      this._adapter.updateItems(formattedItems);

      this._adapter.setItemsChanged(true);
    }

    return undefined;
  }
  /**
   * Get the state to be calculated
   */


  getCalcState() {
    const {
      itemKeysMap,
      formattedItems
    } = this.getFormattedItems();
    const willOpenKeys = this.getWillOpenKeys(itemKeysMap);
    return {
      itemKeysMap,
      willOpenKeys,
      formattedItems
    };
  }
  /**
   * Calculate formatted items and itemsKeyMap
   */


  getFormattedItems() {
    const {
      items,
      children
    } = this.getProps();
    const formattedItems = this.formatItems(items);
    const willHandleItems = _Array$isArray(items) && items.length ? formattedItems : children;
    const itemKeysMap = NavigationFoundation.buildItemKeysMap(willHandleItems);
    return {
      itemKeysMap,
      formattedItems
    };
  }
  /**
   * Calculate the keys that will need to be opened soon
   * @param {*} itemKeysMap
   */


  getWillOpenKeys(itemKeysMap) {
    const {
      defaultOpenKeys,
      openKeys,
      defaultSelectedKeys,
      selectedKeys,
      mode
    } = this.getProps();
    let willOpenKeys = openKeys || defaultOpenKeys || [];

    if (!(_Array$isArray(defaultOpenKeys) || _Array$isArray(openKeys)) && mode === strings.MODE_VERTICAL && (_Array$isArray(defaultSelectedKeys) || _Array$isArray(selectedKeys))) {
      const currentSelectedKeys = _Array$isArray(selectedKeys) ? selectedKeys : defaultSelectedKeys;
      willOpenKeys = this.getShouldOpenKeys(itemKeysMap, currentSelectedKeys);
    }

    return [...willOpenKeys];
  }

  getItemKey(item) {
    let keyPropName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'itemKey';

    if (item && typeof item === 'object') {
      return item[keyPropName];
    }

    return item;
  }

  getShouldOpenKeys() {
    let itemKeysMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let selectedKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    const willOpenKeySet = new _Set();

    if (_Array$isArray(selectedKeys) && selectedKeys.length) {
      _forEachInstanceProperty(selectedKeys).call(selectedKeys, item => {
        if (item) {
          const parentKeys = _get(itemKeysMap, this.getItemKey(item));

          if (_Array$isArray(parentKeys)) {
            _forEachInstanceProperty(parentKeys).call(parentKeys, k => willOpenKeySet.add(k));
          }
        }
      });
    }

    return [...willOpenKeySet];
  }

  destroy() {} // eslint-disable-line


  selectLevelZeroParentKeys(itemKeysMap) {
    const _itemKeysMap = isNullOrUndefined(itemKeysMap) ? this.getState('itemKeysMap') : itemKeysMap; // console.log(itemKeysMap);


    const willAddKeys = [];

    for (var _len2 = arguments.length, itemKeys = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      itemKeys[_key2 - 1] = arguments[_key2];
    }

    if (itemKeys.length) {
      for (const itemKey of itemKeys) {
        if (_Array$isArray(_itemKeysMap[itemKey]) && _itemKeysMap[itemKey].length) {
          const levelZeroParentKey = _itemKeysMap[itemKey][0];

          if (!isNullOrUndefined(levelZeroParentKey)) {
            willAddKeys.push(levelZeroParentKey);
          }
        }
      }
    }

    if (willAddKeys.length) {
      return willAddKeys;
    }

    return [];
  }

  formatItems() {
    let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    const formattedItems = [];

    for (const item of items) {
      formattedItems.push(new NavItem(item));
    }

    return formattedItems;
  }

  handleSelect(data) {
    this._adapter.notifySelect(data);
  }
  /* istanbul ignore next */


  judgeIfOpen(openKeys, items) {
    let shouldBeOpen = false;

    const _openKeys = _Array$isArray(openKeys) ? openKeys : openKeys && [openKeys];

    if (_openKeys && _Array$isArray(items) && items.length) {
      for (const item of items) {
        shouldBeOpen = _includesInstanceProperty(_openKeys).call(_openKeys, item.itemKey) || this.judgeIfOpen(_openKeys, item.items);

        if (shouldBeOpen) {
          break;
        }
      }
    }

    return shouldBeOpen;
  }

  handleCollapseChange() {
    const isCollapsed = !this.getState('isCollapsed');

    if (!this._isControlledComponent('isCollapsed')) {
      this._adapter.setIsCollapsed(isCollapsed);
    }

    this._adapter.notifyCollapseChange(isCollapsed);
  }

  handleItemsChange(isChanged) {
    this._adapter.setItemsChanged(isChanged);
  }

}