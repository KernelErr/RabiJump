import _isEqual from "lodash/isEqual";
import _get from "lodash/get";
import _noop from "lodash/noop";
import _Set from "@babel/runtime-corejs3/core-js-stable/set";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Array$from from "@babel/runtime-corejs3/core-js-stable/array/from";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _spliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/splice";

/* eslint-disable max-lines-per-function */
import BaseComponent from '../_base/baseComponent';
import React, { Children } from 'react';
import PropTypes from 'prop-types';
import cls from 'classnames';
import NavigationFoundation from '@douyinfe/semi-foundation/lib/es/navigation/foundation';
import { strings, cssClasses, numbers } from '@douyinfe/semi-foundation/lib/es/navigation/constants';
import SubNav from './SubNav';
import Item from './Item';
import Footer from './Footer';
import Header from './Header';
import NavContext from './nav-context';
import LocaleConsumer from '../locale/localeConsumer';
import '@douyinfe/semi-foundation/lib/es/navigation/navigation.css';

function createAddKeysFn(context, keyName) {
  return function addKeys() {
    const handleKeys = new _Set(context.state[keyName]);

    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }

    _forEachInstanceProperty(keys).call(keys, key => key && handleKeys.add(key));

    context.setState({
      [keyName]: _Array$from(handleKeys)
    });
  };
}

function createRemoveKeysFn(context, keyName) {
  return function removeKeys() {
    const handleKeys = new _Set(context.state[keyName]);

    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      keys[_key2] = arguments[_key2];
    }

    _forEachInstanceProperty(keys).call(keys, key => key && handleKeys.delete(key));

    context.setState({
      [keyName]: _Array$from(handleKeys)
    });
  };
}

const {
  hasOwnProperty
} = Object.prototype;

class Nav extends BaseComponent {
  constructor(props) {
    super(props);

    this.onCollapseChange = () => {
      this.foundation.handleCollapseChange();
    };

    this.foundation = new NavigationFoundation(this.adapter);
    this.itemsChanged = true;
    const {
      isCollapsed,
      defaultIsCollapsed,
      items,
      children
    } = props;
    const initState = {
      isCollapsed: Boolean(this.isControlled('isCollapsed') ? isCollapsed : defaultIsCollapsed),
      // calc state
      openKeys: [],
      items: [],
      itemKeysMap: {},
      selectedKeys: []
    };
    this.state = _Object$assign({}, initState);

    if (items && items.length || children) {
      const calcState = this.foundation.init('constructor');
      this.state = _Object$assign(_Object$assign({}, initState), calcState);
    }
  }

  static getDerivedStateFromProps(props, state) {
    const willUpdateState = {};

    if (hasOwnProperty.call(props, 'isCollapsed') && props.isCollapsed !== state.isCollapsed) {
      willUpdateState.isCollapsed = props.isCollapsed;
    }

    return willUpdateState;
  }

  componentDidMount() {// override BaseComponent
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevProps.items !== this.props.items || prevProps.children !== this.props.children) {
      this.foundation.init();
    } else {
      this.foundation.handleItemsChange(false);
      const {
        selectedKeys
      } = this.state;

      if (this.props.selectedKeys && !_isEqual(prevProps.selectedKeys, this.props.selectedKeys)) {
        this.adapter.updateSelectedKeys(this.props.selectedKeys);
      }

      if (this.props.openKeys && !_isEqual(prevProps.openKeys, this.props.openKeys)) {
        this.adapter.updateOpenKeys(this.props.openKeys);
      }

      if (!_isEqual(selectedKeys, prevState.selectedKeys)) {
        const parentSelectKeys = this.foundation.selectLevelZeroParentKeys(null, ...selectedKeys);
        this.adapter.addSelectedKeys(...parentSelectKeys);
      }
    }
  }

  get adapter() {
    var _this = this;

    return _Object$assign(_Object$assign({}, super.adapter), {
      notifySelect: function () {
        return _this.props.onSelect(...arguments);
      },
      notifyOpenChange: function () {
        return _this.props.onOpenChange(...arguments);
      },
      setIsCollapsed: isCollapsed => this.setState({
        isCollapsed
      }),
      notifyCollapseChange: function () {
        return _this.props.onCollapseChange(...arguments);
      },
      updateItems: items => this.setState({
        items: [...items]
      }),
      setItemKeysMap: itemKeysMap => this.setState({
        itemKeysMap: _Object$assign({}, itemKeysMap)
      }),
      addSelectedKeys: createAddKeysFn(this, 'selectedKeys'),
      removeSelectedKeys: createRemoveKeysFn(this, 'selectedKeys'),
      updateSelectedKeys: selectedKeys => this.setState({
        selectedKeys: [...selectedKeys]
      }),
      updateOpenKeys: openKeys => this.setState({
        openKeys: [...openKeys]
      }),
      addOpenKeys: createAddKeysFn(this, 'openKeys'),
      removeOpenKeys: createRemoveKeysFn(this, 'openKeys'),
      setItemsChanged: isChanged => {
        this.itemsChanged = isChanged;
      }
    });
  }
  /**
   * Render navigation items recursively
   *
   * @param {NavItem[]} items
   * @returns {JSX.Element}
   */


  renderItems() {
    let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const finalDom = /*#__PURE__*/React.createElement(React.Fragment, null, _mapInstanceProperty(items).call(items, (item, idx) => {
      if (_Array$isArray(item.items) && item.items.length) {
        return /*#__PURE__*/React.createElement(SubNav, _Object$assign({
          key: item.itemKey || String(level) + idx
        }, item, {
          level: level
        }), this.renderItems(item.items, level + 1));
      } else {
        return /*#__PURE__*/React.createElement(Item, _Object$assign({
          key: item.itemKey || String(level) + idx
        }, item, {
          level: level
        }));
      }
    }));
    return finalDom;
  }

  render() {
    const {
      children: originChildren,
      mode,
      onOpenChange,
      onSelect,
      onClick,
      style,
      className,
      subNavCloseDelay,
      subNavOpenDelay,
      subNavMotion,
      tooltipShowDelay,
      tooltipHideDelay,
      prefixCls,
      bodyStyle,
      footer,
      header,
      toggleIconPosition,
      limitIndent
    } = this.props;
    const {
      selectedKeys,
      openKeys,
      items,
      isCollapsed
    } = this.state;
    const {
      updateOpenKeys,
      addOpenKeys,
      removeOpenKeys,
      updateSelectedKeys,
      addSelectedKeys,
      removeSelectedKeys
    } = this.adapter;

    const finalStyle = _Object$assign({}, style);

    let children = Children.toArray(originChildren);
    const footers = [];
    const headers = [];

    if ( /*#__PURE__*/React.isValidElement(footer)) {
      footers.push( /*#__PURE__*/React.createElement(Footer, {
        key: 0
      }, footer));
    } else if (footer && typeof footer === 'object') {
      footers.push( /*#__PURE__*/React.createElement(Footer, _Object$assign({
        key: 0
      }, footer)));
    }

    if ( /*#__PURE__*/React.isValidElement(header)) {
      headers.push( /*#__PURE__*/React.createElement(Header, {
        key: 0
      }, header));
    } else if (header && typeof header === 'object') {
      headers.push( /*#__PURE__*/React.createElement(Header, _Object$assign({
        key: 0
      }, header)));
    }

    if (_Array$isArray(children) && children.length) {
      children = [...children];
      let childrenLength = children.length;

      for (let i = 0; i < childrenLength; i++) {
        const child = children[i];

        if (child.type === Footer || _get(child, 'type.name') === 'NavFooter') {
          footers.push(child);

          _spliceInstanceProperty(children).call(children, i, 1);

          i--;
          childrenLength--;
        } else if (child.type === Header || _get(child, 'type.name') === 'NavHeader') {
          headers.push(child);

          _spliceInstanceProperty(children).call(children, i, 1);

          i--;
          childrenLength--;
        }
      }
    }

    const finalCls = cls(prefixCls, className, {
      ["".concat(prefixCls, "-collapsed")]: isCollapsed,
      ["".concat(prefixCls, "-horizontal")]: mode === 'horizontal',
      ["".concat(prefixCls, "-vertical")]: mode === 'vertical'
    });
    const headerListOuterCls = cls("".concat(prefixCls, "-header-list-outer"), {
      ["".concat(prefixCls, "-header-list-outer-collapsed")]: isCollapsed
    });

    if (this.itemsChanged) {
      this.adapter.setCache('itemElems', this.renderItems(items));
    }

    return /*#__PURE__*/React.createElement(LocaleConsumer, {
      componentName: "Navigation"
    }, locale => /*#__PURE__*/React.createElement(NavContext.Provider, {
      value: {
        subNavCloseDelay,
        subNavOpenDelay,
        subNavMotion,
        tooltipShowDelay,
        tooltipHideDelay,
        openKeys,
        openKeysIsControlled: this.isControlled('openKeys') && mode === 'vertical' && !isCollapsed,
        // canUpdateOpenKeys: mode === 'vertical' && !isCollapsed,
        canUpdateOpenKeys: true,
        selectedKeys,
        selectedKeysIsControlled: this.isControlled('selectedKeys'),
        isCollapsed,
        onCollapseChange: this.onCollapseChange,
        mode,
        onSelect,
        onOpenChange,
        updateOpenKeys,
        addOpenKeys,
        removeOpenKeys,
        updateSelectedKeys,
        addSelectedKeys,
        removeSelectedKeys,
        onClick,
        locale,
        prefixCls,
        toggleIconPosition,
        limitIndent
      }
    }, /*#__PURE__*/React.createElement("div", {
      className: finalCls,
      style: finalStyle
    }, /*#__PURE__*/React.createElement("div", {
      className: "".concat(prefixCls, "-inner")
    }, /*#__PURE__*/React.createElement("div", {
      className: headerListOuterCls
    }, headers, /*#__PURE__*/React.createElement("div", {
      style: bodyStyle,
      className: "".concat(prefixCls, "-list-wrapper")
    }, /*#__PURE__*/React.createElement("ul", {
      role: "menu",
      "aria-orientation": mode,
      className: "".concat(prefixCls, "-list")
    }, this.adapter.getCache('itemElems'), children))), footers))));
  }

}

Nav.Sub = SubNav;
Nav.Item = Item;
Nav.Header = Header;
Nav.Footer = Footer;
Nav.propTypes = {
  // Initial expanded SubNav navigation key array
  defaultOpenKeys: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),
  openKeys: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),
  // Initial selected navigation key array
  defaultSelectedKeys: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),
  selectedKeys: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),
  // Navigation type, now supports vertical, horizontal
  mode: PropTypes.oneOf([...strings.MODE]),
  // Triggered when selecting a navigation item
  onSelect: PropTypes.func,
  // Triggered when clicking a navigation item
  onClick: PropTypes.func,
  // SubNav expand/close callback
  onOpenChange: PropTypes.func,
  // Array of options (nested options can continue)
  items: PropTypes.array,
  // Is it in the state of being stowed to the sidebar
  isCollapsed: PropTypes.bool,
  defaultIsCollapsed: PropTypes.bool,
  onCollapseChange: PropTypes.func,
  multiple: PropTypes.bool,
  onDeselect: PropTypes.func,
  subNavMotion: PropTypes.oneOfType([PropTypes.bool, PropTypes.object, PropTypes.func]),
  subNavCloseDelay: PropTypes.number,
  subNavOpenDelay: PropTypes.number,
  tooltipShowDelay: PropTypes.number,
  tooltipHideDelay: PropTypes.number,
  children: PropTypes.node,
  style: PropTypes.object,
  bodyStyle: PropTypes.object,
  className: PropTypes.string,
  toggleIconPosition: PropTypes.string,
  prefixCls: PropTypes.string,
  header: PropTypes.oneOfType([PropTypes.node, PropTypes.object]),
  footer: PropTypes.oneOfType([PropTypes.node, PropTypes.object]),
  limitIndent: PropTypes.bool
};
Nav.defaultProps = {
  subNavCloseDelay: numbers.DEFAULT_SUBNAV_CLOSE_DELAY,
  subNavOpenDelay: numbers.DEFAULT_SUBNAV_OPEN_DELAY,
  tooltipHideDelay: numbers.DEFAULT_TOOLTIP_HIDE_DELAY,
  tooltipShowDelay: numbers.DEFAULT_TOOLTIP_SHOW_DELAY,
  onCollapseChange: _noop,
  onSelect: _noop,
  onClick: _noop,
  onOpenChange: _noop,
  toggleIconPosition: 'right',
  limitIndent: true,
  prefixCls: cssClasses.PREFIX,
  subNavMotion: true,
  // isOpen: false,
  mode: strings.MODE_VERTICAL // defaultOpenKeys: [],
  // defaultSelectedKeys: [],
  // items: [],

};
export default Nav;