import _times from "lodash/times";
import _noop from "lodash/noop";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";

/* eslint-disable max-len */

/* eslint-disable no-nested-ternary */
import BaseComponent from '../_base/baseComponent';
import React from 'react';
import PropTypes from 'prop-types';
import cls from 'classnames';
import isNullOrUndefined from '@douyinfe/semi-foundation/lib/es/utils/isNullOrUndefined';
import { cloneDeep, isSemiIcon } from '../_utils';
import ItemFoundation from '@douyinfe/semi-foundation/lib/es/navigation/itemFoundation';
import { cssClasses, strings } from '@douyinfe/semi-foundation/lib/es/navigation/constants';
import Tooltip from '../tooltip';
import NavContext from './nav-context';
import Dropdown from '../dropdown';
const clsPrefix = "".concat(cssClasses.PREFIX, "-item");
export default class NavItem extends BaseComponent {
  constructor(props) {
    super(props);

    this.setItemRef = ref => {
      // console.log('Item - setItemRef()', ref);
      this.props.forwardRef && this.props.forwardRef(ref);
    };

    this.wrapTooltip = node => {
      const {
        text,
        tooltipHideDelay,
        tooltipShowDelay
      } = this.props;
      return /*#__PURE__*/React.createElement(Tooltip, {
        content: text,
        position: "right",
        trigger: 'hover',
        mouseEnterDelay: tooltipShowDelay,
        mouseLeaveDelay: tooltipHideDelay
      }, node);
    };

    this.handleClick = e => this.foundation.handleClick(e);

    this.handleKeyPress = e => this.foundation.handleKeyPress(e);

    this.state = {
      tooltipShow: false
    };
    this.foundation = new ItemFoundation(this.adapter);
  }

  _invokeContextFunc(funcName) {
    if (funcName && this.context && typeof this.context[funcName] === 'function') {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return this.context[funcName](...args);
    }

    return null;
  }

  get adapter() {
    var _this = this;

    return _Object$assign(_Object$assign({}, super.adapter), {
      cloneDeep,
      updateTooltipShow: tooltipShow => this.setState({
        tooltipShow
      }),
      updateSelected: _selected => this._invokeContextFunc('updateSelectedKeys', [this.props.itemKey]),
      updateGlobalSelectedKeys: keys => this._invokeContextFunc('updateSelectedKeys', [...keys]),
      getSelectedKeys: () => this.context && this.context.selectedKeys,
      getSelectedKeysIsControlled: () => this.context && this.context.selectedKeysIsControlled,
      notifyGlobalOnSelect: function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return _this._invokeContextFunc('onSelect', ...args);
      },
      notifyGlobalOnClick: function () {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return _this._invokeContextFunc('onClick', ...args);
      },
      notifyClick: function () {
        return _this.props.onClick(...arguments);
      },
      notifyMouseEnter: function () {
        return _this.props.onMouseEnter(...arguments);
      },
      notifyMouseLeave: function () {
        return _this.props.onMouseLeave(...arguments);
      },
      getIsCollapsed: () => this.props.isCollapsed || Boolean(this.context && this.context.isCollapsed) || false,
      getSelected: () => {
        var _context;

        return Boolean(this.context && this.context.selectedKeys && _includesInstanceProperty(_context = this.context.selectedKeys).call(_context, this.props.itemKey));
      },
      getIsOpen: () => {
        var _context2;

        return Boolean(this.context && this.context.openKeys && _includesInstanceProperty(_context2 = this.context.openKeys).call(_context2, this.props.itemKey));
      }
    });
  }

  renderIcon(icon, pos) {
    var _context3;

    let isToggleIcon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    if (this.props.isSubNav) {
      return null;
    }

    if (!icon && this.context.mode === strings.MODE_HORIZONTAL) {
      return null;
    }

    let iconSize = 'large';

    if (pos === strings.ICON_POS_RIGHT) {
      iconSize = 'default';
    }

    const className = cls("".concat(clsPrefix, "-icon"), {
      [_concatInstanceProperty(_context3 = "".concat(clsPrefix, "-icon-toggle-")).call(_context3, this.context.toggleIconPosition)]: isToggleIcon,
      ["".concat(clsPrefix, "-icon-info")]: !isToggleIcon
    });
    return /*#__PURE__*/React.createElement("i", {
      className: className,
      key: key
    }, isSemiIcon(icon) ? /*#__PURE__*/React.cloneElement(icon, {
      size: icon.props.size || iconSize
    }) : icon);
  }

  render() {
    const {
      text,
      children,
      icon,
      toggleIcon,
      className,
      isSubNav,
      style,
      indent,
      onMouseEnter,
      onMouseLeave,
      link,
      linkOptions,
      disabled,
      level = 0
    } = this.props;
    const {
      mode,
      isInSubNav,
      prefixCls,
      limitIndent
    } = this.context;
    const isCollapsed = this.adapter.getIsCollapsed();
    const selected = this.adapter.getSelected();
    let itemChildren = null;

    if (!isNullOrUndefined(children)) {
      itemChildren = children;
    } else {
      let placeholderIcons = null;

      if (mode === strings.MODE_VERTICAL && !limitIndent && !isCollapsed) {
        const iconAmount = icon && !indent ? level : level - 1;
        placeholderIcons = _times(iconAmount, index => this.renderIcon(null, strings.ICON_POS_RIGHT, false, index));
      }

      itemChildren = /*#__PURE__*/React.createElement(React.Fragment, null, placeholderIcons, this.context.toggleIconPosition === strings.TOGGLE_ICON_LEFT && this.renderIcon(toggleIcon, strings.ICON_POS_RIGHT, true, 'key-toggle-pos-right'), icon || indent || isInSubNav ? this.renderIcon(icon, strings.ICON_POS_LEFT, false, 'key-position-left') : null, !isNullOrUndefined(text) ? /*#__PURE__*/React.createElement("span", {
        className: "".concat(cssClasses.PREFIX, "-item-text")
      }, text) : '', this.context.toggleIconPosition === strings.TOGGLE_ICON_RIGHT && this.renderIcon(toggleIcon, strings.ICON_POS_RIGHT, true, 'key-toggle-pos-right'));
    }

    if (typeof link === 'string') {
      itemChildren = /*#__PURE__*/React.createElement("a", _Object$assign({
        className: "".concat(prefixCls, "-item-link"),
        href: link
      }, linkOptions), itemChildren);
    }

    let itemDom = '';

    if (isInSubNav && (isCollapsed || mode === strings.MODE_HORIZONTAL)) {
      const popoverItemCls = cls({
        [clsPrefix]: true,
        ["".concat(clsPrefix, "-sub")]: isSubNav,
        ["".concat(clsPrefix, "-selected")]: selected,
        ["".concat(clsPrefix, "-collapsed")]: isCollapsed,
        ["".concat(clsPrefix, "-disabled")]: disabled
      });
      itemDom = /*#__PURE__*/React.createElement(Dropdown.Item, {
        selected: selected,
        active: selected,
        forwardRef: this.setItemRef,
        className: popoverItemCls,
        onClick: this.handleClick,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        disabled: disabled
      }, itemChildren);
    } else {
      // Items are divided into normal and sub-wrap
      const popoverItemCls = cls("".concat(className || "".concat(clsPrefix, "-normal")), {
        [clsPrefix]: true,
        ["".concat(clsPrefix, "-sub")]: isSubNav,
        ["".concat(clsPrefix, "-selected")]: selected && !isSubNav,
        ["".concat(clsPrefix, "-collapsed")]: isCollapsed,
        ["".concat(clsPrefix, "-disabled")]: disabled
      });
      const ariaProps = {
        'aria-disabled': disabled
      };

      if (isSubNav) {
        const isOpen = this.adapter.getIsOpen();
        ariaProps['aria-expanded'] = isOpen;
      }

      itemDom = /*#__PURE__*/React.createElement("li", _Object$assign({
        role: "menuitem",
        tabIndex: -1
      }, ariaProps, {
        style: style,
        ref: this.setItemRef,
        className: popoverItemCls,
        onClick: this.handleClick,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onKeyPress: this.handleKeyPress
      }), itemChildren);
    } // Display Tooltip when disabled and SubNav


    if (isCollapsed && !isInSubNav && !isSubNav || isCollapsed && isSubNav && disabled) {
      itemDom = this.wrapTooltip(itemDom);
    }

    return itemDom;
  }

}
NavItem.contextType = NavContext;
NavItem.propTypes = {
  text: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  itemKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  onClick: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  children: PropTypes.node,
  icon: PropTypes.oneOfType([PropTypes.node]),
  className: PropTypes.string,
  toggleIcon: PropTypes.string,
  style: PropTypes.object,
  forwardRef: PropTypes.func,
  indent: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),
  isCollapsed: PropTypes.bool,
  isSubNav: PropTypes.bool,
  link: PropTypes.string,
  linkOptions: PropTypes.object,
  disabled: PropTypes.bool
};
NavItem.defaultProps = {
  isSubNav: false,
  indent: false,
  forwardRef: _noop,
  isCollapsed: false,
  onClick: _noop,
  onMouseEnter: _noop,
  onMouseLeave: _noop,
  disabled: false
};