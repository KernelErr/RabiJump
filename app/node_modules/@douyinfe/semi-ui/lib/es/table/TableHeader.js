import _isFunction from "lodash/isFunction";
import _noop from "lodash/noop";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _reduceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/reduce";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _Set from "@babel/runtime-corejs3/core-js-stable/set";

/* eslint-disable max-len */
import React from 'react';
import BaseComponent from '../_base/baseComponent';
import PropTypes from 'prop-types';
import { strings, cssClasses } from '@douyinfe/semi-foundation/lib/es/table/constants';
import TableHeaderRow from './TableHeaderRow';

function parseHeaderRows(columns) {
  const rows = []; // eslint-disable-next-line @typescript-eslint/no-shadow

  function fillRowCells(columns, colIndex) {
    let parents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    let rowIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    // Init rows
    rows[rowIndex] = rows[rowIndex] || [];
    let currentColIndex = colIndex;

    const colSpans = _mapInstanceProperty(columns).call(columns, column => {
      const cell = {
        key: column.key,
        className: column.className || '',
        children: _isFunction(column.title) ? column.title() : column.title,
        column,
        colStart: currentColIndex,
        level,
        parents
      };
      let colSpan = 1;
      /**
        * Calculate header column merge colSpan
        *  - If the current cell has children, colSpan = the sum of children rowSpan
        *  - If the current cell has no children, colSpan = 1
        */

      const subColumns = column.children;

      if (subColumns && subColumns.length > 0) {
        var _context;

        colSpan = _reduceInstanceProperty(_context = fillRowCells(subColumns, currentColIndex, [...parents, cell], rowIndex + 1, level + 1)).call(_context, (total, count) => total + count, 0);
        cell.hasSubColumns = true;
      }

      if ('colSpan' in column) {
        ({
          colSpan
        } = column);
      }

      if ('rowSpan' in column) {
        cell.rowSpan = column.rowSpan;
      }

      if (column.key === strings.DEFAULT_KEY_COLUMN_SCROLLBAR) {
        cell['x-type'] = strings.DEFAULT_KEY_COLUMN_SCROLLBAR;
      }

      cell.colSpan = colSpan;
      cell.colEnd = cell.colStart + colSpan - 1;
      rows[rowIndex].push(cell);
      currentColIndex += colSpan;
      return colSpan;
    });

    return colSpans;
  } // Generate `rows` cell data


  fillRowCells(columns, 0);
  /**
   * Calculate header row merge rowSpan
   *  - If the current cell has no children, you need to calculate rowSpan, rowSpan = the total number of rows in the header-which row currently belongs to
   *  - If the current cell has children, there is no need to calculate rowSpan
   *
   * 计算表头行合并 rowSpan
   *  - 如果当前cell没有children，则需要计算rowSpan，rowSpan = 表头总行数 - 当前属于第几行
   *  - 如果当前cell有children，则无需计算rowSpan
   */

  const rowCount = rows.length;

  for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
    var _context2;

    _forEachInstanceProperty(_context2 = rows[rowIndex]).call(_context2, cell => {
      if (!('rowSpan' in cell) && !cell.hasSubColumns) {
        // eslint-disable-next-line no-param-reassign
        cell.rowSpan = rowCount - rowIndex;
      }
    });
  }

  return rows;
}
/**
 * Render the header of the table header, and control the merging of the columns of the header
 */


class TableHeader extends BaseComponent {
  get adapter() {
    return _Object$assign({}, super.adapter);
  }

  render() {
    const {
      components,
      columns,
      prefixCls,
      fixed,
      onHeaderRow,
      forwardedRef,
      selectedRowKeysSet
    } = this.props;
    const rows = parseHeaderRows(columns);
    const HeaderWrapper = components.header.wrapper;
    return /*#__PURE__*/React.createElement(HeaderWrapper, {
      className: "".concat(prefixCls, "-thead"),
      ref: forwardedRef
    }, _mapInstanceProperty(rows).call(rows, (row, idx) => /*#__PURE__*/React.createElement(TableHeaderRow, {
      prefixCls: prefixCls,
      key: idx,
      index: idx,
      fixed: fixed,
      columns: columns,
      row: row,
      components: components,
      onHeaderRow: onHeaderRow,
      selectedRowKeysSet: selectedRowKeysSet
    })));
  }

}

TableHeader.propTypes = {
  components: PropTypes.any,
  columns: PropTypes.array,
  columnManager: PropTypes.object,
  prefixCls: PropTypes.string,
  onHeaderRow: PropTypes.func,
  onDidUpdate: PropTypes.func,
  fixed: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
  selectedRowKeysSet: PropTypes.instanceOf(_Set).isRequired
};
TableHeader.defaultProps = {
  columns: [],
  prefixCls: cssClasses.PREFIX,
  onHeaderRow: _noop,
  onDidUpdate: _noop,
  components: {
    header: {
      wrapper: 'thead',
      row: 'tr',
      cell: 'th'
    }
  }
};
export default /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(TableHeader, _Object$assign({}, props, {
  forwardedRef: ref
})));