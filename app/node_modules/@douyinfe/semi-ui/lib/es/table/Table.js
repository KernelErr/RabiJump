import _isObject from "lodash/isObject";
import _isFunction from "lodash/isFunction";
import _difference from "lodash/difference";
import _isNull from "lodash/isNull";
import _omit from "lodash/omit";
import _each from "lodash/each";
import _flattenDeep from "lodash/flattenDeep";
import _debounce from "lodash/debounce";
import _some from "lodash/some";
import _findIndex from "lodash/findIndex";
import _find from "lodash/find";
import _includes from "lodash/includes";
import _noop from "lodash/noop";
import _get from "lodash/get";
import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _reduceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/reduce";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _Set from "@babel/runtime-corejs3/core-js-stable/set";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && _indexOfInstanceProperty(e).call(e, p) < 0) t[p] = s[p];

  if (s != null && typeof _Object$getOwnPropertySymbols === "function") for (var i = 0, p = _Object$getOwnPropertySymbols(s); i < p.length; i++) {
    if (_indexOfInstanceProperty(e).call(e, p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
/* eslint-disable no-nested-ternary */

/* eslint-disable prefer-const */

/* eslint-disable prefer-destructuring */

/* eslint-disable no-shadow */

/* eslint-disable no-param-reassign */

/* eslint-disable max-len */

/* eslint-disable react/no-did-update-set-state */

/* eslint-disable eqeqeq */

/* eslint-disable max-lines-per-function */


import React, { createRef, isValidElement } from 'react';
import PropTypes from 'prop-types';
import classnames from 'classnames';
import { mergeQueries, equalWith, mergeColumns, assignColumnKeys, flattenColumns, getAllDisabledRowKeys } from '@douyinfe/semi-foundation/lib/es/table/utils';
import Store from '@douyinfe/semi-foundation/lib/es/utils/Store';
import TableFoundation from '@douyinfe/semi-foundation/lib/es/table/foundation';
import { strings, cssClasses, numbers } from '@douyinfe/semi-foundation/lib/es/table/constants';
import '@douyinfe/semi-foundation/lib/es/table/table.css';
import Spin from '../spin';
import BaseComponent from '../_base/baseComponent';
import LocaleConsumer from '../locale/localeConsumer';
import ColumnShape from './ColumnShape';
import getColumns from './getColumns';
import TableContext from './table-context';
import TableContextProvider from './TableContextProvider';
import ColumnSelection from './ColumnSelection';
import TablePagination from './TablePagination';
import ColumnFilter from './ColumnFilter';
import ColumnSorter from './ColumnSorter';
import ExpandedIcon from './CustomExpandIcon';
import HeadTable from './HeadTable';
import BodyTable from './Body';
import { logger, cloneDeep, mergeComponents } from './utils';

class Table extends BaseComponent {
  constructor(props, context) {
    var _this;

    super(props);
    _this = this;

    // TODO: notify when data don't have key
    this._warnIfNoKey = () => {
      if ((this.props.rowSelection || this.props.expandedRowRender) && _some(this.props.dataSource, record => this.foundation.getRecordKey(record) == null)) {
        logger.error('You must specify a key for each element in the dataSource or use "rowKey" to specify an attribute name as the primary key!');
      }
    };

    this._invokeRowSelection = function (funcName) {
      const func = _get(_this.state, ['rowSelection', funcName]);

      if (typeof func === 'function') {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        func(...args);
      }
    };

    this._invokeColumnFn = function (key, funcName) {
      if (key && funcName) {
        const column = _this.foundation.getQuery(key);

        const func = _get(column, funcName, null);

        if (typeof func === 'function') {
          for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          func(...args);
        }
      }
    };

    this._cacheHeaderRef = node => {
      this.headerWrapRef.current = node;
    };

    this.getCurrentPageData = () => {
      var _context;

      const pageData = this.foundation.getCurrentPageData();

      const retObj = _reduceInstanceProperty(_context = ['dataSource', 'groups']).call(_context, (result, key) => {
        if (pageData[key]) {
          result[key] = pageData[key];
        }

        return result;
      }, {});

      return cloneDeep(retObj);
    };

    this.getColumns = (columns, children) => !_Array$isArray(columns) || !columns || !columns.length ? getColumns(children) : columns; // @ts-ignore


    this.getCellWidths = function () {
      return _this.foundation.getCellWidths(...arguments);
    }; // @ts-ignore


    this.setHeadWidths = function () {
      return _this.foundation.setHeadWidths(...arguments);
    }; // @ts-ignore


    this.getHeadWidths = function () {
      return _this.foundation.getHeadWidths(...arguments);
    }; // @ts-ignore


    this.mergedRowExpandable = function () {
      return _this.foundation.mergedRowExpandable(...arguments);
    }; // @ts-ignore


    this.setBodyHasScrollbar = function () {
      return _this.foundation.setBodyHasScrollbar(...arguments);
    };

    this.handleWheel = event => {
      const {
        scroll = {}
      } = this.props;

      if (window.navigator.userAgent.match(/Trident\/7\./) && scroll.y) {
        event.preventDefault();
        const wd = event.deltaY;
        const {
          target
        } = event; // const { bodyTable, fixedColumnsBodyLeft, fixedColumnsBodyRight } = this;

        const bodyTable = this.bodyWrapRef.current;
        let scrollTop = 0;

        if (this.lastScrollTop) {
          scrollTop = this.lastScrollTop + wd;
        } else {
          scrollTop = wd;
        }

        if (bodyTable && target !== bodyTable) {
          bodyTable.scrollTop = scrollTop;
        }
      }
    };

    this.handleBodyScrollLeft = e => {
      if (e.currentTarget !== e.target) {
        return;
      }

      const {
        target
      } = e; // const { headTable, bodyTable } = this;

      const headTable = this.headerWrapRef.current;
      const bodyTable = this.bodyWrapRef.current;

      if (target.scrollLeft !== this.lastScrollLeft) {
        if (target === bodyTable && headTable) {
          headTable.scrollLeft = target.scrollLeft;
        } else if (target === headTable && bodyTable) {
          bodyTable.scrollLeft = target.scrollLeft;
        }

        this.setScrollPositionClassName();
      } // Remember last scrollLeft for scroll direction detecting.


      this.lastScrollLeft = target.scrollLeft;
    };

    this.handleWindowResize = () => {
      this.syncTableWidth();
      this.setScrollPositionClassName();
    };

    this.handleBodyScrollTop = e => {
      const {
        target
      } = e;

      if (e.currentTarget !== target) {
        return;
      }

      const {
        scroll = {}
      } = this.props; // const { headTable, bodyTable, fixedColumnsBodyLeft, fixedColumnsBodyRight } = this;

      const headTable = this.headerWrapRef.current;
      const bodyTable = this.bodyWrapRef.current;

      if (target.scrollTop !== this.lastScrollTop && scroll.y && target !== headTable) {
        const {
          scrollTop
        } = target;

        if (bodyTable && target !== bodyTable) {
          bodyTable.scrollTop = scrollTop;
        }
      } // Remember last scrollTop for scroll direction detecting.


      this.lastScrollTop = target.scrollTop;
    };

    this.handleBodyScroll = e => {
      this.handleBodyScrollLeft(e);
      this.handleBodyScrollTop(e);
    };

    this.setScrollPosition = position => {
      const {
        prefixCls
      } = this.props;
      const positionAll = ["".concat(prefixCls, "-scroll-position-both"), "".concat(prefixCls, "-scroll-position-middle"), "".concat(prefixCls, "-scroll-position-left"), "".concat(prefixCls, "-scroll-position-right")];
      this.scrollPosition = position;
      const tableNode = this.wrapRef.current;

      if (tableNode && tableNode.nodeType) {
        if (position === 'both') {
          const acceptPosition = ["".concat(prefixCls, "-scroll-position-left"), "".concat(prefixCls, "-scroll-position-right")];
          tableNode.classList.remove(..._difference(positionAll, acceptPosition));
          tableNode.classList.add(...acceptPosition);
        } else {
          var _context2;

          const acceptPosition = [_concatInstanceProperty(_context2 = "".concat(prefixCls, "-scroll-position-")).call(_context2, position)];
          tableNode.classList.remove(..._difference(positionAll, acceptPosition));
          tableNode.classList.add(...acceptPosition);
        }
      }
    };

    this.setScrollPositionClassName = () => {
      const node = this.bodyWrapRef.current;

      if (node && node.children && node.children.length) {
        const scrollToLeft = node.scrollLeft === 0;
        const scrollToRight = node.scrollLeft + 1 >= node.children[0].getBoundingClientRect().width - node.getBoundingClientRect().width;

        if (scrollToLeft && scrollToRight) {
          this.setScrollPosition('both');
        } else if (scrollToLeft) {
          this.setScrollPosition('left');
        } else if (scrollToRight) {
          this.setScrollPosition('right');
        } else if (this.scrollPosition !== 'middle') {
          this.setScrollPosition('middle');
        }
      }
    };

    this.syncTableWidth = () => {
      if (this.rootWrapRef && this.rootWrapRef.current) {
        this.setState({
          tableWidth: this.rootWrapRef.current.getBoundingClientRect().width
        });
      }
    };

    this.renderSelection = function () {
      let record = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let inHeader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      const {
        rowSelection,
        disabledRowKeysSet
      } = _this.state;

      if (rowSelection && typeof rowSelection === 'object') {
        const {
          selectedRowKeys = [],
          selectedRowKeysSet = new _Set(),
          getCheckboxProps,
          disabled
        } = rowSelection;

        if (inHeader) {
          const columnKey = _get(rowSelection, 'key', strings.DEFAULT_KEY_COLUMN_SELECTION);

          const allRowKeys = _this.cachedFilteredSortedRowKeys;
          const allRowKeysSet = _this.cachedFilteredSortedRowKeysSet;

          const allIsSelected = _this.foundation.allIsSelected(selectedRowKeysSet, disabledRowKeysSet, allRowKeys);

          const hasRowSelected = _this.foundation.hasRowSelected(selectedRowKeys, allRowKeysSet);

          return /*#__PURE__*/React.createElement(ColumnSelection, {
            "aria-label": "".concat(allIsSelected ? 'Deselect' : 'Select', " all rows"),
            disabled: disabled,
            key: columnKey,
            selected: allIsSelected,
            indeterminate: hasRowSelected && !allIsSelected,
            onChange: (status, e) => {
              _this.toggleSelectAllRow(status, e);
            }
          });
        } else {
          const key = _this.foundation.getRecordKey(record);

          const selected = selectedRowKeysSet.has(key);

          const checkboxPropsFn = () => typeof getCheckboxProps === 'function' ? getCheckboxProps(record) : {};

          return /*#__PURE__*/React.createElement(ColumnSelection, {
            "aria-label": "".concat(selected ? 'Deselect' : 'Select', " this row"),
            getCheckboxProps: checkboxPropsFn,
            selected: selected,
            onChange: (status, e) => _this.toggleSelectRow(status, key, e)
          });
        }
      }

      return null;
    };

    this.renderRowSelectionCallback = function (text) {
      let record = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return _this.renderSelection(record);
    };

    this.renderTitleSelectionCallback = () => this.renderSelection(null, true);

    this.normalizeSelectionColumn = function () {
      let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const {
        rowSelection,
        prefixCls
      } = props;
      let column = {};

      if (rowSelection) {
        const needOmitSelectionKey = ['selectedRowKeys', 'selectedRowKeysSet'];
        column = {
          key: strings.DEFAULT_KEY_COLUMN_SELECTION
        };

        if (_isObject(rowSelection)) {
          column = _Object$assign(_Object$assign({}, column), _omit(rowSelection, needOmitSelectionKey));
        }

        column.className = classnames(column.className, "".concat(prefixCls, "-column-selection"));
        column.title = _this.renderTitleSelectionCallback;
        column.render = _this.renderRowSelectionCallback;
      }

      return column;
    }; // If there is a scroll bar, manually construct a column and insert it into the header


    this.normalizeScrollbarColumn = function () {
      let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const {
        scrollbarWidth = 0
      } = props;
      return {
        key: strings.DEFAULT_KEY_COLUMN_SCROLLBAR,
        width: scrollbarWidth,
        fixed: 'right'
      };
    };
    /**
     * render expand icon
     * @param {Object} record
     * @param {Boolean} isNested
     * @param {String} groupKey
     * @returns {ReactNode}
     */


    this.renderExpandIcon = function () {
      let record = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let isNested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      let groupKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      const {
        expandedRowKeys
      } = _this.state;
      const {
        expandIcon
      } = _this.props;
      const key = typeof groupKey === 'string' || typeof groupKey === 'number' ? groupKey : _this.foundation.getRecordKey(record);
      return /*#__PURE__*/React.createElement(ExpandedIcon, {
        key: key,
        componentType: isNested ? 'tree' : 'expand',
        expanded: _includes(expandedRowKeys, key),
        expandIcon: expandIcon,
        onClick: (expanded, e) => _this.handleRowExpanded(expanded, key, e)
      });
    }; // @ts-ignore


    this.handleRowExpanded = function () {
      return _this.foundation.handleRowExpanded(...arguments);
    };

    this.normalizeExpandColumn = function () {
      let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let column = null;
      const {
        prefixCls,
        expandCellFixed,
        expandIcon
      } = props;
      column = {
        fixed: expandCellFixed,
        key: strings.DEFAULT_KEY_COLUMN_EXPAND
      };
      column.className = classnames(column.className, "".concat(prefixCls, "-column-expand"));
      column.render = expandIcon !== false ? function () {
        let text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        let record = arguments.length > 1 ? arguments[1] : undefined;
        let index = arguments.length > 2 ? arguments[2] : undefined;
        return _this.adapter.mergedRowExpandable(record) ? _this.renderExpandIcon(record) : null;
      } : () => null;
      return column;
    };
    /**
      * Add sorting, filtering, and rendering functions to columns, and add column event handling
      * Title support function, passing parameters as {filter: node, sorter: node, selection: node}
      * @param {*} column
      */


    this.addFnsInColumn = function () {
      let column = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (column && (column.sorter || column.filters || column.useFullRender)) {
        const {
          dataIndex,
          title: rawTitle,
          useFullRender
        } = column;

        const curQuery = _this.foundation.getQuery(dataIndex);

        const titleMap = {};
        const titleArr = []; // useFullRender adds select buttons to each column

        if (useFullRender) {
          titleMap.selection = _this.renderSelection(null, true);
        }

        const stateSortOrder = _get(curQuery, 'sortOrder');

        const defaultSortOrder = _get(curQuery, 'defaultSortOrder', false);

        const sortOrder = _this.foundation.isSortOrderValid(stateSortOrder) ? stateSortOrder : defaultSortOrder;

        if (typeof column.sorter === 'function' || column.sorter === true) {
          const sorter = /*#__PURE__*/React.createElement(ColumnSorter, {
            key: strings.DEFAULT_KEY_COLUMN_SORTER,
            sortOrder: sortOrder,
            onClick: e => _this.foundation.handleSort(column, e)
          });
          useFullRender && (titleMap.sorter = sorter);
          titleArr.push(sorter);
        }

        const stateFilteredValue = _get(curQuery, 'filteredValue');

        const defaultFilteredValue = _get(curQuery, 'defaultFilteredValue');

        const filteredValue = stateFilteredValue ? stateFilteredValue : defaultFilteredValue;

        if (_Array$isArray(column.filters) && column.filters.length || /*#__PURE__*/isValidElement(column.filterDropdown)) {
          const filter = /*#__PURE__*/React.createElement(ColumnFilter, _Object$assign({
            key: strings.DEFAULT_KEY_COLUMN_FILTER
          }, curQuery, {
            filteredValue: filteredValue,
            onFilterDropdownVisibleChange: visible => _this.foundation.toggleShowFilter(dataIndex, visible),
            onSelect: data => _this.foundation.handleFilterSelect(dataIndex, data)
          }));
          useFullRender && (titleMap.filter = filter);
          titleArr.push(filter);
        }

        const newTitle = typeof rawTitle === 'function' ? () => rawTitle(titleMap) : titleArr.unshift( /*#__PURE__*/React.createElement(React.Fragment, {
          key: strings.DEFAULT_KEY_COLUMN_TITLE
        }, rawTitle)) && titleArr;
        column = _Object$assign(_Object$assign({}, column), {
          title: newTitle
        });
      }

      return column;
    };

    this.toggleSelectRow = (selected, realKey, e) => {
      this.foundation.handleSelectRow(realKey, selected, e);
    };

    this.toggleSelectAllRow = (status, e) => {
      this.foundation.handleSelectAllRow(status, e);
    };
    /**
     * render pagination
     * @param {object} pagination
     * @param {object} propRenderPagination
     */


    this.renderPagination = (pagination, propRenderPagination) => {
      if (!pagination) {
        return null;
      } // use memoized pagination


      const mergedPagination = this.foundation.memoizedPagination(pagination);
      return /*#__PURE__*/React.createElement(LocaleConsumer, {
        componentName: "Table"
      }, locale => {
        const info = this.foundation.formatPaginationInfo(mergedPagination, locale.pageText);
        return /*#__PURE__*/React.createElement(TablePagination, {
          info: info,
          pagination: mergedPagination,
          renderPagination: propRenderPagination
        });
      });
    };

    this.renderTitle = function () {
      let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let {
        title
      } = props;
      const {
        prefixCls,
        dataSource
      } = props;

      if (typeof title === 'function') {
        title = title(dataSource);
      }

      return /*#__PURE__*/isValidElement(title) || typeof title === 'string' ? /*#__PURE__*/React.createElement("div", {
        className: "".concat(prefixCls, "-title"),
        "x-semi-prop": "title"
      }, title) : null;
    };

    this.renderEmpty = function () {
      let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const {
        prefixCls,
        empty,
        dataSource
      } = props;
      const wrapCls = "".concat(prefixCls, "-placeholder");

      const isEmpty = _this.foundation.isEmpty(dataSource);

      if (!isEmpty) {
        return null;
      }

      return /*#__PURE__*/React.createElement(LocaleConsumer, {
        componentName: "Table",
        key: 'emptyText'
      }, (locale, localeCode) => /*#__PURE__*/React.createElement("div", {
        className: wrapCls
      }, /*#__PURE__*/React.createElement("div", {
        className: "".concat(prefixCls, "-empty"),
        "x-semi-prop": "empty"
      }, empty || locale.emptyText)));
    };

    this.renderFooter = function () {
      let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let {
        footer
      } = props;
      const {
        prefixCls,
        dataSource
      } = props;

      if (typeof footer === 'function') {
        footer = footer(dataSource);
      }

      return /*#__PURE__*/isValidElement(footer) || typeof footer === 'string' ? /*#__PURE__*/React.createElement("div", {
        className: "".concat(prefixCls, "-footer"),
        key: "footer",
        "x-semi-prop": "footer"
      }, footer) : null;
    };

    this.renderMainTable = props => {
      const useFixedHeader = this.adapter.useFixedHeader();
      const emptySlot = this.renderEmpty(props);
      const table = [this.renderTable(_Object$assign(_Object$assign({}, props), {
        fixed: false,
        useFixedHeader,
        headerRef: this._cacheHeaderRef,
        bodyRef: this.bodyWrapRef,
        includeHeader: !useFixedHeader
      })), emptySlot, this.renderFooter(props)];
      return table;
    };

    this.renderTable = props => {
      const {
        columns,
        filteredColumns,
        fixed,
        useFixedHeader,
        scroll,
        prefixCls,
        anyColumnFixed,
        includeHeader,
        showHeader,
        components,
        headerRef,
        bodyRef,
        onHeaderRow,
        rowSelection,
        dataSource,
        bodyHasScrollBar,
        disabledRowKeysSet
      } = props;

      const selectedRowKeysSet = _get(rowSelection, 'selectedRowKeysSet', new _Set());

      const headTable = fixed || useFixedHeader ? /*#__PURE__*/React.createElement(HeadTable, {
        key: "head",
        anyColumnFixed: anyColumnFixed,
        ref: headerRef,
        columns: filteredColumns,
        prefixCls: prefixCls,
        fixed: fixed,
        handleBodyScroll: this.handleBodyScrollLeft,
        components: components,
        scroll: scroll,
        showHeader: showHeader,
        selectedRowKeysSet: selectedRowKeysSet,
        onHeaderRow: onHeaderRow,
        dataSource: dataSource,
        bodyHasScrollBar: bodyHasScrollBar
      }) : null;
      const bodyTable = /*#__PURE__*/React.createElement(BodyTable, _Object$assign({}, _omit(props, ['rowSelection', 'headWidths']), {
        key: "body",
        ref: bodyRef,
        columns: filteredColumns,
        fixed: fixed,
        prefixCls: prefixCls,
        handleWheel: this.handleWheel,
        handleBodyScroll: this.handleBodyScroll,
        anyColumnFixed: anyColumnFixed,
        includeHeader: includeHeader,
        showHeader: showHeader,
        scroll: scroll,
        components: components,
        store: this.store,
        selectedRowKeysSet: selectedRowKeysSet,
        disabledRowKeysSet: disabledRowKeysSet
      }));
      return [headTable, bodyTable];
    };
    /**
     * When columns change, call this function to get the latest withFnsColumns
     * In addition to changes in columns, these props changes must be recalculated
     *  - hideExpandedColumn
     *  -rowSelection changes from trusy to falsy or rowSelection.hidden changes
     *  -isAnyFixedRight(columns) || get(scroll,'y') changes
     *
     * columns变化时，调用此函数获取最新的withFnsColumns
     * 除了 columns 变化，这些 props 变化也要重新计算
     *  - hideExpandedColumn
     *  - rowSelection 从 trusy 变为 falsy 或 rowSelection.hidden 发生变化
     *  - isAnyFixedRight(columns) || get(scroll, 'y') 发生变化
     *
     * @param {Array} queries
     * @param {Array} cachedColumns
     * @returns columns after adding extended functions
     */


    this.handleColumns = (queries, cachedColumns) => {
      const {
        hideExpandedColumn,
        scroll,
        prefixCls,
        expandCellFixed,
        expandIcon,
        rowSelection
      } = this.props;
      const childrenColumnName = 'children';
      let columns = cloneDeep(cachedColumns); // eslint-disable-next-line @typescript-eslint/no-shadow

      const addFns = function () {
        let columns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        if (_Array$isArray(columns) && columns.length) {
          _each(columns, (column, index, originColumns) => {
            const newColumn = _this.addFnsInColumn(column);

            const children = column[childrenColumnName];

            if (_Array$isArray(children) && children.length) {
              const newChildren = [...children];
              addFns(newChildren);
              newColumn[childrenColumnName] = newChildren;
            }

            originColumns[index] = newColumn;
          });
        }
      };

      addFns(columns); // hideExpandedColumn=false render expand column separately

      if (!hideExpandedColumn) {
        const column = this.normalizeExpandColumn({
          prefixCls,
          expandCellFixed,
          expandIcon
        });

        const destIndex = _findIndex(columns, item => item.key === strings.DEFAULT_KEY_COLUMN_EXPAND);

        if (column) {
          if (destIndex > -1) {
            columns[destIndex] = _Object$assign(_Object$assign({}, column), columns[destIndex]);
          } else if (column.fixed === 'right') {
            columns = [...columns, column];
          } else {
            columns = [column, ...columns];
          }
        }
      } // selection column


      if (rowSelection && !_get(rowSelection, 'hidden')) {
        const destIndex = _findIndex(columns, item => item.key === strings.DEFAULT_KEY_COLUMN_SELECTION);

        const column = this.normalizeSelectionColumn({
          rowSelection,
          prefixCls
        });

        if (destIndex > -1) {
          columns[destIndex] = _Object$assign(_Object$assign({}, column), columns[destIndex]);
        } else if (column.fixed === 'right') {
          columns = [...columns, column];
        } else {
          columns = [column, ...columns];
        }
      }

      assignColumnKeys(columns);
      return columns;
    };
    /**
     * Convert children to columns object
     * @param {Array} columns
     * @param {ReactNode} children
     * @returns {Array}
     */


    this.normalizeColumns = (columns, children) => {
      const normalColumns = cloneDeep(this.getColumns(columns, children));
      return normalColumns;
    };
    /**
     * Combine pagination and table paging processing functions
     */


    this.mergePagination = pagination => {
      const newPagination = _Object$assign({
        onChange: this.foundation.setPage
      }, pagination);

      return newPagination;
    };

    this.foundation = new TableFoundation(this.adapter); // columns cannot be deepClone, otherwise the comparison will be false

    const columns = this.getColumns(props.columns, props.children);
    const cachedflattenColumns = flattenColumns(columns);
    this.state = {
      /**
       * Cached props
       */
      cachedColumns: columns,
      cachedChildren: props.children,
      flattenColumns: cachedflattenColumns,
      components: mergeComponents(props.components, props.virtualized),

      /**
       * State calculated based on prop
       */
      queries: cloneDeep(cachedflattenColumns),
      dataSource: [],
      flattenData: [],
      expandedRowKeys: [...(props.expandedRowKeys || []), ...(props.defaultExpandedRowKeys || [])],
      rowSelection: props.rowSelection ? _isObject(props.rowSelection) ? _Object$assign({}, props.rowSelection) : {} : null,
      pagination: props.pagination && typeof props.pagination === 'object' ? _Object$assign({}, props.pagination) : props.pagination || false,

      /**
       * Internal state
       */
      groups: null,
      allRowKeys: [],
      disabledRowKeys: [],
      disabledRowKeysSet: new _Set(),
      headWidths: [],
      bodyHasScrollBar: false,
      prePropRowSelection: undefined,
      prePagination: undefined
    };
    this.rootWrapRef = /*#__PURE__*/createRef();
    this.wrapRef = /*#__PURE__*/createRef(); // table's outside wrap

    this.bodyWrapRef = /*#__PURE__*/createRef();
    this.headerWrapRef = /*#__PURE__*/createRef();
    this.store = new Store({
      hoveredRowKey: null
    });
    this.setScrollPosition('left');
    this.debouncedWindowResize = _debounce(this.handleWindowResize, 150);
    this.cachedFilteredSortedDataSource = [];
    this.cachedFilteredSortedRowKeys = [];
    this.cachedFilteredSortedRowKeysSet = new _Set();
  }

  get adapter() {
    var _this2 = this;

    return _Object$assign(_Object$assign({}, super.adapter), {
      resetScrollY: () => {
        if (this.bodyWrapRef.current) {
          this.bodyWrapRef.current.scrollTop = 0;
        }
      },
      setSelectedRowKeys: selectedRowKeys => {
        this.setState({
          rowSelection: _Object$assign(_Object$assign({}, this.state.rowSelection), {
            selectedRowKeys: [...selectedRowKeys],
            selectedRowKeysSet: new _Set(selectedRowKeys)
          })
        });
      },
      setDisabledRowKeys: disabledRowKeys => {
        this.setState({
          disabledRowKeys,
          disabledRowKeysSet: new _Set(disabledRowKeys)
        });
      },
      setCurrentPage: currentPage => {
        const {
          pagination
        } = this.state;

        if (typeof pagination === 'object') {
          this.setState({
            pagination: _Object$assign(_Object$assign({}, pagination), {
              currentPage
            })
          });
        } else {
          this.setState({
            pagination: {
              currentPage
            }
          });
        }
      },
      setPagination: pagination => this.setState({
        pagination
      }),
      setGroups: groups => this.setState({
        groups
      }),
      setDataSource: dataSource => this.setState({
        dataSource
      }),
      setExpandedRowKeys: expandedRowKeys => this.setState({
        expandedRowKeys: [...expandedRowKeys]
      }),
      setQuery: function () {
        let query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        let queries = [..._this2.state.queries];
        queries = mergeQueries(query, queries);

        _this2.setState({
          queries
        });
      },
      // Update queries when filtering or sorting
      setQueries: queries => this.setState({
        queries
      }),
      setFlattenData: flattenData => this.setState({
        flattenData
      }),
      setAllRowKeys: allRowKeys => this.setState({
        allRowKeys
      }),
      setHoveredRowKey: hoveredRowKey => {
        this.store.setState({
          hoveredRowKey
        });
      },
      setCachedFilteredSortedDataSource: filteredSortedDataSource => {
        this.cachedFilteredSortedDataSource = filteredSortedDataSource;
      },
      setCachedFilteredSortedRowKeys: filteredSortedRowKeys => {
        this.cachedFilteredSortedRowKeys = filteredSortedRowKeys;
        this.cachedFilteredSortedRowKeysSet = new _Set(filteredSortedRowKeys);
      },
      getCurrentPage: () => _get(this.state, 'pagination.currentPage', 1),
      getCurrentPageSize: () => _get(this.state, 'pagination.pageSize', numbers.DEFAULT_PAGE_SIZE),
      getCachedFilteredSortedDataSource: () => this.cachedFilteredSortedDataSource,
      getCachedFilteredSortedRowKeys: () => this.cachedFilteredSortedRowKeys,
      getCachedFilteredSortedRowKeysSet: () => this.cachedFilteredSortedRowKeysSet,
      notifyFilterDropdownVisibleChange: (visible, dataIndex) => this._invokeColumnFn(dataIndex, 'onFilterDropdownVisibleChange', visible),
      notifyChange: function () {
        return _this2.props.onChange(...arguments);
      },
      notifyExpand: function () {
        return _this2.props.onExpand(...arguments);
      },
      notifyExpandedRowsChange: function () {
        return _this2.props.onExpandedRowsChange(...arguments);
      },
      notifySelect: function () {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return _this2._invokeRowSelection('onSelect', ...args);
      },
      notifySelectAll: function () {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return _this2._invokeRowSelection('onSelectAll', ...args);
      },
      notifySelectInvert: function () {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        return _this2._invokeRowSelection('onSelectInvert', ...args);
      },
      notifySelectionChange: function () {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }

        return _this2._invokeRowSelection('onChange', ...args);
      },
      isAnyColumnFixed: columns => _some(this.getColumns(columns || this.props.columns, this.props.children), column => Boolean(column.fixed)),
      useFixedHeader: () => {
        const {
          scroll
        } = this.props;

        if (_get(scroll, 'y')) {
          return true;
        }

        return false;
      },
      setHeadWidths: function (headWidths) {
        let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (!equalWith(_this2.state.headWidths[index], headWidths)) {
          // The map call depends on the last state
          _this2.setState(state => {
            const newHeadWidths = [...state.headWidths];
            newHeadWidths[index] = [...headWidths];
            return {
              headWidths: newHeadWidths
            };
          });
        }
      },
      getHeadWidths: function () {
        let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        if (_this2.state.headWidths.length && typeof index === 'number') {
          const configs = _this2.state.headWidths[index] || [];
          return _mapInstanceProperty(configs).call(configs, item => item.width);
        }

        return [];
      },
      // This method is called by row rendering function
      getCellWidths: function (flattenedColumns) {
        let flattenedWidths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        let ignoreScrollBarKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (_Array$isArray(flattenedColumns) && flattenedColumns.length) {
          flattenedWidths = flattenedWidths == null && _this2.state.headWidths.length ? _flattenDeep(_this2.state.headWidths) : [];

          if (_Array$isArray(flattenedWidths) && flattenedWidths.length) {
            return _reduceInstanceProperty(flattenedColumns).call(flattenedColumns, (result, column) => {
              const found = column.key === strings.DEFAULT_KEY_COLUMN_SCROLLBAR && ignoreScrollBarKey ? null : _find(flattenedWidths, item => item && item.key != null && item.key === column.key);

              if (found) {
                result.push(found.width);
              }

              return result;
            }, []);
          }
        }

        return [];
      },
      mergedRowExpandable: record => {
        const {
          expandedRowRender,
          childrenRecordName,
          rowExpandable
        } = this.props;

        const children = _get(record, childrenRecordName);

        const hasExpandedRowRender = typeof expandedRowRender === 'function';
        const hasRowExpandable = typeof rowExpandable === 'function';
        const hasChildren = _Array$isArray(children) && children.length;
        const strictExpandableResult = hasRowExpandable && rowExpandable(record);
        const looseExpandableResult = !hasRowExpandable || strictExpandableResult;
        return (hasExpandedRowRender || hasChildren) && looseExpandableResult || !(hasExpandedRowRender || hasChildren) && strictExpandableResult;
      },
      isAnyColumnUseFullRender: columns => _some(columns, column => Boolean(column.useFullRender)),
      getNormalizeColumns: () => this.normalizeColumns,
      getHandleColumns: () => this.handleColumns,
      getMergePagination: () => this.mergePagination,
      setBodyHasScrollbar: bodyHasScrollBar => {
        if (bodyHasScrollBar !== this.state.bodyHasScrollBar) {
          this.setState({
            bodyHasScrollBar
          });
        }
      }
    });
  }

  static getDerivedStateFromProps(props, state) {
    const willUpdateStates = {};
    const {
      rowSelection,
      dataSource,
      childrenRecordName,
      rowKey,
      pagination
    } = props;
    props.columns && props.children && logger.warn('columns should not given by object and children at the same time');

    if (props.columns && props.columns !== state.cachedColumns) {
      const newFlattenColumns = flattenColumns(props.columns);
      willUpdateStates.flattenColumns = newFlattenColumns;
      willUpdateStates.queries = mergeColumns(state.queries, newFlattenColumns, null, false);
      willUpdateStates.cachedColumns = props.columns;
      willUpdateStates.cachedChildren = null;
    } else if (props.children && props.children !== state.cachedChildren) {
      const newNestedColumns = getColumns(props.children);
      const newFlattenColumns = flattenColumns(newNestedColumns);
      const columns = mergeColumns(state.queries, newFlattenColumns, null, false);
      willUpdateStates.flattenColumns = newFlattenColumns;
      willUpdateStates.queries = [...columns];
      willUpdateStates.cachedColumns = [...newNestedColumns];
      willUpdateStates.cachedChildren = props.children;
    } // Update controlled selection column


    if (rowSelection !== state.prePropRowSelection) {
      let newSelectionStates = {};

      if (_isObject(state.rowSelection)) {
        newSelectionStates = _Object$assign(_Object$assign({}, newSelectionStates), state.rowSelection);
      }

      if (_isObject(rowSelection)) {
        newSelectionStates = _Object$assign(_Object$assign({}, newSelectionStates), rowSelection);
      }

      const selectedRowKeys = _get(rowSelection, 'selectedRowKeys');

      const getCheckboxProps = _get(rowSelection, 'getCheckboxProps');

      if (selectedRowKeys && _Array$isArray(selectedRowKeys)) {
        newSelectionStates.selectedRowKeysSet = new _Set(selectedRowKeys);
      } // The return value of getCheckboxProps affects the disabled rows


      if (_isFunction(getCheckboxProps)) {
        const disabledRowKeys = getAllDisabledRowKeys({
          dataSource,
          getCheckboxProps,
          childrenRecordName,
          rowKey
        });
        willUpdateStates.disabledRowKeys = disabledRowKeys;
        willUpdateStates.disabledRowKeysSet = new _Set(disabledRowKeys);
      }

      willUpdateStates.rowSelection = newSelectionStates;
      willUpdateStates.prePropRowSelection = rowSelection;
    }

    if (pagination !== state.prePagination) {
      let newPagination = {};

      if (_isObject(state.pagination)) {
        newPagination = _Object$assign(_Object$assign({}, newPagination), state.pagination);
      }

      if (_isObject(pagination)) {
        newPagination = _Object$assign(_Object$assign({}, newPagination), pagination);
      }

      willUpdateStates.pagination = newPagination;
      willUpdateStates.prePagination = pagination;
    }

    return willUpdateStates;
  }

  componentDidMount() {
    super.componentDidMount();

    if (this.adapter.isAnyColumnFixed() || this.props.showHeader && this.adapter.useFixedHeader()) {
      this.handleWindowResize();
      window.addEventListener('resize', this.debouncedWindowResize);
    }
  } // TODO: Extract the setState operation to the adapter or getDerivedStateFromProps function


  componentDidUpdate(prevProps, prevState) {
    const {
      dataSource,
      expandedRowKeys,
      expandAllRows,
      expandAllGroupRows,
      virtualized,
      components,
      pagination: propsPagination
    } = this.props;
    const {
      pagination: statePagination,
      queries: stateQueries,
      cachedColumns: stateCachedColumns,
      cachedChildren: stateCachedChildren,
      groups: stateGroups
    } = this.state;
    /**
     * State related to paging
     *
     * @param dataSource
     * @param groups
     * @param pagination
     * @param disabledRowKeys
     * @param allRowKeys
     * @param queries
     */

    const states = {};

    this._warnIfNoKey();
    /**
     * The state that needs to be updated after props changes
     */
    // Update controlled expand column


    if (_Array$isArray(expandedRowKeys) && expandedRowKeys !== prevProps.expandedRowKeys) {
      this.setState({
        expandedRowKeys
      });
    } // Update components


    if (components !== prevProps.components || virtualized !== prevProps.virtualized) {
      this.setState({
        components: mergeComponents(components, virtualized)
      });
    } // Update the default expanded column


    if (expandAllRows !== prevProps.expandAllRows || expandAllGroupRows !== prevProps.expandAllGroupRows) {
      this.foundation.initExpandedRowKeys({
        groups: stateGroups
      });
    }
    /**
     * After dataSource is updated || (cachedColumns || cachedChildren updated)
     * 1. Cache filtered sorted data and a collection of data rows, stored in this
     * 2. Update pager and group, stored in state
     */


    if (dataSource !== prevProps.dataSource || stateCachedColumns !== prevState.cachedColumns || stateCachedChildren !== prevState.cachedChildren) {
      // TODO: foundation.getFilteredSortedDataSource has side effects and will be modified to the dataSource reference
      // Temporarily use _dataSource=[...dataSource] for processing
      const _dataSource = [...dataSource];
      const filteredSortedDataSource = this.foundation.getFilteredSortedDataSource(_dataSource, stateQueries);
      this.foundation.setCachedFilteredSortedDataSource(filteredSortedDataSource);
      states.dataSource = filteredSortedDataSource;

      if (this.props.groupBy) {
        states.groups = null;
      }
    } // when dataSource has change, should reset currentPage


    if (dataSource !== prevProps.dataSource) {
      states.pagination = _isObject(statePagination) ? _Object$assign(_Object$assign({}, statePagination), {
        currentPage: _isObject(propsPagination) && propsPagination.currentPage ? propsPagination.currentPage : 1
      }) : statePagination;
    }

    if (_Object$keys(states).length) {
      const {
        // eslint-disable-next-line @typescript-eslint/no-shadow
        pagination: mergedStatePagination = null,
        queries: stateQueries = null,
        dataSource: stateDataSource = null
      } = states;
      const handledProps = this.foundation.getCurrentPageData(stateDataSource, mergedStatePagination, stateQueries); // After the pager is updated, reset allRowKeys of the current page

      this.adapter.setAllRowKeys(handledProps.allRowKeys);
      this.adapter.setDisabledRowKeys(handledProps.disabledRowKeys);

      if ('dataSource' in states) {
        if (this.props.defaultExpandAllRows && handledProps.groups && handledProps.groups.size || this.props.expandAllRows || this.props.expandAllGroupRows) {
          this.foundation.initExpandedRowKeys(handledProps);
        }
      } // Centrally update paging related state


      const statesKeys = _Object$keys(states);

      for (const k of statesKeys) {
        this.setState({
          [k]: handledProps[k]
        });
      }
    }

    if (this.adapter.isAnyColumnFixed() || this.props.showHeader && this.adapter.useFixedHeader()) {
      if (!this.debouncedWindowResize) {
        window.addEventListener('resize', this.debouncedWindowResize);
      }
    }
  }

  componentWillUnmount() {
    super.componentWillUnmount();

    if (this.debouncedWindowResize) {
      window.removeEventListener('resize', this.debouncedWindowResize);
      this.debouncedWindowResize.cancel();
      this.debouncedWindowResize = null;
    }
  }

  render() {
    var _context3, _context4, _context5, _context6, _context7, _context8;

    let _a = this.props,
        {
      scroll,
      prefixCls,
      className,
      style: wrapStyle = {},
      bordered,
      id,
      pagination: propPagination,
      virtualized,
      size,
      renderPagination: propRenderPagination,
      getVirtualizedListRef,
      loading,
      hideExpandedColumn,
      rowSelection: propRowSelection
    } = _a,
        rest = __rest(_a, ["scroll", "prefixCls", "className", "style", "bordered", "id", "pagination", "virtualized", "size", "renderPagination", "getVirtualizedListRef", "loading", "hideExpandedColumn", "rowSelection"]);

    let {
      rowSelection,
      expandedRowKeys,
      headWidths,
      tableWidth,
      pagination,
      dataSource,
      queries,
      cachedColumns,
      bodyHasScrollBar
    } = this.state;
    wrapStyle = _Object$assign({}, wrapStyle);
    let columns;
    /**
      * As state.queries will change, the columns should be refreshed as a whole at this time
      * The scene of changes in queries
      * 1. Filter
      * 2. Pagination
      *
      * useFullRender needs to be passed to the user selection ReactNode, so columns need to be recalculated every time the selectedRowKeys changes
      * TODO: In the future, the selection passed to the user can be changed to the function type, allowing the user to execute the function to obtain the real-time status of the selection title
      *
      * 由于state.queries会发生变化，此时columns应该整体刷新
      * queries变化的场景
      *  1. 筛选
      *  2. 分页
      * useFullRender需要传给用户selection ReactNode，因此需要每次selectedRowKeys变化时重新计算columns
      * TODO: 未来可以将传给用户的selection改为函数类型，让用户执行函数获取selection title的实时状态
      */

    if (!this.adapter.isAnyColumnUseFullRender(queries)) {
      const rowSelectionUpdate = propRowSelection && !_get(propRowSelection, 'hidden');
      columns = this.foundation.memoizedWithFnsColumns(queries, cachedColumns, rowSelectionUpdate, hideExpandedColumn, // Update the columns after the body scrollbar changes to ensure that the head and body are aligned
      bodyHasScrollBar);
    } else {
      columns = this.handleColumns(queries, cachedColumns);
    }

    const filteredColumns = this.foundation.memoizedFilterColumns(columns);
    const flattenFnsColumns = this.foundation.memoizedFlattenFnsColumns(columns);
    const anyColumnFixed = this.adapter.isAnyColumnFixed(columns);
    /**
     * - If it is the first page break, you need to calculate the current page
     * - If it is manual paging, call foundation to modify the state
     *
     * TODO: After merging issue 1007, you can place it in the constructor to complete
     * The reason is that #1007 exposes the parameters required by getCurrentPageData in the constructor
     */

    if (_isNull(dataSource)) {
      const pageData = this.foundation.getCurrentPageData(this.props.dataSource);
      dataSource = pageData.dataSource;
      pagination = pageData.pagination;
    }

    const props = _Object$assign(_Object$assign(_Object$assign({}, rest), this.state), {
      // props not in rest
      virtualized,
      scroll,
      prefixCls,
      size,
      hideExpandedColumn,
      // renamed state
      columns,
      // calculated value
      anyColumnFixed,
      rowExpandable: this.mergedRowExpandable,
      pagination,
      dataSource,
      rowSelection,
      expandedRowKeys,
      renderExpandIcon: this.renderExpandIcon,
      filteredColumns
    });

    const x = _get(scroll, 'x');

    const y = _get(scroll, 'y');

    if (virtualized) {
      if (typeof wrapStyle.width !== 'number') {
        wrapStyle.width = x;
      }
    }

    const wrapCls = classnames({
      [_concatInstanceProperty(_context3 = "".concat(prefixCls, "-")).call(_context3, strings.SIZE_SMALL)]: size === strings.SIZE_SMALL,
      [_concatInstanceProperty(_context4 = "".concat(prefixCls, "-")).call(_context4, strings.SIZE_MIDDLE)]: size === strings.SIZE_MIDDLE,
      ["".concat(prefixCls, "-virtualized")]: Boolean(virtualized),
      ["".concat(prefixCls, "-bordered")]: bordered,
      ["".concat(prefixCls, "-fixed-header")]: Boolean(y),
      ["".concat(prefixCls, "-scroll-position-left")]: _includesInstanceProperty(_context5 = ['both', 'left']).call(_context5, this.position),
      ["".concat(prefixCls, "-scroll-position-right")]: _includesInstanceProperty(_context6 = ['both', 'right']).call(_context6, this.position)
    }); // pagination

    const tablePagination = pagination && propPagination ? this.renderPagination(pagination, propRenderPagination) : null;

    const paginationPosition = _get(propPagination, 'position', 'bottom');

    const tableContextValue = _Object$assign(_Object$assign({}, this.context), {
      headWidths,
      tableWidth,
      anyColumnFixed,
      flattenedColumns: flattenFnsColumns,
      renderExpandIcon: this.renderExpandIcon,
      renderSelection: this.renderSelection,
      setHeadWidths: this.setHeadWidths,
      getHeadWidths: this.getHeadWidths,
      getCellWidths: this.getCellWidths,
      handleRowExpanded: this.handleRowExpanded,
      getVirtualizedListRef,
      setBodyHasScrollbar: this.setBodyHasScrollbar
    });

    return /*#__PURE__*/React.createElement("div", {
      ref: this.rootWrapRef,
      className: classnames(className, "".concat(prefixCls, "-wrapper")),
      "data-column-fixed": anyColumnFixed,
      style: wrapStyle,
      id: id
    }, /*#__PURE__*/React.createElement(TableContextProvider, _Object$assign({}, tableContextValue), /*#__PURE__*/React.createElement(Spin, {
      spinning: loading,
      size: "large"
    }, /*#__PURE__*/React.createElement("div", {
      ref: this.wrapRef,
      className: wrapCls
    }, /*#__PURE__*/React.createElement(React.Fragment, {
      key: 'pagination-top'
    }, _includesInstanceProperty(_context7 = ['top', 'both']).call(_context7, paginationPosition) ? tablePagination : null), this.renderTitle({
      title: props.title,
      dataSource: props.dataSource,
      prefixCls: props.prefixCls
    }), /*#__PURE__*/React.createElement("div", {
      className: "".concat(prefixCls, "-container")
    }, this.renderMainTable(_Object$assign({}, props))), /*#__PURE__*/React.createElement(React.Fragment, {
      key: 'pagination-bottom'
    }, _includesInstanceProperty(_context8 = ['bottom', 'both']).call(_context8, paginationPosition) ? tablePagination : null)))));
  }

}

Table.contextType = TableContext;
Table.propTypes = {
  className: PropTypes.string,
  style: PropTypes.object,
  prefixCls: PropTypes.string,
  components: PropTypes.any,
  bordered: PropTypes.bool,
  loading: PropTypes.bool,
  size: PropTypes.oneOf(strings.SIZES),
  tableLayout: PropTypes.oneOf(strings.LAYOUTS),
  columns: PropTypes.arrayOf(PropTypes.shape(ColumnShape)),
  hideExpandedColumn: PropTypes.bool,
  id: PropTypes.string,
  expandIcon: PropTypes.oneOfType([PropTypes.bool, PropTypes.func, PropTypes.node]),
  expandCellFixed: PropTypes.oneOf(strings.FIXED_SET),
  title: PropTypes.oneOfType([PropTypes.string, PropTypes.node, PropTypes.func]),
  onHeaderRow: PropTypes.func,
  showHeader: PropTypes.bool,
  indentSize: PropTypes.number,
  rowKey: PropTypes.oneOfType([PropTypes.func, PropTypes.string, PropTypes.number]),
  onRow: PropTypes.func,
  onExpandedRowsChange: PropTypes.func,
  onExpand: PropTypes.func,
  rowExpandable: PropTypes.func,
  expandedRowRender: PropTypes.func,
  expandedRowKeys: PropTypes.array,
  defaultExpandAllRows: PropTypes.bool,
  expandAllRows: PropTypes.bool,
  defaultExpandAllGroupRows: PropTypes.bool,
  expandAllGroupRows: PropTypes.bool,
  defaultExpandedRowKeys: PropTypes.array,
  pagination: PropTypes.oneOfType([PropTypes.object, PropTypes.bool]),
  renderPagination: PropTypes.func,
  footer: PropTypes.oneOfType([PropTypes.func, PropTypes.string, PropTypes.node]),
  empty: PropTypes.node,
  dataSource: PropTypes.array,
  childrenRecordName: PropTypes.string,
  rowSelection: PropTypes.oneOfType([PropTypes.object, PropTypes.bool]),
  onChange: PropTypes.func,
  scroll: PropTypes.shape({
    x: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.bool]),
    y: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
  }),
  groupBy: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.func]),
  renderGroupSection: PropTypes.oneOfType([PropTypes.func]),
  onGroupedRow: PropTypes.func,
  clickGroupedRowToExpand: PropTypes.bool,
  virtualized: PropTypes.oneOfType([PropTypes.object, PropTypes.bool]),
  dropdownPrefixCls: PropTypes.string,
  expandRowByClick: PropTypes.bool,
  getVirtualizedListRef: PropTypes.func // TODO: future api

};
Table.defaultProps = {
  // rowExpandable: stubTrue,
  tableLayout: '',
  dataSource: [],
  prefixCls: cssClasses.PREFIX,
  rowSelection: null,
  className: '',
  childrenRecordName: 'children',
  size: 'default',
  loading: false,
  bordered: false,
  expandCellFixed: false,
  hideExpandedColumn: true,
  showHeader: true,
  indentSize: numbers.DEFAULT_INDENT_WIDTH,
  onChange: _noop,
  pagination: true,
  rowKey: 'key',
  defaultExpandedRowKeys: [],
  defaultExpandAllRows: false,
  defaultExpandAllGroupRows: false,
  expandAllRows: false,
  expandAllGroupRows: false,
  onFilterDropdownVisibleChange: _noop,
  onExpand: _noop,
  onExpandedRowsChange: _noop,
  expandRowByClick: false
};
export default Table;