import _isFunction from "lodash/isFunction";
import _isUndefined from "lodash/isUndefined";
import _isNull from "lodash/isNull";
import _isArray from "lodash/isArray";
import _isString from "lodash/isString";
import _noop from "lodash/noop";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _sliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/slice";
import React from 'react';
import cls from 'classnames';
import PropTypes from 'prop-types';
import { cssClasses, strings } from '@douyinfe/semi-foundation/lib/es/tagInput/constants';
import '@douyinfe/semi-foundation/lib/es/tagInput/tagInput.css';
import TagInputFoundation from '@douyinfe/semi-foundation/lib/es/tagInput/foundation';
import { isSemiIcon } from '../_utils';
import BaseComponent from '../_base/baseComponent';
import Tag from '../tag';
import Input from '../input';
import Popover from '../popover';
import Paragraph from '../typography/paragraph';
import { IconClear, IconHandle } from '@douyinfe/semi-icons';
import { SortableContainer, SortableElement, SortableHandle } from 'react-sortable-hoc';
const SortableItem = SortableElement(props => props.item);
const SortableList = SortableContainer(_ref => {
  let {
    items
  } = _ref;
  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      flexFlow: 'row wrap'
    }
  }, _mapInstanceProperty(items).call(items, (item, index) =>
  /*#__PURE__*/
  // @ts-ignore skip SortableItem type check
  React.createElement(SortableItem, {
    key: item.key,
    index: index,
    item: item.item
  })));
});
const prefixCls = cssClasses.PREFIX;

class TagInput extends BaseComponent {
  constructor(props) {
    super(props);

    this.handleInputChange = e => {
      this.foundation.handleInputChange(e);
    };

    this.handleKeyDown = e => {
      this.foundation.handleKeyDown(e);
    };

    this.handleInputFocus = e => {
      this.foundation.handleInputFocus(e);
    };

    this.handleInputBlur = e => {
      this.foundation.handleInputBlur(e);
    };

    this.handleClearBtn = e => {
      this.foundation.handleClearBtn(e);
    };
    /* istanbul ignore next */


    this.handleClearEnterPress = e => {
      this.foundation.handleClearEnterPress(e);
    };

    this.handleTagClose = idx => {
      this.foundation.handleTagClose(idx);
    };

    this.handleInputMouseLeave = e => {
      this.foundation.handleInputMouseLeave();
    };

    this.handleClick = e => {
      this.foundation.handleClick(e);
    };

    this.handleInputMouseEnter = e => {
      this.foundation.handleInputMouseEnter();
    };

    this.handleClickPrefixOrSuffix = e => {
      this.foundation.handleClickPrefixOrSuffix(e);
    };

    this.handlePreventMouseDown = e => {
      this.foundation.handlePreventMouseDown(e);
    };

    this.getAllTags = () => {
      var _context;

      const {
        size,
        disabled,
        renderTagItem,
        showContentTooltip,
        draggable
      } = this.props;
      const {
        tagsArray,
        active
      } = this.state;
      const showIconHandler = active && draggable;
      const tagCls = cls("".concat(prefixCls, "-wrapper-tag"), {
        [_concatInstanceProperty(_context = "".concat(prefixCls, "-wrapper-tag-size-")).call(_context, size)]: size,
        ["".concat(prefixCls, "-wrapper-tag-icon")]: showIconHandler
      });
      const typoCls = cls("".concat(prefixCls, "-wrapper-typo"), {
        ["".concat(prefixCls, "-wrapper-typo-disabled")]: disabled
      });
      const itemWrapperCls = cls({
        ["".concat(prefixCls, "-drag-item")]: showIconHandler,
        ["".concat(prefixCls, "-wrapper-tag-icon")]: showIconHandler
      });
      const DragHandle = SortableHandle(() => /*#__PURE__*/React.createElement(IconHandle, {
        className: "".concat(prefixCls, "-drag-handler")
      }));
      return _mapInstanceProperty(tagsArray).call(tagsArray, (value, index) => {
        var _context2;

        const elementKey = showIconHandler ? value : _concatInstanceProperty(_context2 = "".concat(index)).call(_context2, value);

        if (_isFunction(renderTagItem)) {
          return showIconHandler ? /*#__PURE__*/React.createElement("div", {
            className: itemWrapperCls,
            key: elementKey
          }, /*#__PURE__*/React.createElement(DragHandle, null), renderTagItem(value, index)) : renderTagItem(value, index);
        } else {
          var _context3;

          return /*#__PURE__*/React.createElement(Tag, {
            className: tagCls,
            color: "white",
            size: size === 'small' ? 'small' : 'large',
            type: "light",
            onClose: () => {
              !disabled && this.handleTagClose(index);
            },
            closable: !disabled,
            key: elementKey,
            visible: true,
            "aria-label": _concatInstanceProperty(_context3 = "".concat(!disabled ? 'Closable ' : '', "Tag: ")).call(_context3, value)
          }, showIconHandler && /*#__PURE__*/React.createElement(DragHandle, null), /*#__PURE__*/React.createElement(Paragraph, {
            className: typoCls,
            ellipsis: {
              showTooltip: showContentTooltip,
              rows: 1
            }
          }, value));
        }
      });
    };

    this.onSortEnd = callbackProps => {
      this.foundation.handleSortEnd(callbackProps);
    };

    this.foundation = new TagInputFoundation(this.adapter);
    this.state = {
      tagsArray: props.defaultValue || [],
      inputValue: '',
      focusing: false,
      hovering: false,
      active: false
    };
    this.inputRef = /*#__PURE__*/React.createRef();
    this.tagInputRef = /*#__PURE__*/React.createRef();
    this.clickOutsideHandler = null;
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    const {
      value,
      inputValue
    } = nextProps;
    const {
      tagsArray: prevTagsArray
    } = prevState;
    let tagsArray;

    if (_isArray(value)) {
      tagsArray = value;
    } else if ('value' in nextProps && !value) {
      tagsArray = [];
    } else {
      tagsArray = prevTagsArray;
    }

    return {
      tagsArray,
      inputValue: _isString(inputValue) ? inputValue : prevState.inputValue
    };
  }

  get adapter() {
    return _Object$assign(_Object$assign({}, super.adapter), {
      setInputValue: inputValue => {
        this.setState({
          inputValue
        });
      },
      setTagsArray: tagsArray => {
        this.setState({
          tagsArray
        });
      },
      setFocusing: focusing => {
        this.setState({
          focusing
        });
      },
      toggleFocusing: isFocus => {
        const {
          preventScroll
        } = this.props;
        const input = this.inputRef && this.inputRef.current;

        if (isFocus) {
          input && input.focus({
            preventScroll
          });
        } else {
          input && input.blur();
        }

        this.setState({
          focusing: isFocus
        });
      },
      setHovering: hovering => {
        this.setState({
          hovering
        });
      },
      setActive: active => {
        this.setState({
          active
        });
      },
      getClickOutsideHandler: () => {
        return this.clickOutsideHandler;
      },
      notifyBlur: e => {
        this.props.onBlur(e);
      },
      notifyFocus: e => {
        this.props.onFocus(e);
      },
      notifyInputChange: (v, e) => {
        this.props.onInputChange(v, e);
      },
      notifyTagChange: v => {
        this.props.onChange(v);
      },
      notifyTagAdd: v => {
        this.props.onAdd(v);
      },
      notifyTagRemove: (v, idx) => {
        this.props.onRemove(v, idx);
      },
      notifyKeyDown: e => {
        this.props.onKeyDown(e);
      },
      registerClickOutsideHandler: cb => {
        const clickOutsideHandler = e => {
          const tagInputDom = this.tagInputRef && this.tagInputRef.current;
          const target = e.target;

          if (tagInputDom && !tagInputDom.contains(target)) {
            cb(e);
          }
        };

        this.clickOutsideHandler = clickOutsideHandler;
        document.addEventListener('click', clickOutsideHandler, false);
      },
      unregisterClickOutsideHandler: () => {
        document.removeEventListener('click', this.clickOutsideHandler, false);
        this.clickOutsideHandler = null;
      }
    });
  }

  componentDidMount() {
    const {
      disabled,
      autoFocus,
      preventScroll
    } = this.props;

    if (!disabled && autoFocus) {
      this.inputRef.current.focus({
        preventScroll
      });
      this.foundation.handleClick();
    }

    this.foundation.init();
  }

  renderClearBtn() {
    const {
      hovering,
      tagsArray,
      inputValue
    } = this.state;
    const {
      showClear,
      disabled
    } = this.props;
    const clearCls = cls("".concat(prefixCls, "-clearBtn"), {
      ["".concat(prefixCls, "-clearBtn-invisible")]: !hovering || inputValue === '' && tagsArray.length === 0 || disabled
    });

    if (showClear) {
      return /*#__PURE__*/React.createElement("div", {
        role: "button",
        tabIndex: 0,
        "aria-label": "Clear TagInput value",
        className: clearCls,
        onClick: e => this.handleClearBtn(e),
        onKeyPress: e => this.handleClearEnterPress(e)
      }, /*#__PURE__*/React.createElement(IconClear, null));
    }

    return null;
  }

  renderPrefix() {
    const {
      prefix,
      insetLabel,
      insetLabelId
    } = this.props;
    const labelNode = prefix || insetLabel;

    if (_isNull(labelNode) || _isUndefined(labelNode)) {
      return null;
    }

    const prefixWrapperCls = cls("".concat(prefixCls, "-prefix"), {
      ["".concat(prefixCls, "-inset-label")]: insetLabel,
      ["".concat(prefixCls, "-prefix-text")]: labelNode && _isString(labelNode),
      // eslint-disable-next-line max-len
      ["".concat(prefixCls, "-prefix-icon")]: isSemiIcon(labelNode)
    });
    return (
      /*#__PURE__*/
      // eslint-disable-next-line jsx-a11y/no-static-element-interactions,jsx-a11y/click-events-have-key-events
      React.createElement("div", {
        className: prefixWrapperCls,
        onMouseDown: this.handlePreventMouseDown,
        onClick: this.handleClickPrefixOrSuffix,
        id: insetLabelId,
        "x-semi-prop": "prefix"
      }, labelNode)
    );
  }

  renderSuffix() {
    const {
      suffix
    } = this.props;

    if (_isNull(suffix) || _isUndefined(suffix)) {
      return null;
    }

    const suffixWrapperCls = cls("".concat(prefixCls, "-suffix"), {
      ["".concat(prefixCls, "-suffix-text")]: suffix && _isString(suffix),
      // eslint-disable-next-line max-len
      ["".concat(prefixCls, "-suffix-icon")]: isSemiIcon(suffix)
    });
    return (
      /*#__PURE__*/
      // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
      React.createElement("div", {
        className: suffixWrapperCls,
        onMouseDown: this.handlePreventMouseDown,
        onClick: this.handleClickPrefixOrSuffix,
        "x-semi-prop": "suffix"
      }, suffix)
    );
  }

  renderTags() {
    const {
      disabled,
      maxTagCount,
      showRestTagsPopover,
      restTagsPopoverProps = {},
      draggable,
      expandRestTagsOnClick
    } = this.props;
    const {
      tagsArray,
      active
    } = this.state;
    const restTagsCls = cls("".concat(prefixCls, "-wrapper-n"), {
      ["".concat(prefixCls, "-wrapper-n-disabled")]: disabled
    });
    const allTags = this.getAllTags();
    let restTags = [];
    let tags = [...allTags];

    if ((!active || !expandRestTagsOnClick) && maxTagCount && maxTagCount < allTags.length) {
      tags = _sliceInstanceProperty(allTags).call(allTags, 0, maxTagCount);
      restTags = _sliceInstanceProperty(allTags).call(allTags, maxTagCount);
    }

    const restTagsContent = /*#__PURE__*/React.createElement("span", {
      className: restTagsCls
    }, "+", tagsArray.length - maxTagCount);

    const sortableListItems = _mapInstanceProperty(allTags).call(allTags, (item, index) => ({
      item: item,
      key: tagsArray[index]
    }));

    if (active && draggable && sortableListItems.length > 0) {
      // @ts-ignore skip SortableItem type check
      return /*#__PURE__*/React.createElement(SortableList, {
        useDragHandle: true,
        items: sortableListItems,
        onSortEnd: this.onSortEnd,
        axis: "xy"
      });
    }

    return /*#__PURE__*/React.createElement(React.Fragment, null, tags, restTags.length > 0 && (showRestTagsPopover ? /*#__PURE__*/React.createElement(Popover, _Object$assign({
      content: restTags,
      showArrow: true,
      trigger: "hover",
      position: "top",
      autoAdjustOverflow: true
    }, restTagsPopoverProps), restTagsContent) : restTagsContent));
  }

  blur() {
    this.inputRef.current.blur(); // unregister clickOutside event 

    this.foundation.clickOutsideCallBack();
  }

  focus() {
    const {
      preventScroll,
      disabled
    } = this.props;
    this.inputRef.current.focus({
      preventScroll
    });

    if (!disabled) {
      // register clickOutside event 
      this.foundation.handleClick();
    }
  }

  render() {
    const {
      size,
      style,
      className,
      disabled,
      placeholder,
      validateStatus
    } = this.props;
    const {
      focusing,
      hovering,
      tagsArray,
      inputValue,
      active
    } = this.state;
    const tagInputCls = cls(prefixCls, className, {
      ["".concat(prefixCls, "-focus")]: focusing || active,
      ["".concat(prefixCls, "-disabled")]: disabled,
      ["".concat(prefixCls, "-hover")]: hovering && !disabled,
      ["".concat(prefixCls, "-error")]: validateStatus === 'error',
      ["".concat(prefixCls, "-warning")]: validateStatus === 'warning'
    });
    const inputCls = cls("".concat(prefixCls, "-wrapper-input"));
    const wrapperCls = cls("".concat(prefixCls, "-wrapper"));
    return (
      /*#__PURE__*/
      // eslint-disable-next-line 
      React.createElement("div", {
        ref: this.tagInputRef,
        style: style,
        className: tagInputCls,
        "aria-disabled": disabled,
        "aria-label": this.props['aria-label'],
        "aria-invalid": validateStatus === 'error',
        onMouseEnter: e => {
          this.handleInputMouseEnter(e);
        },
        onMouseLeave: e => {
          this.handleInputMouseLeave(e);
        },
        onClick: e => {
          this.handleClick(e);
        }
      }, this.renderPrefix(), /*#__PURE__*/React.createElement("div", {
        className: wrapperCls
      }, this.renderTags(), /*#__PURE__*/React.createElement(Input, {
        "aria-label": 'input value',
        ref: this.inputRef,
        className: inputCls,
        disabled: disabled,
        value: inputValue,
        size: size,
        placeholder: tagsArray.length === 0 ? placeholder : '',
        onKeyDown: e => {
          this.handleKeyDown(e);
        },
        onChange: (v, e) => {
          this.handleInputChange(e);
        },
        onBlur: e => {
          this.handleInputBlur(e);
        },
        onFocus: e => {
          this.handleInputFocus(e);
        }
      })), this.renderClearBtn(), this.renderSuffix())
    );
  }

}

TagInput.propTypes = {
  children: PropTypes.node,
  style: PropTypes.object,
  className: PropTypes.string,
  disabled: PropTypes.bool,
  allowDuplicates: PropTypes.bool,
  max: PropTypes.number,
  maxTagCount: PropTypes.number,
  maxLength: PropTypes.number,
  showRestTagsPopover: PropTypes.bool,
  restTagsPopoverProps: PropTypes.object,
  showContentTooltip: PropTypes.bool,
  defaultValue: PropTypes.array,
  value: PropTypes.array,
  inputValue: PropTypes.string,
  placeholder: PropTypes.string,
  separator: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  showClear: PropTypes.bool,
  addOnBlur: PropTypes.bool,
  draggable: PropTypes.bool,
  expandRestTagsOnClick: PropTypes.bool,
  autoFocus: PropTypes.bool,
  renderTagItem: PropTypes.func,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  onChange: PropTypes.func,
  onInputChange: PropTypes.func,
  onExceed: PropTypes.func,
  onInputExceed: PropTypes.func,
  onAdd: PropTypes.func,
  onRemove: PropTypes.func,
  onKeyDown: PropTypes.func,
  size: PropTypes.oneOf(strings.SIZE_SET),
  validateStatus: PropTypes.oneOf(strings.STATUS),
  prefix: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  suffix: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  'aria-label': PropTypes.string,
  preventScroll: PropTypes.bool
};
TagInput.defaultProps = {
  showClear: false,
  addOnBlur: false,
  allowDuplicates: true,
  showRestTagsPopover: true,
  autoFocus: false,
  draggable: false,
  expandRestTagsOnClick: true,
  showContentTooltip: true,
  separator: ',',
  size: 'default',
  validateStatus: 'default',
  onBlur: _noop,
  onFocus: _noop,
  onChange: _noop,
  onInputChange: _noop,
  onExceed: _noop,
  onInputExceed: _noop,
  onAdd: _noop,
  onRemove: _noop,
  onKeyDown: _noop
};
export default TagInput;