import _isObject from "lodash/isObject";
import _isNumber from "lodash/isNumber";
import _isString from "lodash/isString";
import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && _indexOfInstanceProperty(e).call(e, p) < 0) t[p] = s[p];

  if (s != null && typeof _Object$getOwnPropertySymbols === "function") for (var i = 0, p = _Object$getOwnPropertySymbols(s); i < p.length; i++) {
    if (_indexOfInstanceProperty(e).call(e, p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
/* eslint-disable max-lines-per-function, prefer-destructuring, prefer-const, @typescript-eslint/no-unused-vars */


import React, { useContext } from 'react';
import classNames from 'classnames';
import { cssClasses } from '@douyinfe/semi-foundation/lib/es/form/constants';
import Label from './label';
import { Col } from '../grid';
import { FormUpdaterContext } from './context';
import ErrorMessage from './errorMessage';
const prefix = cssClasses.PREFIX;

const FormSlot = props => {
  var _context;

  let labelCol, wrapperCol, labelWidth, labelAlign, content;
  let labelPosition = 'top';

  try {
    const updater = useContext(FormUpdaterContext);
    const formProps = updater.getFormProps(['labelPosition', 'labelWidth', 'labelAlign', 'labelCol', 'wrapperCol']);
    labelCol = formProps.labelCol;
    wrapperCol = formProps.wrapperCol;
    labelWidth = formProps.labelWidth;
    labelAlign = formProps.labelAlign;
    labelPosition = formProps.labelPosition ? formProps.labelPosition : labelPosition;
  } catch (error) {} // eslint-disable-next-line react/destructuring-assignment


  props.labelPosition ? labelPosition = props.labelPosition : null;

  let {
    children,
    label,
    className,
    style,
    error,
    noLabel
  } = props,
      rest = __rest(props, ["children", "label", "className", "style", "error", "noLabel"]);

  const appendCol = labelCol && wrapperCol;
  const slotCls = classNames({
    ["".concat(prefix, "-field")]: true,
    ["".concat(prefix, "-slot")]: true
  }, className);
  const labelColCls = classNames({
    [_concatInstanceProperty(_context = "".concat(prefix, "-col-")).call(_context, labelAlign)]: true
  });

  switch (true) {
    case _isObject(label) && ! /*#__PURE__*/React.isValidElement(label):
      // do nothing
      break;

    case _isString(label) || _isNumber(label):
      // @ts-ignore skip type check, the actual type is already determined
      label = {
        text: label
      };
      break;

    case /*#__PURE__*/React.isValidElement(label):
      // @ts-ignore skip type check, the actual type is already determined
      label = {
        text: label
      };
      break;

    default:
      break;
  }

  let slotError = null;

  if (typeof error !== undefined) {
    let emProps = {};

    switch (true) {
      case _isObject(error) && ! /*#__PURE__*/React.isValidElement(error):
        // do nothing
        emProps = error;
        break;

      case _isString(error) || _isNumber(error):
        emProps = {
          error
        };
        break;

      case /*#__PURE__*/React.isValidElement(error):
        emProps = {
          error
        };
        break;

      default:
        break;
    }

    slotError = /*#__PURE__*/React.createElement(ErrorMessage, _Object$assign({}, emProps));
  }

  let mergeLabelProps = _Object$assign({
    align: labelAlign,
    width: labelWidth
  }, label);

  let mainCls = classNames({
    ["".concat(prefix, "-field-main")]: true,
    ["".concat(prefix, "-slot-main")]: true
  });

  switch (true) {
    case !appendCol && !noLabel:
      content = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Label, _Object$assign({}, mergeLabelProps)), /*#__PURE__*/React.createElement("div", {
        className: mainCls
      }, children, slotError));
      break;

    case !appendCol && noLabel:
      content = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
        className: mainCls
      }, children, slotError));
      break;

    case appendCol && labelPosition === 'top':
      // When labelPosition is top, you need to add an overflow hidden div to the label, otherwise it will be arranged horizontally
      content = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
        style: {
          overflow: 'hidden'
        }
      }, /*#__PURE__*/React.createElement(Col, _Object$assign({}, labelCol, {
        className: labelColCls
      }), /*#__PURE__*/React.createElement(Label, _Object$assign({}, mergeLabelProps)))), /*#__PURE__*/React.createElement(Col, null, children, slotError));
      break;

    case appendCol && labelPosition !== 'top':
      content = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Col, _Object$assign({}, labelCol, {
        className: labelColCls
      }), /*#__PURE__*/React.createElement(Label, _Object$assign({}, mergeLabelProps))), /*#__PURE__*/React.createElement(Col, null, children, slotError));
      break;

    default:
      break;
  }

  return /*#__PURE__*/React.createElement("div", {
    className: slotCls,
    "x-label-pos": labelPosition,
    style: style
  }, content);
};

export default FormSlot;