import _isUndefined from "lodash/isUndefined";
import _cloneDeep from "lodash/cloneDeep";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _sliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/slice";
import _spliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/splice";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";

/* eslint-disable react/destructuring-assignment */
import React, { Component } from 'react';
import { getUuidv4 } from '@douyinfe/semi-foundation/lib/es/utils/uuid';
import { FormUpdaterContext, ArrayFieldContext } from './context';
import warning from '@douyinfe/semi-foundation/lib/es/utils/warning';

const filterArrayByIndex = (array, index) => _filterInstanceProperty(array).call(array, (item, i) => i !== index);

const getUuidByArray = array => _mapInstanceProperty(array).call(array, () => getUuidv4());

const getUpdateKey = arrayField => {
  if (!arrayField) {
    return undefined;
  }

  if (arrayField && arrayField.updateKey) {
    return arrayField.updateKey;
  }

  return undefined;
};

const initValueAdapter = initValue => {
  const iv = [];

  if (_Array$isArray(initValue)) {
    return initValue;
  } else {
    warning(!_isUndefined(initValue), '[Semi Form ArrayField] initValue of ArrayField must be an array. Please check the type of your props');
    return iv;
  }
};
/**
 *
 * @param {any[]} value
 * @param {string[]} oldKeys
 * @returns string[]
 */


const generateKeys = (value, oldKeys) => {
  const val = initValueAdapter(value);
  const newKeys = getUuidByArray(val); // return newKeys;

  const keys = _mapInstanceProperty(newKeys).call(newKeys, (key, i) => oldKeys && oldKeys[i] ? oldKeys[i] : key);

  return keys;
};

class ArrayFieldComponent extends Component {
  constructor(props, context) {
    var _context, _context2, _context3;

    super(props, context);
    const initValueInProps = this.props.initValue;
    const {
      field
    } = this.props;
    const initValueInForm = context.getValue(field);
    const initValue = initValueInProps || initValueInForm;
    this.state = {
      keys: generateKeys(initValue)
    };
    this.add = _bindInstanceProperty(_context = this.add).call(_context, this);
    this.addWithInitValue = _bindInstanceProperty(_context2 = this.addWithInitValue).call(_context2, this);
    this.remove = _bindInstanceProperty(_context3 = this.remove).call(_context3, this);
    this.cacheFieldValues = null;
    this.cacheUpdateKey = null;
    /*
        If updateKey exists, it means that the arrayField (usually a nested ArrayField not at the first level) is only re-mounted due to setValues,
        and the fields it contains do not need to consume initValue
    */
    // whether the fields inside arrayField should use props.initValue in current render process

    this.shouldUseInitValue = !context.getArrayField(field); // Separate the arrays that reset and the usual add and remove modify, otherwise they will affect each other

    const initValueCopyForFormState = _cloneDeep(initValue);

    const initValueCopyForReset = _cloneDeep(initValue);

    context.registerArrayField(field, initValueCopyForReset); // register ArrayField will update state.updateKey to render, So there is no need to execute forceUpdate here

    context.updateStateValue(field, initValueCopyForFormState, {
      notNotify: true,
      notUpdate: true
    });
  }

  componentWillUnmount() {
    const updater = this.context;
    const {
      field
    } = this.props;
    updater.unRegisterArrayField(field);
  }

  componentDidUpdate() {
    const updater = this.context;
    const {
      field
    } = this.props;
    const {
      keys
    } = this.state;
    const fieldValues = updater.getValue(field);
    const updateKey = getUpdateKey(updater.getArrayField(field)); // when update form outside, like use formApi.setValue('field', [{newItem1, newItem2}]),  formApi.setValues
    // re generate keys to update arrayField;

    if (updateKey !== this.cacheUpdateKey) {
      const newKeys = generateKeys(fieldValues, keys); // eslint-disable-next-line

      this.setState({
        keys: newKeys
      });
      this.cacheUpdateKey = updateKey;

      if (this.cacheUpdateKey !== null) {
        this.shouldUseInitValue = false;
      }
    }
  }

  add() {
    const {
      keys
    } = this.state;
    keys.push(getUuidv4());
    this.shouldUseInitValue = true;
    this.setState({
      keys
    });
  }

  addWithInitValue(lineObject) {
    var _context4;

    const updater = this.context;
    const {
      field
    } = this.props;
    const newArrayFieldVal = updater.getValue(field) ? _sliceInstanceProperty(_context4 = updater.getValue(field)).call(_context4) : [];
    newArrayFieldVal.push(lineObject);
    updater.updateStateValue(field, newArrayFieldVal, {});
    updater.updateArrayField(field, {
      updateKey: new Date().valueOf()
    });
  }

  remove(i) {
    const updater = this.context;
    const {
      keys
    } = this.state;
    const {
      field
    } = this.props;
    const newKeys = filterArrayByIndex(keys, i); // Make sure that all the keys in the line are removed, because some keys are not taken over by the field, only set in the initValue

    let newArrayFieldError = updater.getError(field);
    const opts = {
      notNotify: true,
      notUpdate: true
    };

    if (_Array$isArray(newArrayFieldError)) {
      newArrayFieldError = _sliceInstanceProperty(newArrayFieldError).call(newArrayFieldError);

      _spliceInstanceProperty(newArrayFieldError).call(newArrayFieldError, i, 1);

      updater.updateStateError(field, newArrayFieldError, opts);
    } // if (Array.isArray(newArrayFieldTouched)) {
    //     newArrayFieldTouched = newArrayFieldTouched.slice();
    //     newArrayFieldTouched.splice(i, 1);
    //     updater.updateStateTouched(field, newArrayFieldTouched, opts);
    // }


    let newArrayFieldValue = updater.getValue(field);

    if (_Array$isArray(newArrayFieldValue)) {
      newArrayFieldValue = _sliceInstanceProperty(newArrayFieldValue).call(newArrayFieldValue);

      _spliceInstanceProperty(newArrayFieldValue).call(newArrayFieldValue, i, 1);

      updater.updateStateValue(field, newArrayFieldValue);
    }

    this.setState({
      keys: newKeys
    });
  }

  render() {
    const {
      children,
      field
    } = this.props;
    const {
      keys
    } = this.state;

    const arrayFields = _mapInstanceProperty(keys).call(keys, (key, i) => {
      var _context5;

      return {
        // key: i,
        key,
        field: _concatInstanceProperty(_context5 = "".concat(field, "[")).call(_context5, i, "]"),
        remove: () => this.remove(i)
      };
    });

    const {
      add
    } = this;
    const {
      addWithInitValue
    } = this;
    const contextVal = {
      shouldUseInitValue: this.shouldUseInitValue
    };
    return /*#__PURE__*/React.createElement(ArrayFieldContext.Provider, {
      value: contextVal
    }, children({
      arrayFields,
      add,
      addWithInitValue
    }));
  }

}

ArrayFieldComponent.contextType = FormUpdaterContext;
export default ArrayFieldComponent;