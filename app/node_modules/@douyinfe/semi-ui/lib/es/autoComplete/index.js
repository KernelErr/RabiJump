import _noop from "lodash/noop";
import _isEqual from "lodash/isEqual";
import _Map from "@babel/runtime-corejs3/core-js-stable/map";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _Array$from from "@babel/runtime-corejs3/core-js-stable/array/from";
import _valuesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/values";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";

/* eslint-disable @typescript-eslint/ban-types, max-len */
import React from 'react';
import PropTypes from 'prop-types';
import cls from 'classnames';
import { strings, cssClasses } from '@douyinfe/semi-foundation/lib/es/autoComplete/constants';
import AutoCompleteFoundation from '@douyinfe/semi-foundation/lib/es/autoComplete/foundation';
import { numbers as popoverNumbers } from '@douyinfe/semi-foundation/lib/es/popover/constants';
import BaseComponent from '../_base/baseComponent';
import Spin from '../spin';
import Popover from '../popover';
import Input from '../input';
import Trigger from '../trigger';
import Option from '../select/option';
import warning from '@douyinfe/semi-foundation/lib/es/utils/warning';
import '@douyinfe/semi-foundation/lib/es/autoComplete/autoComplete.css';
const prefixCls = cssClasses.PREFIX;
const sizeSet = strings.SIZE;
const positionSet = strings.POSITION;
const statusSet = strings.STATUS;

class AutoComplete extends BaseComponent {
  constructor(props) {
    super(props);

    this.onSelect = (option, optionIndex, e) => {
      this.foundation.handleSelect(option, optionIndex);
    };

    this.onSearch = value => {
      this.foundation.handleSearch(value);
    };

    this.onBlur = e => this.foundation.handleBlur(e);

    this.onFocus = e => this.foundation.handleFocus(e);

    this.onInputClear = () => this.foundation.handleClear();

    this.handleInputClick = e => this.foundation.handleInputClick(e);

    this.foundation = new AutoCompleteFoundation(this.adapter);
    const initRePosKey = 1;
    this.state = {
      dropdownMinWidth: null,
      inputValue: '',
      // option list
      options: [],
      // popover visible
      visible: false,
      // current focus option index
      focusIndex: props.defaultActiveFirstOption ? 0 : -1,
      // current selected options
      selection: new _Map(),
      rePosKey: initRePosKey
    };
    this.triggerRef = /*#__PURE__*/React.createRef();
    this.optionsRef = /*#__PURE__*/React.createRef();
    this.clickOutsideHandler = null;
    warning('triggerRender' in this.props && typeof this.props.triggerRender === 'function', "[Semi AutoComplete]\n            - If you are using the following props: 'suffix', 'prefix', 'showClear', 'validateStatus', and 'size',\n            please notice that they will be removed in the next major version.\n            Please use 'componentProps' to retrieve these props instead.\n            - If you are using 'onBlur', 'onFocus', please try to avoid using them and look for changes in the future.");
  }

  get adapter() {
    const keyboardAdapter = {
      registerKeyDown: cb => {
        const keyboardEventSet = {
          onKeyDown: cb
        };
        this.setState({
          keyboardEventSet
        });
      },
      unregisterKeyDown: cb => {
        this.setState({
          keyboardEventSet: {}
        });
      },
      updateFocusIndex: focusIndex => {
        this.setState({
          focusIndex
        });
      }
    };
    return _Object$assign(_Object$assign(_Object$assign({}, super.adapter), keyboardAdapter), {
      getTriggerWidth: () => {
        const el = this.triggerRef.current;
        return el && el.getBoundingClientRect().width;
      },
      setOptionWrapperWidth: width => {
        this.setState({
          dropdownMinWidth: width
        });
      },
      updateInputValue: inputValue => {
        this.setState({
          inputValue
        });
      },
      toggleListVisible: isShow => {
        this.setState({
          visible: isShow
        });
      },
      updateOptionList: optionList => {
        this.setState({
          options: optionList
        });
      },
      updateSelection: selection => {
        this.setState({
          selection
        });
      },
      notifySearch: inputValue => {
        this.props.onSearch(inputValue);
      },
      notifyChange: value => {
        this.props.onChange(value);
      },
      notifySelect: option => {
        this.props.onSelect(option);
      },
      notifyDropdownVisibleChange: isVisible => {
        this.props.onDropdownVisibleChange(isVisible);
      },
      notifyClear: () => {
        this.props.onClear();
      },
      notifyFocus: event => {
        this.props.onFocus(event);
      },
      notifyBlur: event => {
        this.props.onBlur(event);
      },
      rePositionDropdown: () => {
        let {
          rePosKey
        } = this.state;
        rePosKey = rePosKey + 1;
        this.setState({
          rePosKey
        });
      }
    });
  }

  componentDidMount() {
    this.foundation.init();
  }

  componentWillUnmount() {
    this.foundation.destroy();
  }

  componentDidUpdate(prevProps, prevState) {
    if (!_isEqual(this.props.data, prevProps.data)) {
      this.foundation.handleDataChange(this.props.data);
    }

    if (this.props.value !== prevProps.value) {
      this.foundation.handleValueChange(this.props.value);
    }
  }

  renderInput() {
    const {
      size,
      prefix,
      insetLabel,
      insetLabelId,
      suffix,
      placeholder,
      style,
      className,
      showClear,
      disabled,
      triggerRender,
      validateStatus,
      autoFocus,
      value,
      id
    } = this.props;
    const {
      inputValue,
      keyboardEventSet,
      selection
    } = this.state;
    const useCustomTrigger = typeof triggerRender === 'function';

    const outerProps = _Object$assign({
      style,
      className: useCustomTrigger ? cls(className) : cls({
        [prefixCls]: true,
        ["".concat(prefixCls, "-disabled")]: disabled
      }, className),
      onClick: this.handleInputClick,
      ref: this.triggerRef,
      id
    }, keyboardEventSet);

    const innerProps = {
      disabled,
      placeholder,
      autofocus: autoFocus,
      onChange: this.onSearch,
      onClear: this.onInputClear,
      'aria-label': this.props['aria-label'],
      'aria-labelledby': this.props['aria-labelledby'],
      'aria-invalid': this.props['aria-invalid'],
      'aria-errormessage': this.props['aria-errormessage'],
      'aria-describedby': this.props['aria-describedby'],
      'aria-required': this.props['aria-required'],
      // TODO: remove in next major version
      suffix,
      prefix: prefix || insetLabel,
      insetLabelId,
      showClear,
      validateStatus,
      size,
      onBlur: this.onBlur,
      onFocus: this.onFocus
    };
    return /*#__PURE__*/React.createElement("div", _Object$assign({}, outerProps), typeof triggerRender === 'function' ? /*#__PURE__*/React.createElement(Trigger, _Object$assign({}, innerProps, {
      inputValue: typeof value !== 'undefined' ? value : inputValue,
      value: _Array$from(_valuesInstanceProperty(selection).call(selection)),
      triggerRender: triggerRender,
      componentName: "AutoComplete",
      componentProps: _Object$assign({}, this.props)
    })) : /*#__PURE__*/React.createElement(Input, _Object$assign({}, innerProps, {
      value: typeof value !== 'undefined' ? value : inputValue
    })));
  }

  renderLoading() {
    const loadingWrapperCls = "".concat(prefixCls, "-loading-wrapper");
    return /*#__PURE__*/React.createElement("div", {
      className: loadingWrapperCls
    }, /*#__PURE__*/React.createElement(Spin, null));
  }

  renderOption(option, optionIndex) {
    const {
      focusIndex
    } = this.state;
    const isFocused = optionIndex === focusIndex;
    return /*#__PURE__*/React.createElement(Option, _Object$assign({
      showTick: false,
      onSelect: (v, e) => this.onSelect(v, optionIndex, e),
      // selected={selection.has(option.label)}
      focused: isFocused,
      onMouseEnter: () => this.foundation.handleOptionMouseEnter(optionIndex),
      key: option.key || option.label + option.value + optionIndex
    }, option), option.label);
  }

  renderOptionList() {
    const {
      maxHeight,
      dropdownStyle,
      dropdownClassName,
      loading,
      emptyContent
    } = this.props;
    const {
      options,
      dropdownMinWidth
    } = this.state;
    const listCls = cls({
      ["".concat(prefixCls, "-option-list")]: true
    }, dropdownClassName);
    let optionsNode;

    if (options.length === 0) {
      optionsNode = emptyContent;
    } else {
      var _context;

      optionsNode = _mapInstanceProperty(_context = _filterInstanceProperty(options).call(options, option => option.show)).call(_context, (option, i) => this.renderOption(option, i));
    }

    const style = _Object$assign({
      maxHeight: maxHeight,
      minWidth: dropdownMinWidth
    }, dropdownStyle);

    return /*#__PURE__*/React.createElement("div", {
      className: listCls,
      role: "listbox",
      style: style
    }, !loading ? optionsNode : this.renderLoading());
  }

  render() {
    const {
      position,
      motion,
      zIndex,
      mouseEnterDelay,
      mouseLeaveDelay,
      autoAdjustOverflow,
      stopPropagation,
      getPopupContainer
    } = this.props;
    const {
      visible,
      rePosKey
    } = this.state;
    const input = this.renderInput();
    const optionList = this.renderOptionList();
    return /*#__PURE__*/React.createElement(Popover, {
      mouseEnterDelay: mouseEnterDelay,
      mouseLeaveDelay: mouseLeaveDelay,
      autoAdjustOverflow: autoAdjustOverflow,
      trigger: "custom",
      motion: motion,
      visible: visible,
      content: optionList,
      position: position,
      ref: this.optionsRef,
      // TransformFromCenter TODO: need to confirm
      zIndex: zIndex,
      stopPropagation: stopPropagation,
      getPopupContainer: getPopupContainer,
      rePosKey: rePosKey
    }, input);
  }

}

AutoComplete.propTypes = {
  'aria-label': PropTypes.string,
  'aria-labelledby': PropTypes.string,
  'aria-invalid': PropTypes.bool,
  'aria-errormessage': PropTypes.string,
  'aria-describedby': PropTypes.string,
  'aria-required': PropTypes.bool,
  autoFocus: PropTypes.bool,
  autoAdjustOverflow: PropTypes.bool,
  className: PropTypes.string,
  children: PropTypes.node,
  data: PropTypes.array,
  defaultOpen: PropTypes.bool,
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  defaultActiveFirstOption: PropTypes.bool,
  disabled: PropTypes.bool,
  dropdownMatchSelectWidth: PropTypes.bool,
  dropdownClassName: PropTypes.string,
  dropdownStyle: PropTypes.object,
  emptyContent: PropTypes.node,
  id: PropTypes.string,
  insetLabel: PropTypes.node,
  insetLabelId: PropTypes.string,
  onSearch: PropTypes.func,
  onSelect: PropTypes.func,
  onClear: PropTypes.func,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  onChange: PropTypes.func,
  position: PropTypes.oneOf(positionSet),
  placeholder: PropTypes.string,
  prefix: PropTypes.node,
  onChangeWithObject: PropTypes.bool,
  onSelectWithObject: PropTypes.bool,
  renderItem: PropTypes.func,
  renderSelectedItem: PropTypes.func,
  suffix: PropTypes.node,
  showClear: PropTypes.bool,
  size: PropTypes.oneOf(sizeSet),
  style: PropTypes.object,
  stopPropagation: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
  maxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  mouseEnterDelay: PropTypes.number,
  mouseLeaveDelay: PropTypes.number,
  motion: PropTypes.oneOfType([PropTypes.bool, PropTypes.func, PropTypes.object]),
  getPopupContainer: PropTypes.func,
  triggerRender: PropTypes.func,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  validateStatus: PropTypes.oneOf(statusSet),
  zIndex: PropTypes.number
};
AutoComplete.Option = Option;
AutoComplete.defaultProps = {
  stopPropagation: true,
  motion: true,
  zIndex: popoverNumbers.DEFAULT_Z_INDEX,
  position: 'bottomLeft',
  data: [],
  showClear: false,
  size: 'default',
  onFocus: _noop,
  onSearch: _noop,
  onClear: _noop,
  onBlur: _noop,
  onSelect: _noop,
  onChange: _noop,
  onSelectWithObject: false,
  onDropdownVisibleChange: _noop,
  defaultActiveFirstOption: false,
  dropdownMatchSelectWidth: true,
  loading: false,
  maxHeight: 300,
  validateStatus: 'default',
  autoFocus: false,
  emptyContent: null // onPressEnter: () => undefined,
  // defaultOpen: false,

};
export default AutoComplete;