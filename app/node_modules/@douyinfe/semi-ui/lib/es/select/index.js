import _isNumber from "lodash/isNumber";
import _get from "lodash/get";
import _noop from "lodash/noop";
import _isString from "lodash/isString";
import _isEqual from "lodash/isEqual";
import _Map from "@babel/runtime-corejs3/core-js-stable/map";
import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _someInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/some";
import _sliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/slice";
import _Array$from from "@babel/runtime-corejs3/core-js-stable/array/from";
import _valuesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/values";

/* eslint-disable max-len */

/* eslint-disable max-lines-per-function */
import React, { Fragment } from 'react';
import ReactDOM from 'react-dom';
import cls from 'classnames';
import PropTypes from 'prop-types';
import ConfigContext from '../configProvider/context';
import SelectFoundation from '@douyinfe/semi-foundation/lib/es/select/foundation';
import { cssClasses, strings, numbers } from '@douyinfe/semi-foundation/lib/es/select/constants';
import BaseComponent from '../_base/baseComponent';
import Tag from '../tag/index';
import TagGroup from '../tag/group';
import LocaleConsumer from '../locale/localeConsumer';
import Popover from '../popover/index';
import { numbers as popoverNumbers } from '@douyinfe/semi-foundation/lib/es/popover/constants';
import { FixedSizeList as List } from 'react-window';
import { getOptionsFromGroup } from './utils';
import VirtualRow from './virtualRow';
import Input from '../input/index';
import Option from './option';
import OptionGroup from './optionGroup';
import Spin from '../spin';
import Trigger from '../trigger';
import { IconChevronDown, IconClear } from '@douyinfe/semi-icons';
import { isSemiIcon, getFocusableElements, getActiveElement } from '../_utils';
import warning from '@douyinfe/semi-foundation/lib/es/utils/warning';
import { getUuidShort } from '@douyinfe/semi-foundation/lib/es/utils/uuid';
import '@douyinfe/semi-foundation/lib/es/select/select.css';
const prefixcls = cssClasses.PREFIX;
const key = 0; // Notes: Use the label of the option as the identifier, that is, the option in Select, the value is allowed to be the same, but the label must be unique

class Select extends BaseComponent {
  constructor(props) {
    var _context, _context2, _context3, _context4, _context5, _context6;

    super(props);

    this.setOptionContainerEl = node => this.optionContainerEl = {
      current: node
    };

    this.handleInputChange = value => this.foundation.handleInputChange(value);

    this.state = {
      isOpen: false,
      isFocus: false,
      options: [],
      selections: new _Map(),
      dropdownMinWidth: null,
      optionKey: key,
      inputValue: '',
      showInput: false,
      focusIndex: props.defaultActiveFirstOption ? 0 : -1,
      keyboardEventSet: {},
      optionGroups: [],
      isHovering: false,
      isFocusInContainer: false
    };
    /* Generate random string */

    this.selectOptionListID = '';
    this.selectID = '';
    this.virtualizeListRef = /*#__PURE__*/React.createRef();
    this.inputRef = /*#__PURE__*/React.createRef();
    this.triggerRef = /*#__PURE__*/React.createRef();
    this.optionsRef = /*#__PURE__*/React.createRef();
    this.optionContainerEl = /*#__PURE__*/React.createRef();
    this.clickOutsideHandler = null;
    this.onSelect = _bindInstanceProperty(_context = this.onSelect).call(_context, this);
    this.onClear = _bindInstanceProperty(_context2 = this.onClear).call(_context2, this);
    this.onMouseEnter = _bindInstanceProperty(_context3 = this.onMouseEnter).call(_context3, this);
    this.onMouseLeave = _bindInstanceProperty(_context4 = this.onMouseLeave).call(_context4, this);
    this.renderOption = _bindInstanceProperty(_context5 = this.renderOption).call(_context5, this);
    this.onKeyPress = _bindInstanceProperty(_context6 = this.onKeyPress).call(_context6, this);
    this.foundation = new SelectFoundation(this.adapter);
    warning('optionLabelProp' in this.props, '[Semi Select] \'optionLabelProp\' has already been deprecated, please use \'renderSelectedItem\' instead.');
    warning('labelInValue' in this.props, '[Semi Select] \'labelInValue\' has already been deprecated, please use \'onChangeWithObject\' instead.');
  }

  get adapter() {
    var _this = this;

    const keyboardAdapter = {
      registerKeyDown: cb => {
        const keyboardEventSet = {
          onKeyDown: cb
        };
        this.setState({
          keyboardEventSet
        });
      },
      unregisterKeyDown: () => {
        this.setState({
          keyboardEventSet: {}
        });
      },
      updateFocusIndex: focusIndex => {
        this.setState({
          focusIndex
        });
      },
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      scrollToFocusOption: () => {}
    };
    const filterAdapter = {
      updateInputValue: value => {
        this.setState({
          inputValue: value
        });
      },
      toggleInputShow: (showInput, cb) => {
        this.setState({
          showInput
        }, () => {
          cb();
        });
      },
      focusInput: () => {
        const {
          preventScroll
        } = this.props;

        if (this.inputRef && this.inputRef.current) {
          this.inputRef.current.focus({
            preventScroll
          });
        }
      }
    };
    const multipleAdapter = {
      notifyMaxLimit: option => this.props.onExceed(option),
      getMaxLimit: () => this.props.max,
      registerClickOutsideHandler: cb => {
        const clickOutsideHandler = e => {
          const optionInstance = this.optionsRef && this.optionsRef.current;
          const triggerDom = this.triggerRef && this.triggerRef.current; // eslint-disable-next-line react/no-find-dom-node

          const optionsDom = ReactDOM.findDOMNode(optionInstance); // let isInPanel = optionsDom && optionsDom.contains(e.target);
          // let isInTrigger = triggerDom && triggerDom.contains(e.target);

          if (optionsDom && !optionsDom.contains(e.target) && triggerDom && !triggerDom.contains(e.target)) {
            cb(e);
          }
        };

        this.clickOutsideHandler = clickOutsideHandler;
        document.addEventListener('mousedown', clickOutsideHandler, false);
      },
      unregisterClickOutsideHandler: () => {
        if (this.clickOutsideHandler) {
          document.removeEventListener('mousedown', this.clickOutsideHandler, false);
          this.clickOutsideHandler = null;
        }
      },
      rePositionDropdown: () => {
        let {
          optionKey
        } = this.state;
        optionKey = optionKey + 1;
        this.setState({
          optionKey
        });
      },
      notifyDeselect: (value, option) => {
        delete option._parentGroup;
        this.props.onDeselect(value, option);
      }
    };
    return _Object$assign(_Object$assign(_Object$assign(_Object$assign(_Object$assign({}, super.adapter), keyboardAdapter), filterAdapter), multipleAdapter), {
      // Collect all subitems, each item is visible by default when collected, and is not selected
      getOptionsFromChildren: function () {
        let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props.children;
        let optionGroups = [];
        let options = [];
        const {
          optionList
        } = _this.props;

        if (optionList && optionList.length) {
          options = _mapInstanceProperty(optionList).call(optionList, (itemOpt, index) => _Object$assign({
            _show: true,
            _selected: false,
            _scrollIndex: index
          }, itemOpt));
          optionGroups[0] = {
            children: options,
            label: ''
          };
        } else {
          const result = getOptionsFromGroup(children);
          optionGroups = result.optionGroups;
          options = result.options;
        }

        _this.setState({
          optionGroups
        });

        return options;
      },
      updateOptions: options => {
        this.setState({
          options
        });
      },
      openMenu: () => {
        this.setState({
          isOpen: true
        });
      },
      closeMenu: () => {
        this.setState({
          isOpen: false
        });
      },
      getTriggerWidth: () => {
        const el = this.triggerRef.current;
        return el && el.getBoundingClientRect().width;
      },
      setOptionWrapperWidth: width => {
        this.setState({
          dropdownMinWidth: width
        });
      },
      updateSelection: selections => {
        this.setState({
          selections
        });
      },
      // clone Map, important!!!, prevent unexpected modify on state
      getSelections: () => new _Map(this.state.selections),
      notifyChange: value => {
        this.props.onChange(value);
      },
      notifySelect: (value, option) => {
        delete option._parentGroup;
        this.props.onSelect(value, option);
      },
      notifyDropdownVisibleChange: visible => {
        this.props.onDropdownVisibleChange(visible);
      },
      notifySearch: input => {
        this.props.onSearch(input);
      },
      notifyCreate: input => {
        this.props.onCreate(input);
      },
      notifyMouseEnter: e => {
        this.props.onMouseEnter(e);
      },
      notifyMouseLeave: e => {
        this.props.onMouseLeave(e);
      },
      notifyFocus: event => {
        this.props.onFocus(event);
      },
      notifyBlur: event => {
        this.props.onBlur(event);
      },
      notifyClear: () => {
        this.props.onClear();
      },
      notifyListScroll: e => {
        this.props.onListScroll(e);
      },
      updateHovering: isHovering => {
        this.setState({
          isHovering
        });
      },
      updateFocusState: isFocus => {
        this.setState({
          isFocus
        });
      },
      focusTrigger: () => {
        try {
          const {
            preventScroll
          } = this.props;
          const el = this.triggerRef.current;
          el.focus({
            preventScroll
          });
        } catch (error) {}
      },
      getContainer: () => {
        return this.optionContainerEl && this.optionContainerEl.current;
      },
      getFocusableElements: node => {
        return getFocusableElements(node);
      },
      getActiveElement: () => {
        return getActiveElement();
      },
      setIsFocusInContainer: isFocusInContainer => {
        this.setState({
          isFocusInContainer
        });
      },
      getIsFocusInContainer: () => {
        return this.state.isFocusInContainer;
      },
      updateScrollTop: index => {
        var _context8, _context9;

        // eslint-disable-next-line max-len
        let optionClassName = ".".concat(prefixcls, "-option-selected");

        if (index !== undefined) {
          var _context7;

          optionClassName = _concatInstanceProperty(_context7 = ".".concat(prefixcls, "-option:nth-child(")).call(_context7, index, ")");
        }

        let destNode = document.querySelector(_concatInstanceProperty(_context8 = _concatInstanceProperty(_context9 = "#".concat(prefixcls, "-")).call(_context9, this.selectOptionListID, " ")).call(_context8, optionClassName));

        if (_Array$isArray(destNode)) {
          // eslint-disable-next-line prefer-destructuring
          destNode = destNode[0];
        }

        if (destNode) {
          /**
           * Scroll the first selected item into view.
           * The reason why ScrollIntoView is not used here is that it may cause page to move.
           */
          const destParent = destNode.parentNode;
          destParent.scrollTop = destNode.offsetTop - destParent.offsetTop - destParent.clientHeight / 2 + destNode.clientHeight / 2;
        }
      }
    });
  }

  componentDidMount() {
    this.foundation.init();
    this.selectOptionListID = getUuidShort();
    this.selectID = this.props.id || getUuidShort();
  }

  componentWillUnmount() {
    this.foundation.destroy();
  }

  componentDidUpdate(prevProps, prevState) {
    var _context10, _context11;

    const prevChildrenKeys = _mapInstanceProperty(_context10 = React.Children.toArray(prevProps.children)).call(_context10, child => child.key);

    const nowChildrenKeys = _mapInstanceProperty(_context11 = React.Children.toArray(this.props.children)).call(_context11, child => child.key);

    let isOptionsChanged = false;

    if (!_isEqual(prevChildrenKeys, nowChildrenKeys) || !_isEqual(prevProps.optionList, this.props.optionList)) {
      isOptionsChanged = true;
      this.foundation.handleOptionListChange();
    } // Add isOptionChanged: There may be cases where the value is unchanged, but the optionList is updated. At this time, the label corresponding to the value may change, and the selected item needs to be updated


    if (prevProps.value !== this.props.value || isOptionsChanged) {
      if ('value' in this.props) {
        this.foundation.handleValueChange(this.props.value);
      } else {
        this.foundation.handleOptionListChangeHadDefaultValue();
      }
    }
  }

  renderInput() {
    var _context12;

    const {
      size,
      multiple,
      disabled,
      inputProps,
      filter
    } = this.props;

    const inputPropsCls = _get(inputProps, 'className');

    const inputcls = cls("".concat(prefixcls, "-input"), {
      ["".concat(prefixcls, "-input-single")]: !multiple,
      ["".concat(prefixcls, "-input-multiple")]: multiple
    }, inputPropsCls);
    const {
      inputValue,
      focusIndex
    } = this.state;

    const selectInputProps = _Object$assign({
      value: inputValue,
      disabled,
      className: inputcls,
      onChange: this.handleInputChange
    }, inputProps);

    let style = {}; // Multiple choice mode

    if (multiple) {
      style = {
        width: inputValue ? "".concat(inputValue.length * 16, "px") : '2px'
      };
      selectInputProps.style = style;
    }

    return /*#__PURE__*/React.createElement(Input, _Object$assign({
      ref: this.inputRef,
      size: size,
      "aria-activedescendant": focusIndex !== -1 ? _concatInstanceProperty(_context12 = "".concat(this.selectID, "-option-")).call(_context12, focusIndex) : '',
      onFocus: e => {
        // if multiple and filter, when use tab key to let select get focus
        // need to manual update state isFocus to let the focus style take effect
        if (multiple && Boolean(filter)) {
          this.setState({
            isFocus: true
          });
        } // prevent event bubbling which will fire trigger onFocus event


        e.stopPropagation(); // e.nativeEvent.stopImmediatePropagation();
      },
      onBlur: e => this.foundation.handleInputBlur(e)
    }, selectInputProps));
  }

  close() {
    this.foundation.close();
  }

  open() {
    this.foundation.open();
  }

  clearInput() {
    this.foundation.clearInput();
  }

  selectAll() {
    this.foundation.selectAll();
  }

  deselectAll() {
    this.foundation.clearSelected();
  }

  focus() {
    this.foundation.focus();
  }

  onSelect(option, optionIndex, e) {
    this.foundation.onSelect(option, optionIndex, e);
  }

  onClear(e) {
    e.nativeEvent.stopImmediatePropagation();
    this.foundation.handleClearClick(e);
  }

  renderEmpty() {
    return /*#__PURE__*/React.createElement(Option, {
      empty: true,
      emptyContent: this.props.emptyContent
    });
  }

  renderLoading() {
    const loadingWrapperCls = "".concat(prefixcls, "-loading-wrapper");
    return /*#__PURE__*/React.createElement("div", {
      className: loadingWrapperCls
    }, /*#__PURE__*/React.createElement(Spin, null));
  }

  renderOption(option, optionIndex, style) {
    const {
      focusIndex,
      inputValue
    } = this.state;
    const {
      renderOptionItem
    } = this.props;
    let optionContent;
    const isFocused = optionIndex === focusIndex;
    let optionStyle = style || {};

    if (option.style) {
      optionStyle = _Object$assign(_Object$assign({}, optionStyle), option.style);
    }

    if (option._inputCreateOnly) {
      optionContent = this.renderCreateOption(option, isFocused, optionIndex, style);
    } else {
      var _context13;

      // use another name to make sure that 'key' in optionList still exist when we call onChange
      if ('key' in option) {
        option._keyInOptionList = option.key;
      }

      optionContent = /*#__PURE__*/React.createElement(Option, _Object$assign({
        showTick: true
      }, option, {
        selected: option._selected,
        onSelect: (v, e) => this.onSelect(v, optionIndex, e),
        focused: isFocused,
        onMouseEnter: () => this.onOptionHover(optionIndex),
        style: optionStyle,
        key: option.key || option.label + option.value + optionIndex,
        renderOptionItem: renderOptionItem,
        inputValue: inputValue,
        id: _concatInstanceProperty(_context13 = "".concat(this.selectID, "-option-")).call(_context13, optionIndex)
      }), option.label);
    }

    return optionContent;
  }

  renderCreateOption(option, isFocused, optionIndex, style) {
    const {
      renderCreateItem
    } = this.props; // default render method

    if (typeof renderCreateItem === 'undefined') {
      const defaultCreateItem = /*#__PURE__*/React.createElement(Option, _Object$assign({
        key: option.key || option.label + option.value,
        onSelect: (v, e) => this.onSelect(v, optionIndex, e),
        onMouseEnter: () => this.onOptionHover(optionIndex),
        showTick: true
      }, option, {
        focused: isFocused,
        style: style
      }), /*#__PURE__*/React.createElement(LocaleConsumer, {
        componentName: "Select"
      }, locale => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
        className: "".concat(prefixcls, "-create-tips")
      }, locale.createText), option.value)));
      return defaultCreateItem;
    }

    const customCreateItem = renderCreateItem(option.value, isFocused);
    return (
      /*#__PURE__*/
      // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/interactive-supports-focus
      React.createElement("div", {
        role: "button",
        "aria-label": "Use the input box to create an optional item",
        onClick: e => this.onSelect(option, optionIndex, e),
        key: option.key || option.label
      }, customCreateItem)
    );
  }

  onOptionHover(optionIndex) {
    this.foundation.handleOptionMouseEnter(optionIndex);
  }

  renderWithGroup(visibleOptions) {
    const content = [];
    const groupStatus = new _Map();

    _forEachInstanceProperty(visibleOptions).call(visibleOptions, (option, optionIndex) => {
      const parentGroup = option._parentGroup;
      const optionContent = this.renderOption(option, optionIndex);

      if (parentGroup && !groupStatus.has(parentGroup.label)) {
        // when use with OptionGroup and group content not already insert
        const groupContent = /*#__PURE__*/React.createElement(OptionGroup, _Object$assign({}, parentGroup, {
          key: parentGroup.label
        }));
        groupStatus.set(parentGroup.label, true);
        content.push(groupContent);
      }

      content.push(optionContent);
    });

    return content;
  }

  renderVirtualizeList(visibleOptions) {
    const {
      virtualize
    } = this.props;
    const {
      direction
    } = this.context;
    const {
      height,
      width,
      itemSize
    } = virtualize;
    return /*#__PURE__*/React.createElement(List, {
      ref: this.virtualizeListRef,
      height: height || numbers.LIST_HEIGHT,
      itemCount: visibleOptions.length,
      itemSize: itemSize,
      itemData: {
        visibleOptions,
        renderOption: this.renderOption
      },
      width: width || '100%',
      style: {
        direction
      }
    }, VirtualRow);
  }

  renderOptions(children) {
    var _context14;

    const {
      dropdownMinWidth,
      options,
      selections
    } = this.state;
    const {
      maxHeight,
      dropdownClassName,
      dropdownStyle,
      outerTopSlot,
      innerTopSlot,
      outerBottomSlot,
      innerBottomSlot,
      loading,
      virtualize,
      multiple
    } = this.props; // Do a filter first, instead of directly judging in forEach, so that the focusIndex can correspond to

    const visibleOptions = _filterInstanceProperty(options).call(options, item => item._show);

    let listContent = this.renderWithGroup(visibleOptions);

    if (virtualize) {
      listContent = this.renderVirtualizeList(visibleOptions);
    }

    const style = _Object$assign({
      minWidth: dropdownMinWidth
    }, dropdownStyle);

    const optionListCls = cls({
      ["".concat(prefixcls, "-option-list")]: true,
      ["".concat(prefixcls, "-option-list-chosen")]: selections.size
    });
    const isEmpty = !options.length || !_someInstanceProperty(options).call(options, item => item._show);
    return (
      /*#__PURE__*/
      // eslint-disable-next-line jsx-a11y/no-static-element-interactions
      React.createElement("div", {
        id: _concatInstanceProperty(_context14 = "".concat(prefixcls, "-")).call(_context14, this.selectOptionListID),
        className: dropdownClassName,
        style: style,
        ref: this.setOptionContainerEl,
        onKeyDown: e => this.foundation.handleContainerKeyDown(e)
      }, outerTopSlot, /*#__PURE__*/React.createElement("div", {
        style: {
          maxHeight: "".concat(maxHeight, "px")
        },
        className: optionListCls,
        role: "listbox",
        "aria-multiselectable": multiple,
        onScroll: e => this.foundation.handleListScroll(e)
      }, innerTopSlot, loading ? this.renderLoading() : isEmpty ? this.renderEmpty() : listContent, innerBottomSlot), outerBottomSlot)
    );
  }

  renderSingleSelection(selections, filterable) {
    let {
      renderSelectedItem
    } = this.props;
    const {
      placeholder
    } = this.props;
    const {
      showInput,
      inputValue
    } = this.state;
    let renderText = '';
    const selectedItems = [...selections];

    if (typeof renderSelectedItem === 'undefined') {
      renderSelectedItem = optionNode => optionNode.label;
    }

    if (selectedItems.length) {
      const selectedItem = selectedItems[0][1];
      renderText = renderSelectedItem(selectedItem);
    }

    const spanCls = cls({
      ["".concat(prefixcls, "-selection-text")]: true,
      ["".concat(prefixcls, "-selection-placeholder")]: !renderText && renderText !== 0,
      ["".concat(prefixcls, "-selection-text-hide")]: inputValue && showInput,
      ["".concat(prefixcls, "-selection-text-inactive")]: !inputValue && showInput // Stack Input & RenderText(opacity 0.4)

    });
    const contentWrapperCls = "".concat(prefixcls, "-content-wrapper");
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
      className: contentWrapperCls
    }, /*#__PURE__*/React.createElement("span", {
      className: spanCls,
      "x-semi-prop": "placeholder"
    }, renderText || renderText === 0 ? renderText : placeholder), filterable && showInput ? this.renderInput() : null));
  }

  renderMultipleSelection(selections, filterable) {
    let {
      renderSelectedItem
    } = this.props;
    const {
      placeholder,
      maxTagCount,
      size
    } = this.props;
    const {
      inputValue
    } = this.state;
    const selectDisabled = this.props.disabled;
    const renderTags = [];
    const selectedItems = [...selections];

    if (typeof renderSelectedItem === 'undefined') {
      renderSelectedItem = optionNode => ({
        isRenderInTag: true,
        content: optionNode.label
      });
    }

    const mapItems = maxTagCount ? _sliceInstanceProperty(selectedItems).call(selectedItems, 0, maxTagCount) : selectedItems; // no need to render rest tag when maxTagCount is setting

    const tags = _mapInstanceProperty(mapItems).call(mapItems, (item, i) => {
      const label = item[0];
      const {
        value
      } = item[1];
      const disabled = item[1].disabled || selectDisabled;

      const onClose = (tagContent, e) => {
        if (e && typeof e.preventDefault === 'function') {
          e.preventDefault(); // make sure that tag will not hidden immediately in controlled mode
        }

        this.foundation.removeTag({
          label,
          value
        });
      };

      const {
        content,
        isRenderInTag
      } = renderSelectedItem(item[1], {
        index: i,
        disabled,
        onClose
      });
      const basic = {
        disabled,
        closable: !disabled,
        onClose
      };

      if (isRenderInTag) {
        return /*#__PURE__*/React.createElement(Tag, _Object$assign({}, basic, {
          color: "white",
          size: size || 'large',
          key: value,
          tabIndex: -1
        }), content);
      } else {
        return /*#__PURE__*/React.createElement(Fragment, {
          key: value
        }, content);
      }
    });

    const contentWrapperCls = cls({
      ["".concat(prefixcls, "-content-wrapper")]: true,
      ["".concat(prefixcls, "-content-wrapper-one-line")]: maxTagCount,
      ["".concat(prefixcls, "-content-wrapper-empty")]: !tags.length
    });
    const spanCls = cls({
      ["".concat(prefixcls, "-selection-text")]: true,
      ["".concat(prefixcls, "-selection-placeholder")]: !tags.length,
      ["".concat(prefixcls, "-selection-text-hide")]: tags && tags.length // [prefixcls + '-selection-text-inactive']: !inputValue && !tags.length,

    });
    const placeholderText = placeholder && !inputValue ? /*#__PURE__*/React.createElement("span", {
      className: spanCls
    }, placeholder) : null;
    const n = selectedItems.length > maxTagCount ? maxTagCount : undefined;
    const NotOneLine = !maxTagCount; // Multiple lines (that is, do not set maxTagCount), do not use TagGroup, directly traverse with Tag, otherwise Input cannot follow the correct position

    const tagContent = NotOneLine ? tags : /*#__PURE__*/React.createElement(TagGroup, {
      tagList: tags,
      maxTagCount: n,
      restCount: maxTagCount ? selectedItems.length - maxTagCount : undefined,
      size: "large",
      mode: "custom"
    });
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
      className: contentWrapperCls
    }, tags && tags.length ? tagContent : placeholderText, !filterable ? null : this.renderInput()));
  }

  onMouseEnter(e) {
    this.foundation.handleMouseEnter(e);
  }

  onMouseLeave(e) {
    this.foundation.handleMouseLeave(e);
  }

  onKeyPress(e) {
    this.foundation.handleKeyPress(e);
  }
  /* Processing logic when popover visible changes */


  handlePopoverVisibleChange(status) {
    const {
      virtualize
    } = this.props;
    const {
      selections
    } = this.state;

    if (!status) {
      return;
    }

    if (virtualize) {
      let minItemIndex = -1;

      _forEachInstanceProperty(selections).call(selections, item => {
        const itemIndex = _get(item, '_scrollIndex');
        /* When the itemIndex is legal */


        if (_isNumber(itemIndex) && itemIndex >= 0) {
          minItemIndex = minItemIndex !== -1 && minItemIndex < itemIndex ? minItemIndex : itemIndex;
        }
      });

      if (minItemIndex !== -1) {
        try {
          this.virtualizeListRef.current.scrollToItem(minItemIndex, 'center');
        } catch (error) {}
      }
    } else {
      this.foundation.updateScrollTop();
    }
  }

  renderSuffix() {
    const {
      suffix
    } = this.props;
    const suffixWrapperCls = cls({
      ["".concat(prefixcls, "-suffix")]: true,
      ["".concat(prefixcls, "-suffix-text")]: suffix && _isString(suffix),
      ["".concat(prefixcls, "-suffix-icon")]: isSemiIcon(suffix)
    });
    return /*#__PURE__*/React.createElement("div", {
      className: suffixWrapperCls,
      "x-semi-prop": "suffix"
    }, suffix);
  }

  renderPrefix() {
    const {
      prefix,
      insetLabel,
      insetLabelId
    } = this.props;
    const labelNode = prefix || insetLabel;
    const prefixWrapperCls = cls({
      ["".concat(prefixcls, "-prefix")]: true,
      ["".concat(prefixcls, "-inset-label")]: insetLabel,
      ["".concat(prefixcls, "-prefix-text")]: labelNode && _isString(labelNode),
      ["".concat(prefixcls, "-prefix-icon")]: isSemiIcon(labelNode)
    });
    return /*#__PURE__*/React.createElement("div", {
      className: prefixWrapperCls,
      id: insetLabelId,
      "x-semi-prop": "prefix,insetLabel"
    }, labelNode);
  }

  renderSelection() {
    var _context15, _context16;

    const {
      disabled,
      multiple,
      filter,
      style,
      id,
      size,
      className,
      validateStatus,
      showArrow,
      suffix,
      prefix,
      insetLabel,
      placeholder,
      triggerRender,
      arrowIcon
    } = this.props;
    const {
      selections,
      isOpen,
      keyboardEventSet,
      inputValue,
      isHovering,
      isFocus,
      showInput,
      focusIndex
    } = this.state;
    const useCustomTrigger = typeof triggerRender === 'function';
    const filterable = Boolean(filter); // filter（boolean || function）

    const selectionCls = useCustomTrigger ? cls(className) : cls(prefixcls, className, {
      ["".concat(prefixcls, "-open")]: isOpen,
      ["".concat(prefixcls, "-focus")]: isFocus,
      ["".concat(prefixcls, "-disabled")]: disabled,
      ["".concat(prefixcls, "-single")]: !multiple,
      ["".concat(prefixcls, "-multiple")]: multiple,
      ["".concat(prefixcls, "-filterable")]: filterable,
      ["".concat(prefixcls, "-small")]: size === 'small',
      ["".concat(prefixcls, "-large")]: size === 'large',
      ["".concat(prefixcls, "-error")]: validateStatus === 'error',
      ["".concat(prefixcls, "-warning")]: validateStatus === 'warning',
      ["".concat(prefixcls, "-no-arrow")]: !showArrow,
      ["".concat(prefixcls, "-with-prefix")]: prefix || insetLabel,
      ["".concat(prefixcls, "-with-suffix")]: suffix
    });
    const showClear = this.props.showClear && (selections.size || inputValue) && !disabled && (isHovering || isOpen);
    const arrowContent = showArrow ? /*#__PURE__*/React.createElement("div", {
      className: "".concat(prefixcls, "-arrow"),
      "x-semi-prop": "arrowIcon"
    }, arrowIcon) : /*#__PURE__*/React.createElement("div", {
      className: "".concat(prefixcls, "-arrow-empty")
    });
    const inner = useCustomTrigger ? /*#__PURE__*/React.createElement(Trigger, {
      value: _Array$from(_valuesInstanceProperty(selections).call(selections)),
      inputValue: inputValue,
      onChange: this.handleInputChange,
      onClear: this.onClear,
      disabled: disabled,
      triggerRender: triggerRender,
      placeholder: placeholder,
      componentName: "Select",
      componentProps: _Object$assign({}, this.props)
    }) : [/*#__PURE__*/React.createElement(Fragment, {
      key: "prefix"
    }, prefix || insetLabel ? this.renderPrefix() : null), /*#__PURE__*/React.createElement(Fragment, {
      key: "selection"
    }, /*#__PURE__*/React.createElement("div", {
      className: cls("".concat(prefixcls, "-selection"))
    }, multiple ? this.renderMultipleSelection(selections, filterable) : this.renderSingleSelection(selections, filterable))), /*#__PURE__*/React.createElement(Fragment, {
      key: "clearicon"
    }, showClear ? /*#__PURE__*/React.createElement("div", {
      className: cls("".concat(prefixcls, "-clear")),
      onClick: this.onClear
    }, /*#__PURE__*/React.createElement(IconClear, null)) : arrowContent), /*#__PURE__*/React.createElement(Fragment, {
      key: "suffix"
    }, suffix ? this.renderSuffix() : null)];
    /**
     *
     * In disabled, searchable single-selection and display input, and searchable multi-selection
     * make combobox not focusable by tab key
     *
     * 在disabled，可搜索单选且显示input框，以及可搜索多选情况下
     * 让combobox无法通过tab聚焦
     */

    const tabIndex = disabled || filterable && showInput || filterable && multiple ? -1 : 0;
    return (
      /*#__PURE__*/

      /* eslint-disable-next-line jsx-a11y/aria-activedescendant-has-tabindex */
      React.createElement("div", _Object$assign({
        role: "combobox",
        "aria-disabled": disabled,
        "aria-expanded": isOpen,
        "aria-controls": _concatInstanceProperty(_context15 = "".concat(prefixcls, "-")).call(_context15, this.selectOptionListID),
        "aria-haspopup": "listbox",
        "aria-label": selections.size ? 'selected' : '',
        "aria-invalid": this.props['aria-invalid'],
        "aria-errormessage": this.props['aria-errormessage'],
        "aria-labelledby": this.props['aria-labelledby'],
        "aria-describedby": this.props['aria-describedby'],
        "aria-required": this.props['aria-required'],
        className: selectionCls,
        ref: ref => this.triggerRef.current = ref,
        onClick: e => this.foundation.handleClick(e),
        style: style,
        id: this.selectID,
        tabIndex: tabIndex,
        "aria-activedescendant": focusIndex !== -1 ? _concatInstanceProperty(_context16 = "".concat(this.selectID, "-option-")).call(_context16, focusIndex) : '',
        onMouseEnter: this.onMouseEnter,
        onMouseLeave: this.onMouseLeave,
        onFocus: e => this.foundation.handleTriggerFocus(e),
        onBlur: e => this.foundation.handleTriggerBlur(e),
        onKeyPress: this.onKeyPress
      }, keyboardEventSet), inner)
    );
  }

  render() {
    const {
      direction
    } = this.context;
    const defaultPosition = direction === 'rtl' ? 'bottomRight' : 'bottomLeft';
    const {
      children,
      position = defaultPosition,
      zIndex,
      getPopupContainer,
      motion,
      autoAdjustOverflow,
      mouseLeaveDelay,
      mouseEnterDelay,
      spacing,
      stopPropagation
    } = this.props;
    const {
      isOpen,
      optionKey
    } = this.state;
    const optionList = this.renderOptions(children);
    const selection = this.renderSelection();
    return /*#__PURE__*/React.createElement(Popover, {
      getPopupContainer: getPopupContainer,
      motion: motion,
      autoAdjustOverflow: autoAdjustOverflow,
      mouseLeaveDelay: mouseLeaveDelay,
      mouseEnterDelay: mouseEnterDelay,
      // transformFromCenter TODO: check no such property
      zIndex: zIndex,
      ref: this.optionsRef,
      content: optionList,
      visible: isOpen,
      trigger: "custom",
      rePosKey: optionKey,
      position: position,
      spacing: spacing,
      stopPropagation: stopPropagation,
      disableArrowKeyDown: true,
      onVisibleChange: status => this.handlePopoverVisibleChange(status)
    }, selection);
  }

}

Select.contextType = ConfigContext;
Select.Option = Option;
Select.OptGroup = OptionGroup;
Select.propTypes = {
  'aria-describedby': PropTypes.string,
  'aria-errormessage': PropTypes.string,
  'aria-invalid': PropTypes.bool,
  'aria-labelledby': PropTypes.string,
  'aria-required': PropTypes.bool,
  autoFocus: PropTypes.bool,
  autoClearSearchValue: PropTypes.bool,
  children: PropTypes.node,
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array, PropTypes.object]),
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array, PropTypes.object]),
  placeholder: PropTypes.node,
  onChange: PropTypes.func,
  multiple: PropTypes.bool,
  // Whether to turn on the input box filtering function, when it is a function, it represents a custom filtering function
  filter: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  // How many tags can you choose?
  max: PropTypes.number,
  // How many tabs are displayed at most, and the rest are displayed in + N
  maxTagCount: PropTypes.number,
  maxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  style: PropTypes.object,
  className: PropTypes.string,
  size: PropTypes.oneOf(strings.SIZE_SET),
  disabled: PropTypes.bool,
  emptyContent: PropTypes.node,
  onDropdownVisibleChange: PropTypes.func,
  zIndex: PropTypes.number,
  position: PropTypes.oneOf(strings.POSITION_SET),
  onSearch: PropTypes.func,
  getPopupContainer: PropTypes.func,
  dropdownClassName: PropTypes.string,
  dropdownStyle: PropTypes.object,
  outerTopSlot: PropTypes.node,
  innerTopSlot: PropTypes.node,
  inputProps: PropTypes.object,
  outerBottomSlot: PropTypes.node,
  innerBottomSlot: PropTypes.node,
  optionList: PropTypes.array,
  dropdownMatchSelectWidth: PropTypes.bool,
  loading: PropTypes.bool,
  defaultOpen: PropTypes.bool,
  validateStatus: PropTypes.oneOf(strings.STATUS),
  defaultActiveFirstOption: PropTypes.bool,
  triggerRender: PropTypes.func,
  stopPropagation: PropTypes.bool,
  // motion doesn't need to be exposed
  motion: PropTypes.oneOfType([PropTypes.func, PropTypes.bool, PropTypes.object]),
  onChangeWithObject: PropTypes.bool,
  suffix: PropTypes.node,
  prefix: PropTypes.node,
  insetLabel: PropTypes.node,
  insetLabelId: PropTypes.string,
  showClear: PropTypes.bool,
  showArrow: PropTypes.bool,
  renderSelectedItem: PropTypes.func,
  allowCreate: PropTypes.bool,
  renderCreateItem: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  clickToHide: PropTypes.bool,
  onExceed: PropTypes.func,
  onCreate: PropTypes.func,
  remote: PropTypes.bool,
  onDeselect: PropTypes.func,
  // The main difference between onSelect and onChange is that when multiple selections are selected, onChange contains all options, while onSelect only contains items for the current operation
  onSelect: PropTypes.func,
  autoAdjustOverflow: PropTypes.bool,
  mouseEnterDelay: PropTypes.number,
  mouseLeaveDelay: PropTypes.number,
  spacing: PropTypes.number,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  onClear: PropTypes.func,
  virtualize: PropTypes.object,
  renderOptionItem: PropTypes.func,
  onListScroll: PropTypes.func,
  arrowIcon: PropTypes.node,
  preventScroll: PropTypes.bool // open: PropTypes.bool,
  // tagClosable: PropTypes.bool,

};
Select.defaultProps = {
  stopPropagation: true,
  motion: true,
  zIndex: popoverNumbers.DEFAULT_Z_INDEX,
  // position: 'bottomLeft',
  filter: false,
  multiple: false,
  disabled: false,
  defaultOpen: false,
  allowCreate: false,
  placeholder: '',
  onDropdownVisibleChange: _noop,
  onChangeWithObject: false,
  onChange: _noop,
  onSearch: _noop,
  onMouseEnter: _noop,
  onMouseLeave: _noop,
  onDeselect: _noop,
  onSelect: _noop,
  onCreate: _noop,
  onExceed: _noop,
  onFocus: _noop,
  onBlur: _noop,
  onClear: _noop,
  onListScroll: _noop,
  maxHeight: 300,
  dropdownMatchSelectWidth: true,
  defaultActiveFirstOption: true,
  showArrow: true,
  showClear: false,
  remote: false,
  autoAdjustOverflow: true,
  autoClearSearchValue: true,
  arrowIcon: /*#__PURE__*/React.createElement(IconChevronDown, {
    "aria-label": ''
  }) // Radio selection is different from the default renderSelectedItem for multiple selection, so it is not declared here
  // renderSelectedItem: (optionNode) => optionNode.label,
  // The default creator rendering is related to i18, so it is not declared here
  // renderCreateItem: (input) => input

};
export default Select;