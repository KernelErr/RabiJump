import _isUndefined from "lodash/isUndefined";
import _isNull from "lodash/isNull";
import _omit from "lodash/omit";
import _isEqual from "lodash/isEqual";
import _someInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/some";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _Map from "@babel/runtime-corejs3/core-js-stable/map";

/* eslint-disable arrow-body-style */
import React from 'react';
import cls from 'classnames';
import BaseComponent from '../_base/baseComponent';
import PropTypes from 'prop-types';
import { cssClasses, strings } from '@douyinfe/semi-foundation/lib/es/overflowList/constants';
import ResizeObserver from '../resizeObserver';
import IntersectionObserver from './intersectionObserver';
import OverflowListFoundation from '@douyinfe/semi-foundation/lib/es/overflowList/foundation';
import '@douyinfe/semi-foundation/lib/es/overflowList/overflowList.css';
const prefixCls = cssClasses.PREFIX;
const Boundary = strings.BOUNDARY_MAP;
const OverflowDirection = strings.OVERFLOW_DIR;
const RenderMode = strings.MODE_MAP; // reference to https://github.com/palantir/blueprint/blob/1aa71605/packages/core/src/components/overflow-list/overflowList.tsx#L34

class OverflowList extends BaseComponent {
  constructor(props) {
    var _this;

    super(props);
    _this = this;
    this.scroller = null;
    this.spacer = null;

    this.isScrollMode = () => {
      const {
        renderMode
      } = this.props;
      return renderMode === RenderMode.SCROLL;
    };

    this.resize = function () {
      let entries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      // if any parent is growing, assume we have more room than before
      const growing = _someInstanceProperty(entries).call(entries, entry => {
        const previousWidth = _this.previousWidths.get(entry.target) || 0;
        return entry.contentRect.width > previousWidth;
      });

      _this.repartition(growing);

      _forEachInstanceProperty(entries).call(entries, entry => _this.previousWidths.set(entry.target, entry.contentRect.width));
    };

    this.repartition = growing => {
      // if not mounted or scroll mode, we do not
      if (_isNull(this.spacer) || _isUndefined(this.spacer) || this.isScrollMode()) {
        return;
      } // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink


      const state = growing ? OverflowDirection.GROW : this.spacer.getBoundingClientRect().width < 0.9 ? OverflowDirection.SHRINK : OverflowDirection.NONE;
      this.foundation.handlePartition(state);
    };

    this.reintersect = entries => {
      this.foundation.handleIntersect(entries);
    };

    this.mergeRef = (ref, node, key) => {
      this.itemRefs[key] = node;

      if (typeof ref === 'function') {
        ref(node);
      } else if (typeof ref === 'object' && ref && 'current' in ref) {
        ref.current = node;
      }
    };

    this.renderOverflow = () => {
      const overflow = this.foundation.getOverflowItem();
      return this.props.overflowRenderer(overflow);
    };

    this.renderItemList = () => {
      var _context;

      const {
        className,
        wrapperClassName,
        wrapperStyle,
        style,
        visibleItemRenderer,
        renderMode,
        collapseFrom
      } = this.props;
      const {
        visible
      } = this.state;
      const overflow = this.renderOverflow();
      const inner = renderMode === RenderMode.SCROLL ? [overflow[0], /*#__PURE__*/React.createElement("div", {
        className: cls(wrapperClassName, "".concat(prefixCls, "-scroll-wrapper")),
        ref: ref => {
          this.scroller = ref;
        },
        style: _Object$assign({}, wrapperStyle),
        key: "".concat(prefixCls, "-scroll-wrapper")
      }, _mapInstanceProperty(_context = _mapInstanceProperty(visible).call(visible, visibleItemRenderer)).call(_context, (item, ind) => {
        const {
          forwardRef,
          key
        } = item;
        return /*#__PURE__*/React.cloneElement(item, {
          ref: node => this.mergeRef(forwardRef, node, key),
          'data-scrollkey': "".concat(key),
          key
        });
      })), overflow[1]] : [collapseFrom === Boundary.START ? overflow : null, _mapInstanceProperty(visible).call(visible, visibleItemRenderer), collapseFrom === Boundary.END ? overflow : null, /*#__PURE__*/React.createElement("div", {
        className: "".concat(prefixCls, "-spacer"),
        ref: ref => this.spacer = ref,
        key: "".concat(prefixCls, "-spacer")
      })];
      const list = /*#__PURE__*/React.createElement('div', {
        className: cls("".concat(prefixCls), className),
        style
      }, ...inner);
      return list;
    };

    this.state = {
      direction: OverflowDirection.GROW,
      lastOverflowCount: 0,
      overflow: [],
      visible: props.items,
      visibleState: new _Map()
    };
    this.foundation = new OverflowListFoundation(this.adapter);
    this.previousWidths = new _Map();
    this.itemRefs = {};
    this.itemSizeMap = new _Map();
  }

  static getDerivedStateFromProps(props, prevState) {
    const {
      prevProps
    } = prevState;
    const newState = {};
    newState.prevProps = props;

    const needUpdate = name => {
      return !prevProps && name in props || prevProps && !_isEqual(prevProps[name], props[name]);
    };

    if (needUpdate('items') || needUpdate('style')) {
      // reset visible state if the above props change.
      newState.direction = OverflowDirection.GROW;
      newState.lastOverflowCount = 0;
      newState.overflow = [];
      newState.visible = props.items;
    }

    return newState;
  }

  get adapter() {
    return _Object$assign(_Object$assign({}, super.adapter), {
      updateVisibleState: visibleState => {
        this.setState({
          visibleState
        });
      },
      updateStates: states => {
        this.setState(_Object$assign({}, states));
      },
      notifyIntersect: res => {
        this.props.onIntersect && this.props.onIntersect(res);
      }
    });
  }

  componentDidMount() {
    this.repartition(false);
  }

  shouldComponentUpdate(_nextProps, nextState) {
    // We want this component to always re-render, even when props haven't changed, so that
    // changes in the renderers' behavior can be reflected.
    // The following statement prevents re-rendering only in the case where the state changes
    // identity (i.e. setState was called), but the state is still the same when
    // shallow-compared to the previous state.
    const currState = _omit(this.state, 'prevProps');

    const comingState = _omit(nextState, 'prevProps');

    return !(currState !== comingState && _isEqual(currState, comingState));
  }

  componentDidUpdate(prevProps, prevState) {
    if (!_isEqual(prevProps.items, this.props.items)) {
      this.itemRefs = {};
    }

    if (!_isEqual(_omit(prevState, 'prevProps'), _omit(this.state, 'prevProps'))) {
      this.repartition(false);
    }

    const {
      direction,
      overflow,
      lastOverflowCount
    } = this.state;

    if ( // if a resize operation has just completed (transition to NONE)
    direction === OverflowDirection.NONE && direction !== prevState.direction && overflow.length !== lastOverflowCount) {
      this.props.onOverflow && this.props.onOverflow(overflow);
    }
  }

  render() {
    const list = this.renderItemList();
    const {
      renderMode
    } = this.props;

    if (renderMode === RenderMode.SCROLL) {
      return /*#__PURE__*/React.createElement(IntersectionObserver, {
        onIntersect: this.reintersect,
        root: this.scroller,
        threshold: this.props.threshold,
        items: this.itemRefs
      }, list);
    }

    return /*#__PURE__*/React.createElement(ResizeObserver, {
      onResize: this.resize
    }, list);
  }

}

OverflowList.defaultProps = {
  collapseFrom: 'end',
  minVisibleItems: 0,
  overflowRenderer: () => null,
  renderMode: 'collapse',
  threshold: 0.75,
  visibleItemRenderer: () => null
};
OverflowList.propTypes = {
  // if render in scroll mode, key is required in items
  className: PropTypes.string,
  collapseFrom: PropTypes.oneOf(strings.BOUNDARY_SET),
  direction: PropTypes.oneOf(strings.POSITION_SET),
  items: PropTypes.array,
  minVisibleItems: PropTypes.number,
  onIntersect: PropTypes.func,
  onOverflow: PropTypes.func,
  overflowRenderer: PropTypes.func,
  renderMode: PropTypes.oneOf(strings.MODE_SET),
  style: PropTypes.object,
  threshold: PropTypes.number,
  visibleItemRenderer: PropTypes.func,
  wrapperClassName: PropTypes.string,
  wrapperStyle: PropTypes.object
};
export default OverflowList;