import _sliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/slice";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import ReactDOM from 'react-dom';
import React from 'react';
/**
 * The logic of JS for text truncation is referenced from antd typography
 * https://github.com/ant-design/ant-design/blob/master/components/typography/util.tsx
 *
 * For more thinking and analysis about this function, please refer to Feishu document
 * https://bytedance.feishu.cn/docs/doccnqovjjyoKm2U5O13bj30aTh
 */

let ellipsisContainer;

function pxToNumber(value) {
  if (!value) {
    return 0;
  }

  const match = value.match(/^\d*(\.\d*)?/);
  return match ? Number(match[0]) : 0;
}

function styleToString(style) {
  // There are some different behavior between Firefox & Chrome.
  // We have to handle this ourself.
  const styleNames = _sliceInstanceProperty(Array.prototype).apply(style);

  return _mapInstanceProperty(styleNames).call(styleNames, name => {
    var _context;

    return _concatInstanceProperty(_context = "".concat(name, ": ")).call(_context, style.getPropertyValue(name), ";");
  }).join('');
}

const getRenderText = function (originEle, rows) {
  let content = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  let fixedContent = arguments.length > 3 ? arguments[3] : undefined;
  let ellipsisStr = arguments.length > 4 ? arguments[4] : undefined;
  let suffix = arguments.length > 5 ? arguments[5] : undefined;
  let ellipsisPos // eslint-disable-next-line max-params
  = arguments.length > 6 ? arguments[6] : undefined;

  if (!ellipsisContainer) {
    ellipsisContainer = document.createElement('div');
    ellipsisContainer.setAttribute('aria-hidden', 'true');
    document.body.appendChild(ellipsisContainer);
  } // Get origin style


  const originStyle = window.getComputedStyle(originEle);
  const originCSS = styleToString(originStyle);
  const lineHeight = pxToNumber(originStyle.lineHeight);
  const maxHeight = Math.round(lineHeight * (rows + 1) + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom)); // Set shadow

  ellipsisContainer.setAttribute('style', originCSS);
  ellipsisContainer.style.position = 'fixed';
  ellipsisContainer.style.left = '0';
  ellipsisContainer.style.height = 'auto';
  ellipsisContainer.style.top = '-999999px';
  ellipsisContainer.style.zIndex = '-1000'; // clean up css overflow

  ellipsisContainer.style.textOverflow = 'clip';
  ellipsisContainer.style.webkitLineClamp = 'none'; // Render fake container

  ReactDOM.render( /*#__PURE__*/React.createElement(React.Fragment, null), ellipsisContainer); // Check if ellipsis in measure div is height enough for content

  function inRange() {
    // console.log('inrange?', ellipsisContainer.scrollHeight, ellipsisContainer.scrollHeight < maxHeight)
    return ellipsisContainer.scrollHeight < maxHeight;
  } // ========================= Find match ellipsis content =========================
  // Create origin content holder


  const ellipsisContentHolder = document.createElement('span');
  const ellipsisTextNode = document.createTextNode(suffix);
  ellipsisContentHolder.appendChild(ellipsisTextNode);
  ellipsisContainer.appendChild(ellipsisContentHolder);

  _mapInstanceProperty(fixedContent).call(fixedContent, node => node && ellipsisContainer.appendChild(node.cloneNode(true))); // Append before fixed nodes


  function appendChildNode(node) {
    ellipsisContentHolder.insertBefore(node, ellipsisTextNode);
  }

  function getCurrentText(text, pos) {
    const end = text.length;

    if (!pos) {
      return ellipsisStr;
    }

    if (ellipsisPos === 'end' || pos > end - pos) {
      return _sliceInstanceProperty(text).call(text, 0, pos) + ellipsisStr;
    }

    return _sliceInstanceProperty(text).call(text, 0, pos) + ellipsisStr + _sliceInstanceProperty(text).call(text, end - pos, end);
  } // Get maximum text


  function measureText(textNode, fullText) {
    let startLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let endLoc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : fullText.length;
    let lastSuccessLoc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    const midLoc = Math.floor((startLoc + endLoc) / 2);
    const currentText = getCurrentText(fullText, midLoc);
    textNode.textContent = currentText; // console.log('calculating....', currentText);

    if (startLoc >= endLoc - 1 && endLoc > 0) {
      // Loop when step is small
      for (let step = endLoc; step >= startLoc; step -= 1) {
        const currentStepText = getCurrentText(fullText, step);
        textNode.textContent = currentStepText;

        if (inRange() || !currentStepText) {
          return step === fullText.length ? fullText : currentStepText;
        }
      }
    } else if (endLoc === 0) {
      return ellipsisStr;
    }

    if (inRange()) {
      return measureText(textNode, fullText, midLoc, endLoc, midLoc);
    }

    return measureText(textNode, fullText, startLoc, midLoc, lastSuccessLoc);
  }

  const textNode = document.createTextNode(content);
  appendChildNode(textNode);
  const resText = measureText(textNode, content);
  ellipsisContainer.innerHTML = '';
  return resText;
};

export default getRenderText;