import _isString from "lodash/isString";
import _merge from "lodash/merge";
import _omit from "lodash/omit";
import _isUndefined from "lodash/isUndefined";
import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && _indexOfInstanceProperty(e).call(e, p) < 0) t[p] = s[p];

  if (s != null && typeof _Object$getOwnPropertySymbols === "function") for (var i = 0, p = _Object$getOwnPropertySymbols(s); i < p.length; i++) {
    if (_indexOfInstanceProperty(e).call(e, p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import cls from 'classnames';
import PropTypes from 'prop-types';
import { cssClasses, strings } from '@douyinfe/semi-foundation/lib/es/typography/constants';
import Typography from './typography';
import Copyable from './copyable';
import Tooltip from '../tooltip/index';
import Popover from '../popover/index';
import getRenderText from './util';
import warning from '@douyinfe/semi-foundation/lib/es/utils/warning';
import isEnterPress from '@douyinfe/semi-foundation/lib/es/utils/isEnterPress';
import LocaleConsumer from '../locale/localeConsumer';
import { isSemiIcon } from '../_utils';
const prefixCls = cssClasses.PREFIX;
const ELLIPSIS_STR = '...';

const wrapperDecorations = (props, content) => {
  const {
    mark,
    code,
    underline,
    strong,
    link,
    disabled
  } = props;
  let wrapped = content;

  const wrap = (isNeeded, tag) => {
    let wrapProps = {};

    if (!isNeeded) {
      return;
    }

    if (typeof isNeeded === 'object') {
      wrapProps = _Object$assign({}, isNeeded);
    }

    wrapped = /*#__PURE__*/React.createElement(tag, wrapProps, wrapped);
  };

  wrap(mark, 'mark');
  wrap(code, 'code');
  wrap(underline && !link, 'u');
  wrap(strong, 'strong');
  wrap(props.delete, 'del');
  wrap(link, disabled ? 'span' : 'a');
  return wrapped;
};

export default class Base extends Component {
  constructor(props) {
    super(props);

    this.onResize = () => {
      var _context;

      if (this.rafId) {
        window.cancelAnimationFrame(this.rafId);
      }

      this.rafId = window.requestAnimationFrame(_bindInstanceProperty(_context = this.getEllipsisState).call(_context, this));
    }; // if need to use js overflowed:
    // 1. text is expandable 2. expandText need to be shown  3. has extra operation 4. text need to ellipse from mid


    this.canUseCSSEllipsis = () => {
      const {
        copyable
      } = this.props;
      const {
        expandable,
        expandText,
        pos,
        suffix
      } = this.getEllipsisOpt();
      return !expandable && _isUndefined(expandText) && !copyable && pos === 'end' && !suffix.length;
    };
    /**
     * whether truncated
     *  rows < = 1 if there is overflow content, return true
     *  rows > 1 if there is overflow height, return true
     * @param {Number} rows
     * @returns {Boolean}
     */


    this.shouldTruncated = rows => {
      if (!rows || rows < 1) {
        return false;
      }

      const updateOverflow = rows <= 1 ? this.wrapperRef.current.scrollWidth > this.wrapperRef.current.clientWidth : this.wrapperRef.current.scrollHeight > this.wrapperRef.current.offsetHeight;
      return updateOverflow;
    };

    this.showTooltip = () => {
      const {
        isOverflowed,
        isTruncated,
        expanded
      } = this.state;
      const {
        showTooltip,
        expandable,
        expandText
      } = this.getEllipsisOpt();
      const overflowed = !expanded && (isOverflowed || isTruncated);

      const noExpandText = !expandable && _isUndefined(expandText);

      const show = noExpandText && overflowed && showTooltip;

      if (!show) {
        return show;
      }

      const defaultOpts = {
        type: 'tooltip',
        opts: {}
      };

      if (typeof showTooltip === 'object') {
        if (showTooltip.type && showTooltip.type.toLowerCase() === 'popover') {
          return _merge({
            opts: {
              style: {
                width: '240px'
              },
              showArrow: true
            }
          }, showTooltip);
        }

        return _Object$assign(_Object$assign({}, defaultOpts), showTooltip);
      }

      return defaultOpts;
    };
    /**
     * Triggered when the fold button is clicked to save the latest expanded state
     * @param {Event} e
     */


    this.toggleOverflow = e => {
      const {
        onExpand,
        expandable,
        collapsible
      } = this.getEllipsisOpt();
      const {
        expanded
      } = this.state;
      onExpand && onExpand(!expanded, e);

      if (expandable && !expanded || collapsible && expanded) {
        this.setState({
          expanded: !expanded,
          first: false
        });
      }
    };

    this.getEllipsisOpt = () => {
      const {
        ellipsis
      } = this.props;

      if (!ellipsis) {
        return {};
      }

      const opt = _Object$assign({
        rows: 1,
        expandable: false,
        pos: 'end',
        suffix: '',
        showTooltip: false,
        collapsible: false,
        expandText: ellipsis.expandable ? this.expandStr : undefined,
        collapseText: ellipsis.collapsible ? this.collapseStr : undefined
      }, typeof ellipsis === 'object' ? ellipsis : null);

      return opt;
    };

    this.renderExpandable = () => {
      const {
        expandText,
        expandable,
        collapseText,
        collapsible
      } = this.getEllipsisOpt();
      const {
        expanded,
        first
      } = this.state;

      const noExpandText = !expandable && _isUndefined(expandText);

      const noCollapseText = !collapsible && _isUndefined(collapseText);

      let text;

      if (!expanded && !noExpandText) {
        text = expandText;
      } else if (expanded && !first && !noCollapseText) {
        // if expanded is true but the text is initally mounted, we dont show collapseText
        text = collapseText;
      }

      if (!noExpandText || !noCollapseText) {
        return (
          /*#__PURE__*/
          // TODO: replace `a` tag with `span` in next major version
          // NOTE: may have effect on style
          // eslint-disable-next-line jsx-a11y/anchor-is-valid
          React.createElement("a", {
            role: "button",
            tabIndex: 0,
            className: "".concat(prefixCls, "-ellipsis-expand"),
            key: "expand",
            ref: this.expandRef,
            "aria-label": text,
            onClick: this.toggleOverflow,
            onKeyPress: e => isEnterPress(e) && this.toggleOverflow(e)
          }, text)
        );
      }

      return null;
    };
    /**
     * 获取文本的缩略class和style
     *
     * 截断类型：
     *  - CSS 截断，仅在 rows=1 且没有 expandable、pos、suffix 时生效
     *  - JS 截断，应对 CSS 无法阶段的场景
     * 相关变量
     *  props:
     *      - ellipsis:
     *          - rows
     *          - expandable
     *          - pos
     *          - suffix
     *  state:
     *      - isOverflowed，文本是否处于overflow状态
     *      - expanded，文本是否处于折叠状态
     *      - isTruncated，文本是否被js截断
     *
     * Get the abbreviated class and style of the text
     *
     * Truncation type:
     *  -CSS truncation, which only takes effect when rows = 1 and there is no expandable, pos, suffix
     *  -JS truncation, dealing with scenarios where CSS cannot stage
     * related variables
     *  props:
     *      -ellipsis:
     *          -rows
     *          -expandable
     *          -pos
     *          -suffix
     *  state:
     *      -isOverflowed, whether the text is in an overflow state
     *      -expanded, whether the text is in a collapsed state
     *      -isTruncated, whether the text is truncated by js
     * @returns {Object}
     */


    this.getEllipsisStyle = () => {
      const {
        ellipsis
      } = this.props;
      const {
        expandable
      } = this.getEllipsisOpt();

      if (!ellipsis) {
        return {
          ellipsisCls: '',
          ellipsisStyle: {} // ellipsisAttr: {}

        };
      }

      const {
        rows
      } = this.getEllipsisOpt();
      const {
        isOverflowed,
        expanded,
        isTruncated
      } = this.state;
      const useCSS = !expanded && this.canUseCSSEllipsis();
      const ellipsisCls = cls({
        ["".concat(prefixCls, "-ellipsis")]: true,
        ["".concat(prefixCls, "-ellipsis-single-line")]: rows === 1,
        ["".concat(prefixCls, "-ellipsis-multiple-line")]: rows > 1,
        ["".concat(prefixCls, "-ellipsis-overflow-ellipsis")]: rows === 1 && useCSS
      });
      const ellipsisStyle = useCSS && rows > 1 ? {
        WebkitLineClamp: rows
      } : {};
      return {
        ellipsisCls,
        ellipsisStyle: isOverflowed ? ellipsisStyle : {}
      };
    };

    this.renderEllipsisText = opt => {
      const {
        suffix
      } = opt;
      const {
        children
      } = this.props;
      const {
        isTruncated,
        expanded,
        isOverflowed,
        ellipsisContent
      } = this.state;

      if (expanded || !isTruncated) {
        return /*#__PURE__*/React.createElement(React.Fragment, null, children, suffix && suffix.length ? suffix : null);
      }

      return /*#__PURE__*/React.createElement("span", null, ellipsisContent, suffix);
    };

    this.state = {
      editable: false,
      copied: false,
      // ellipsis
      // if text is overflow in container
      isOverflowed: true,
      ellipsisContent: null,
      expanded: false,
      // if text is truncated with js
      isTruncated: false,
      // record if has click expanded
      first: true,
      prevChildren: null
    };
    this.wrapperRef = /*#__PURE__*/React.createRef();
    this.expandRef = /*#__PURE__*/React.createRef();
    this.copyRef = /*#__PURE__*/React.createRef();
  }

  componentDidMount() {
    if (this.props.ellipsis) {
      this.getEllipsisState();
      window.addEventListener('resize', this.onResize);
    }
  }

  static getDerivedStateFromProps(props, prevState) {
    const {
      prevChildren
    } = prevState;
    const newState = {};
    newState.prevChildren = props.children;

    if (props.ellipsis && prevChildren !== props.children) {
      // reset ellipsis state if children update
      newState.isOverflowed = true;
      newState.ellipsisContent = null;
      newState.expanded = false;
      newState.isTruncated = false;
      newState.first = true;
    }

    return newState;
  }

  componentDidUpdate(prevProps) {
    // Render was based on outdated refs and needs to be rerun
    if (this.props.children !== prevProps.children) {
      this.forceUpdate();

      if (this.props.ellipsis) {
        this.getEllipsisState();
      }
    }
  }

  componentWillUnmount() {
    if (this.props.ellipsis) {
      window.removeEventListener('resize', this.onResize);
    }

    if (this.rafId) {
      window.cancelAnimationFrame(this.rafId);
    }
  }

  getEllipsisState() {
    const {
      rows,
      suffix,
      pos
    } = this.getEllipsisOpt();
    const {
      children
    } = this.props; // wait until element mounted

    if (!this.wrapperRef || !this.wrapperRef.current) {
      this.onResize();
      return false;
    }

    const {
      ellipsisContent,
      isOverflowed,
      isTruncated,
      expanded
    } = this.state;
    const updateOverflow = this.shouldTruncated(rows);
    const canUseCSSEllipsis = this.canUseCSSEllipsis();
    const needUpdate = updateOverflow !== isOverflowed;

    if (!rows || rows < 0 || expanded) {
      return undefined;
    }

    if (canUseCSSEllipsis) {
      if (needUpdate) {
        this.setState({
          expanded: !updateOverflow
        });
      }

      return undefined;
    }

    const extraNode = [this.expandRef.current, this.copyRef && this.copyRef.current];
    warning('children' in this.props && typeof children !== 'string', "[Semi Typography] 'Only children with pure text could be used with ellipsis at this moment.");
    const content = getRenderText(ReactDOM.findDOMNode(this.wrapperRef.current), rows, children, extraNode, ELLIPSIS_STR, suffix, pos);

    if (children === content) {
      this.setState({
        expanded: true
      });
    } else if (ellipsisContent !== content || isOverflowed !== updateOverflow) {
      this.setState({
        ellipsisContent: content,
        isOverflowed: updateOverflow,
        isTruncated: children !== content
      });
    }

    return undefined;
  }

  renderOperations() {
    return /*#__PURE__*/React.createElement(React.Fragment, null, this.renderExpandable(), this.renderCopy());
  }

  renderCopy() {
    const {
      copyable,
      children
    } = this.props;

    if (!copyable) {
      return null;
    }

    let copyContent;
    let hasObject = false;

    if (_Array$isArray(children)) {
      copyContent = '';

      _forEachInstanceProperty(children).call(children, value => {
        if (typeof value === 'object') {
          hasObject = true;
        }

        copyContent += String(value);
      });
    } else if (typeof children !== 'object') {
      copyContent = String(children);
    } else {
      hasObject = true;
      copyContent = String(children);
    }

    warning(hasObject, 'Children in Typography is a object, it will case a [object Object] mistake when copy to clipboard.');

    const copyConfig = _Object$assign({
      content: copyContent,
      duration: 3
    }, typeof copyable === 'object' ? copyable : null);

    return /*#__PURE__*/React.createElement(Copyable, _Object$assign({}, copyConfig, {
      forwardRef: this.copyRef
    }));
  }

  renderIcon() {
    const {
      icon,
      size
    } = this.props;

    if (!icon) {
      return null;
    }

    const iconSize = size === 'small' ? 'small' : 'default';
    return /*#__PURE__*/React.createElement("span", {
      className: "".concat(prefixCls, "-icon"),
      "x-semi-prop": "icon"
    }, isSemiIcon(icon) ? /*#__PURE__*/React.cloneElement(icon, {
      size: iconSize
    }) : icon);
  }

  renderContent() {
    var _context2, _context3, _context4, _context5;

    const _a = this.props,
          {
      component,
      children,
      className,
      type,
      spacing,
      disabled,
      style,
      ellipsis,
      icon,
      size,
      link,
      heading
    } = _a,
          rest = __rest(_a, ["component", "children", "className", "type", "spacing", "disabled", "style", "ellipsis", "icon", "size", "link", "heading"]);

    const textProps = _omit(rest, ['strong', 'editable', 'mark', 'copyable', 'underline', 'code', // 'link',
    'delete']);

    const iconNode = this.renderIcon();
    const ellipsisOpt = this.getEllipsisOpt();
    const {
      ellipsisCls,
      ellipsisStyle
    } = this.getEllipsisStyle();
    let textNode = ellipsis ? this.renderEllipsisText(ellipsisOpt) : children;
    const linkCls = cls({
      ["".concat(prefixCls, "-link-text")]: link,
      ["".concat(prefixCls, "-link-underline")]: this.props.underline && link
    });
    textNode = wrapperDecorations(this.props, /*#__PURE__*/React.createElement(React.Fragment, null, iconNode, this.props.link ? /*#__PURE__*/React.createElement("span", {
      className: linkCls
    }, textNode) : textNode));
    const hTagReg = /^h[1-6]$/;
    const wrapperCls = cls(className, ellipsisCls, {
      // [`${prefixCls}-primary`]: !type || type === 'primary',
      [_concatInstanceProperty(_context2 = "".concat(prefixCls, "-")).call(_context2, type)]: type && !link,
      [_concatInstanceProperty(_context3 = "".concat(prefixCls, "-")).call(_context3, size)]: size,
      ["".concat(prefixCls, "-link")]: link,
      ["".concat(prefixCls, "-disabled")]: disabled,
      [_concatInstanceProperty(_context4 = "".concat(prefixCls, "-")).call(_context4, spacing)]: spacing,
      [_concatInstanceProperty(_context5 = "".concat(prefixCls, "-")).call(_context5, heading)]: _isString(heading) && hTagReg.test(heading)
    });
    return /*#__PURE__*/React.createElement(Typography, _Object$assign({
      className: wrapperCls,
      style: _Object$assign(_Object$assign({}, style), ellipsisStyle),
      component: component,
      forwardRef: this.wrapperRef
    }, textProps), textNode, this.renderOperations());
  }

  renderTipWrapper() {
    const {
      children
    } = this.props;
    const showTooltip = this.showTooltip();
    const content = this.renderContent();

    if (showTooltip) {
      const {
        type,
        opts
      } = showTooltip;

      if (type.toLowerCase() === 'popover') {
        return /*#__PURE__*/React.createElement(Popover, _Object$assign({
          content: children,
          position: "top"
        }, opts), content);
      }

      return /*#__PURE__*/React.createElement(Tooltip, _Object$assign({
        content: children,
        position: "top"
      }, opts), content);
    } else {
      return content;
    }
  }

  render() {
    return /*#__PURE__*/React.createElement(LocaleConsumer, {
      componentName: "Typography"
    }, locale => {
      this.expandStr = locale.expand;
      this.collapseStr = locale.collapse;
      return this.renderTipWrapper();
    });
  }

}
Base.propTypes = {
  children: PropTypes.node,
  copyable: PropTypes.oneOfType([PropTypes.shape({
    text: PropTypes.string,
    onCopy: PropTypes.func,
    successTip: PropTypes.node,
    copyTip: PropTypes.node
  }), PropTypes.bool]),
  delete: PropTypes.bool,
  disabled: PropTypes.bool,
  // editable: PropTypes.bool,
  ellipsis: PropTypes.oneOfType([PropTypes.shape({
    rows: PropTypes.number,
    expandable: PropTypes.bool,
    expandText: PropTypes.string,
    onExpand: PropTypes.func,
    suffix: PropTypes.string,
    showTooltip: PropTypes.oneOfType([PropTypes.shape({
      type: PropTypes.string,
      opts: PropTypes.object
    }), PropTypes.bool]),
    collapsible: PropTypes.bool,
    collapseText: PropTypes.string,
    pos: PropTypes.oneOf(['end', 'middle'])
  }), PropTypes.bool]),
  mark: PropTypes.bool,
  underline: PropTypes.bool,
  link: PropTypes.oneOfType([PropTypes.object, PropTypes.bool]),
  spacing: PropTypes.oneOf(strings.SPACING),
  strong: PropTypes.bool,
  size: PropTypes.oneOf(strings.SIZE),
  type: PropTypes.oneOf(strings.TYPE),
  style: PropTypes.object,
  className: PropTypes.string,
  icon: PropTypes.oneOfType([PropTypes.node, PropTypes.string]),
  heading: PropTypes.string,
  component: PropTypes.string
};
Base.defaultProps = {
  children: null,
  copyable: false,
  delete: false,
  disabled: false,
  // editable: false,
  ellipsis: false,
  icon: '',
  mark: false,
  underline: false,
  strong: false,
  link: false,
  type: 'primary',
  spacing: 'normal',
  size: 'normal',
  style: {},
  className: ''
};