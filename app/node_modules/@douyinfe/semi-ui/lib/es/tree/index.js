import _isFunction from "lodash/isFunction";
import _get from "lodash/get";
import _isEqual from "lodash/isEqual";
import _isEmpty from "lodash/isEmpty";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _Set from "@babel/runtime-corejs3/core-js-stable/set";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _Array$from from "@babel/runtime-corejs3/core-js-stable/array/from";

/* eslint-disable max-lines-per-function */
import React from 'react';
import cls from 'classnames';
import PropTypes from 'prop-types';
import ConfigContext from '../configProvider/context';
import TreeFoundation from '@douyinfe/semi-foundation/lib/es/tree/foundation';
import { convertDataToEntities, flattenTreeData, calcExpandedKeysForValues, calcMotionKeys, convertJsonToData, findKeysForValues, calcCheckedKeys, calcExpandedKeys, filterTreeData, normalizeValue, updateKeys, calcDisabledKeys } from '@douyinfe/semi-foundation/lib/es/tree/treeUtil';
import { cssClasses, strings } from '@douyinfe/semi-foundation/lib/es/tree/constants';
import BaseComponent from '../_base/baseComponent';
import { cloneDeep } from './treeUtil';
import Input from '../input/index';
import { FixedSizeList as VirtualList } from 'react-window';
import AutoSizer from './autoSizer';
import TreeContext from './treeContext';
import TreeNode from './treeNode';
import NodeList from './nodeList';
import LocaleConsumer from '../locale/localeConsumer';
import '@douyinfe/semi-foundation/lib/es/tree/tree.css';
import { IconSearch } from '@douyinfe/semi-icons';
import CheckboxGroup from '../checkbox/checkboxGroup';
export * from './interface';
const prefixcls = cssClasses.PREFIX;

class Tree extends BaseComponent {
  constructor(props) {
    super(props);

    this.search = value => {
      this.foundation.handleInputChange(value);
    };

    this.renderEmpty = () => {
      const {
        emptyContent
      } = this.props;

      if (emptyContent) {
        return /*#__PURE__*/React.createElement(TreeNode, {
          empty: true,
          emptyContent: this.props.emptyContent
        });
      } else {
        return /*#__PURE__*/React.createElement(LocaleConsumer, {
          componentName: "Tree"
        }, locale => /*#__PURE__*/React.createElement(TreeNode, {
          empty: true,
          emptyContent: _get(locale, 'emptyText')
        }));
      }
    };

    this.onNodeSelect = (e, treeNode) => {
      this.foundation.handleNodeSelect(e, treeNode);
    };

    this.onNodeLoad = data => new _Promise(resolve => {
      // We need to get the latest state of loading/loaded keys
      this.setState(_ref => {
        let {
          loadedKeys = new _Set([]),
          loadingKeys = new _Set([])
        } = _ref;
        return this.foundation.handleNodeLoad(loadedKeys, loadingKeys, data, resolve);
      });
    });

    this.onNodeCheck = (e, treeNode) => {
      this.foundation.handleNodeSelect(e, treeNode);
    };

    this.onNodeExpand = (e, treeNode) => {
      this.foundation.handleNodeExpand(e, treeNode);
    };

    this.onNodeRightClick = (e, treeNode) => {
      this.foundation.handleNodeRightClick(e, treeNode);
    };

    this.onNodeDoubleClick = (e, treeNode) => {
      this.foundation.handleNodeDoubleClick(e, treeNode);
    };

    this.onNodeDragStart = (e, treeNode) => {
      this.foundation.handleNodeDragStart(e, treeNode);
    };

    this.onNodeDragEnter = (e, treeNode) => {
      this.foundation.handleNodeDragEnter(e, treeNode, this.dragNode);
    };

    this.onNodeDragOver = (e, treeNode) => {
      this.foundation.handleNodeDragOver(e, treeNode, this.dragNode);
    };

    this.onNodeDragLeave = (e, treeNode) => {
      this.foundation.handleNodeDragLeave(e, treeNode);
    };

    this.onNodeDragEnd = (e, treeNode) => {
      this.foundation.handleNodeDragEnd(e, treeNode);
    };

    this.onNodeDrop = (e, treeNode) => {
      this.foundation.handleNodeDrop(e, treeNode, this.dragNode);
    };

    this.getTreeNodeRequiredProps = () => {
      const {
        expandedKeys,
        selectedKeys,
        checkedKeys,
        halfCheckedKeys,
        keyEntities,
        filteredKeys
      } = this.state;
      return {
        expandedKeys: expandedKeys || new _Set(),
        selectedKeys: selectedKeys || [],
        checkedKeys: checkedKeys || new _Set(),
        halfCheckedKeys: halfCheckedKeys || new _Set(),
        filteredKeys: filteredKeys || new _Set(),
        keyEntities
      };
    };

    this.getTreeNodeKey = treeNode => {
      const {
        data
      } = treeNode;
      const {
        key
      } = data;
      return key;
    };

    this.renderTreeNode = (treeNode, ind, style) => {
      const {
        data
      } = treeNode;
      const {
        key
      } = data;
      const treeNodeProps = this.foundation.getTreeNodeProps(key);

      if (!treeNodeProps) {
        return null;
      }

      return /*#__PURE__*/React.createElement(TreeNode, _Object$assign({}, treeNodeProps, data, {
        key: key,
        data: data,
        style: _isEmpty(style) ? {} : style
      }));
    };

    this.itemKey = (index, data) => {
      // Find the item at the specified index.
      const item = data[index]; // Return a value that uniquely identifies this item.

      return item.key;
    };

    this.state = {
      inputValue: '',
      keyEntities: {},
      treeData: [],
      flattenNodes: [],
      selectedKeys: [],
      checkedKeys: new _Set(),
      halfCheckedKeys: new _Set(),
      realCheckedKeys: new _Set([]),
      motionKeys: new _Set([]),
      motionType: 'hide',
      expandedKeys: new _Set(props.expandedKeys),
      filteredKeys: new _Set(),
      filteredExpandedKeys: new _Set(),
      filteredShownKeys: new _Set(),
      prevProps: null,
      loadedKeys: new _Set(),
      loadingKeys: new _Set(),
      cachedFlattenNodes: undefined,
      cachedKeyValuePairs: {},
      disabledKeys: new _Set(),
      dragging: false,
      dragNodesKeys: new _Set(),
      dragOverNodeKey: null,
      dropPosition: null
    };
    this.inputRef = /*#__PURE__*/React.createRef();
    this.optionsRef = /*#__PURE__*/React.createRef();
    this.foundation = new TreeFoundation(this.adapter);
    this.dragNode = null;
  }
  /**
   * Process of getDerivedStateFromProps was inspired by rc-tree
   * https://github.com/react-component/tree
   */


  static getDerivedStateFromProps(props, prevState) {
    const {
      prevProps
    } = prevState;
    let treeData;
    let keyEntities = prevState.keyEntities || {};
    let valueEntities = prevState.cachedKeyValuePairs || {};
    const isSeaching = Boolean(props.filterTreeNode && prevState.inputValue && prevState.inputValue.length);
    const newState = {
      prevProps: props
    };
    const isExpandControlled = ('expandedKeys' in props); // Accept a props field as a parameter to determine whether to update the field

    const needUpdate = name => {
      const firstInProps = !prevProps && name in props;
      const nameHasChange = prevProps && !_isEqual(prevProps[name], props[name]);
      return firstInProps || nameHasChange;
    }; // Determine whether treeData has changed


    const needUpdateData = () => {
      const firstInProps = !prevProps && 'treeData' in props;
      const treeDataHasChange = prevProps && prevProps.treeData !== props.treeData;
      return firstInProps || treeDataHasChange;
    }; // Update the data of tree in state


    if (needUpdate('treeData') || props.draggable && needUpdateData()) {
      // eslint-disable-next-line prefer-destructuring
      treeData = props.treeData;
      newState.treeData = treeData;
      const entitiesMap = convertDataToEntities(treeData);
      newState.keyEntities = _Object$assign({}, entitiesMap.keyEntities);
      keyEntities = newState.keyEntities;
      newState.cachedKeyValuePairs = _Object$assign({}, entitiesMap.valueEntities);
      valueEntities = newState.cachedKeyValuePairs;
    } else if (needUpdate('treeDataSimpleJson')) {
      // Convert treeDataSimpleJson to treeData
      treeData = convertJsonToData(props.treeDataSimpleJson);
      newState.treeData = treeData;
      const entitiesMap = convertDataToEntities(treeData);
      newState.keyEntities = _Object$assign({}, entitiesMap.keyEntities);
      keyEntities = newState.keyEntities;
      newState.cachedKeyValuePairs = _Object$assign({}, entitiesMap.valueEntities);
      valueEntities = newState.cachedKeyValuePairs;
    } // If treeData keys changes, we won't show animation


    if (treeData && props.motion) {
      if (prevProps && props.motion) {
        newState.motionKeys = new _Set([]);
        newState.motionType = null;
      }
    }

    const dataUpdated = needUpdate('treeDataSimpleJson') || needUpdate('treeData');
    const expandAllWhenDataChange = dataUpdated && props.expandAll;

    if (!isSeaching) {
      // Update expandedKeys
      if (needUpdate('expandedKeys') || prevProps && needUpdate('autoExpandParent')) {
        newState.expandedKeys = calcExpandedKeys(props.expandedKeys, keyEntities, props.autoExpandParent || !prevProps); // only show animation when treeData does not change

        if (prevProps && props.motion && !treeData) {
          const {
            motionKeys,
            motionType
          } = calcMotionKeys(prevState.expandedKeys, newState.expandedKeys, keyEntities);
          newState.motionKeys = new _Set(motionKeys);
          newState.motionType = motionType;

          if (motionType === 'hide') {
            // cache flatten nodes: expandedKeys changed may not be triggered by interaction
            newState.cachedFlattenNodes = cloneDeep(prevState.flattenNodes);
          }
        }
      } else if (!prevProps && (props.defaultExpandAll || props.expandAll) || expandAllWhenDataChange) {
        newState.expandedKeys = new _Set(_Object$keys(keyEntities));
      } else if (!prevProps && props.defaultExpandedKeys) {
        newState.expandedKeys = calcExpandedKeys(props.defaultExpandedKeys, keyEntities);
      } else if (!prevProps && props.defaultValue) {
        newState.expandedKeys = calcExpandedKeysForValues(props.defaultValue, keyEntities, props.multiple, valueEntities);
      } else if ((!prevProps || !isExpandControlled && dataUpdated) && props.value) {
        newState.expandedKeys = calcExpandedKeysForValues(props.value, keyEntities, props.multiple, valueEntities);
      }

      if (!newState.expandedKeys) {
        delete newState.expandedKeys;
      } // Update flattenNodes


      if (treeData || newState.expandedKeys) {
        const flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys);
        newState.flattenNodes = flattenNodes;
      }
    } else {
      let filteredState; // treeData changed while searching

      if (treeData) {
        // Get filter data
        filteredState = filterTreeData({
          treeData,
          inputValue: prevState.inputValue,
          filterTreeNode: props.filterTreeNode,
          filterProps: props.treeNodeFilterProp,
          showFilteredOnly: props.showFilteredOnly,
          keyEntities: newState.keyEntities,
          prevExpandedKeys: [...prevState.filteredExpandedKeys]
        });
        newState.flattenNodes = filteredState.flattenNodes;
        newState.motionKeys = new _Set([]);
        newState.filteredKeys = filteredState.filteredKeys;
        newState.filteredShownKeys = filteredState.filteredShownKeys;
        newState.filteredExpandedKeys = filteredState.filteredExpandedKeys;
      } // expandedKeys changed while searching


      if (props.expandedKeys) {
        newState.filteredExpandedKeys = calcExpandedKeys(props.expandedKeys, keyEntities, props.autoExpandParent || !prevProps);

        if (prevProps && props.motion) {
          const prevKeys = prevState ? prevState.filteredExpandedKeys : new _Set([]); // only show animation when treeData does not change

          if (!treeData) {
            const motionResult = calcMotionKeys(prevKeys, newState.filteredExpandedKeys, keyEntities);
            let {
              motionKeys
            } = motionResult;
            const {
              motionType
            } = motionResult;

            if (props.showFilteredOnly) {
              motionKeys = _filterInstanceProperty(motionKeys).call(motionKeys, key => prevState.filteredShownKeys.has(key));
            }

            if (motionType === 'hide') {
              // cache flatten nodes: expandedKeys changed may not be triggered by interaction
              newState.cachedFlattenNodes = cloneDeep(prevState.flattenNodes);
            }

            newState.motionKeys = new _Set(motionKeys);
            newState.motionType = motionType;
          }
        }

        newState.flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.filteredExpandedKeys || prevState.filteredExpandedKeys, props.showFilteredOnly && prevState.filteredShownKeys);
      }
    } // Handle single selection and multiple selection in controlled mode


    const withObject = props.onChangeWithObject;
    const isMultiple = props.multiple;

    if (!isMultiple) {
      // When getting single selection, the selected node
      if (needUpdate('value')) {
        newState.selectedKeys = findKeysForValues( // In both cases whether withObject is turned on, the value is standardized to string
        normalizeValue(props.value, withObject), valueEntities, isMultiple);
      } else if (!prevProps && props.defaultValue) {
        newState.selectedKeys = findKeysForValues(normalizeValue(props.defaultValue, withObject), valueEntities, isMultiple);
      } else if (treeData) {
        // If `treeData` changed, we also need check it
        if (props.value) {
          newState.selectedKeys = findKeysForValues(normalizeValue(props.value, withObject) || '', valueEntities, isMultiple);
        }
      }
    } else {
      let checkedKeyValues; // Get the selected node during multiple selection

      if (needUpdate('value')) {
        checkedKeyValues = findKeysForValues(normalizeValue(props.value, withObject), valueEntities, isMultiple);
      } else if (!prevProps && props.defaultValue) {
        checkedKeyValues = findKeysForValues(normalizeValue(props.defaultValue, withObject), valueEntities, isMultiple);
      } else if (treeData) {
        // If `treeData` changed, we also need check it
        if (props.value) {
          checkedKeyValues = findKeysForValues(normalizeValue(props.value, withObject) || [], valueEntities, isMultiple);
        } else {
          checkedKeyValues = updateKeys(prevState.checkedKeys, keyEntities);
        }
      }

      if (checkedKeyValues) {
        if (props.checkRelation === 'unRelated') {
          newState.realCheckedKeys = new _Set(checkedKeyValues);
        } else if (props.checkRelation === 'related') {
          const {
            checkedKeys,
            halfCheckedKeys
          } = calcCheckedKeys(checkedKeyValues, keyEntities);
          newState.checkedKeys = checkedKeys;
          newState.halfCheckedKeys = halfCheckedKeys;
        }
      }
    } // update loadedKeys


    if (needUpdate('loadedKeys')) {
      newState.loadedKeys = new _Set(props.loadedKeys);
    } // update disableStrictly


    if (treeData && props.disableStrictly && props.checkRelation === 'related') {
      newState.disabledKeys = calcDisabledKeys(keyEntities);
    }

    return newState;
  }

  get adapter() {
    const filterAdapter = {
      updateInputValue: value => {
        this.setState({
          inputValue: value
        });
      },
      focusInput: () => {
        const {
          preventScroll
        } = this.props;

        if (this.inputRef && this.inputRef.current) {
          this.inputRef.current.focus({
            preventScroll
          });
        }
      }
    };
    return _Object$assign(_Object$assign(_Object$assign({}, super.adapter), filterAdapter), {
      updateState: states => {
        this.setState(_Object$assign({}, states));
      },
      notifyExpand: (expandedKeys, _ref2) => {
        let {
          expanded: bool,
          node
        } = _ref2;
        this.props.onExpand && this.props.onExpand([...expandedKeys], {
          expanded: bool,
          node
        });

        if (bool && this.props.loadData) {
          this.onNodeLoad(node);
        }
      },
      notifySelect: (selectKey, bool, node) => {
        this.props.onSelect && this.props.onSelect(selectKey, bool, node);
      },
      notifyChange: value => {
        this.props.onChange && this.props.onChange(value);
      },
      notifySearch: input => {
        this.props.onSearch && this.props.onSearch(input);
      },
      notifyRightClick: (e, node) => {
        this.props.onContextMenu && this.props.onContextMenu(e, node);
      },
      notifyDoubleClick: (e, node) => {
        this.props.onDoubleClick && this.props.onDoubleClick(e, node);
      },
      cacheFlattenNodes: bool => {
        this.setState({
          cachedFlattenNodes: bool ? cloneDeep(this.state.flattenNodes) : undefined
        });
      },
      setDragNode: treeNode => {
        this.dragNode = treeNode;
      }
    });
  }

  renderInput() {
    const {
      searchClassName,
      searchStyle,
      searchRender,
      searchPlaceholder,
      showClear
    } = this.props;
    const inputcls = cls("".concat(prefixcls, "-input"));
    const {
      inputValue
    } = this.state;
    const inputProps = {
      value: inputValue,
      className: inputcls,
      onChange: value => this.search(value),
      prefix: /*#__PURE__*/React.createElement(IconSearch, null),
      showClear,
      placeholder: searchPlaceholder
    };
    const wrapperCls = cls("".concat(prefixcls, "-search-wrapper"), searchClassName);
    return /*#__PURE__*/React.createElement("div", {
      className: wrapperCls,
      style: searchStyle
    }, /*#__PURE__*/React.createElement(LocaleConsumer, {
      componentName: "Tree"
    }, locale => {
      inputProps.placeholder = searchPlaceholder || _get(locale, 'searchPlaceholder');

      if (_isFunction(searchRender)) {
        return searchRender(_Object$assign({}, inputProps));
      }

      if (searchRender === false) {
        return null;
      }

      return /*#__PURE__*/React.createElement(Input, _Object$assign({
        "aria-label": 'Filter Tree',
        ref: this.inputRef
      }, inputProps));
    }));
  }

  renderNodeList() {
    const {
      flattenNodes,
      cachedFlattenNodes,
      motionKeys,
      motionType
    } = this.state;
    const {
      virtualize,
      motion
    } = this.props;
    const {
      direction
    } = this.context;

    if (_isEmpty(flattenNodes)) {
      return undefined;
    }

    if (!virtualize || _isEmpty(virtualize)) {
      return /*#__PURE__*/React.createElement(NodeList, {
        flattenNodes: flattenNodes,
        flattenList: cachedFlattenNodes,
        motionKeys: motion ? motionKeys : new _Set([]),
        motionType: motionType,
        onMotionEnd: this.onMotionEnd,
        renderTreeNode: this.renderTreeNode
      });
    }

    const option = _ref3 => {
      let {
        index,
        style,
        data
      } = _ref3;
      return this.renderTreeNode(data[index], index, style);
    };

    return /*#__PURE__*/React.createElement(AutoSizer, {
      defaultHeight: virtualize.height,
      defaultWidth: virtualize.width
    }, _ref4 => {
      let {
        height,
        width
      } = _ref4;
      return /*#__PURE__*/React.createElement(VirtualList, {
        itemCount: flattenNodes.length,
        itemSize: virtualize.itemSize,
        height: height,
        width: width,
        itemKey: this.itemKey,
        itemData: flattenNodes,
        className: "".concat(prefixcls, "-virtual-list"),
        style: {
          direction
        }
      }, option);
    });
  }

  render() {
    const {
      keyEntities,
      motionKeys,
      motionType,
      inputValue,
      filteredKeys,
      dragOverNodeKey,
      dropPosition,
      checkedKeys,
      realCheckedKeys
    } = this.state;
    const {
      blockNode,
      className,
      style,
      filterTreeNode,
      disabled,
      icon,
      directory,
      multiple,
      showFilteredOnly,
      motion,
      expandAction,
      loadData,
      renderLabel,
      draggable,
      renderFullLabel,
      labelEllipsis,
      virtualize,
      checkRelation
    } = this.props;
    const wrapperCls = cls("".concat(prefixcls, "-wrapper"), className);
    const listCls = cls("".concat(prefixcls, "-option-list"), {
      ["".concat(prefixcls, "-option-list-block")]: blockNode
    });
    const searchNoRes = Boolean(inputValue) && !filteredKeys.size;
    const noData = _isEmpty(keyEntities) || showFilteredOnly && searchNoRes;
    const ariaAttr = {
      role: noData ? 'none' : 'tree'
    };

    if (ariaAttr.role === 'tree') {
      ariaAttr['aria-multiselectable'] = multiple ? true : false;
    }

    return /*#__PURE__*/React.createElement(TreeContext.Provider, {
      value: {
        treeDisabled: disabled,
        treeIcon: icon,
        motion,
        motionKeys,
        motionType,
        filterTreeNode,
        keyEntities,
        onNodeClick: this.onNodeClick,
        onNodeExpand: this.onNodeExpand,
        onNodeSelect: this.onNodeSelect,
        onNodeCheck: this.onNodeCheck,
        onNodeRightClick: this.onNodeRightClick,
        onNodeDoubleClick: this.onNodeDoubleClick,
        renderTreeNode: this.renderTreeNode,
        onNodeDragStart: this.onNodeDragStart,
        onNodeDragEnter: this.onNodeDragEnter,
        onNodeDragOver: this.onNodeDragOver,
        onNodeDragLeave: this.onNodeDragLeave,
        onNodeDragEnd: this.onNodeDragEnd,
        onNodeDrop: this.onNodeDrop,
        expandAction,
        directory,
        multiple,
        showFilteredOnly,
        isSearching: Boolean(inputValue),
        loadData,
        onNodeLoad: this.onNodeLoad,
        renderLabel,
        draggable,
        renderFullLabel,
        dragOverNodeKey,
        dropPosition,
        labelEllipsis: typeof labelEllipsis === 'undefined' ? virtualize : labelEllipsis
      }
    }, /*#__PURE__*/React.createElement("div", {
      "aria-label": this.props['aria-label'],
      className: wrapperCls,
      style: style
    }, filterTreeNode ? this.renderInput() : null, /*#__PURE__*/React.createElement("div", _Object$assign({
      className: listCls
    }, ariaAttr), noData ? this.renderEmpty() : multiple ? /*#__PURE__*/React.createElement(CheckboxGroup, {
      value: _Array$from(checkRelation === 'related' ? checkedKeys : realCheckedKeys)
    }, this.renderNodeList()) : this.renderNodeList())));
  }

}

Tree.contextType = ConfigContext;
Tree.propTypes = {
  blockNode: PropTypes.bool,
  className: PropTypes.string,
  showClear: PropTypes.bool,
  defaultExpandAll: PropTypes.bool,
  defaultExpandedKeys: PropTypes.array,
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  directory: PropTypes.bool,
  disabled: PropTypes.bool,
  emptyContent: PropTypes.node,
  expandAll: PropTypes.bool,
  expandedKeys: PropTypes.array,
  filterTreeNode: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  icon: PropTypes.node,
  onChangeWithObject: PropTypes.bool,
  motion: PropTypes.bool,
  multiple: PropTypes.bool,
  onChange: PropTypes.func,
  onExpand: PropTypes.func,
  onSearch: PropTypes.func,
  onSelect: PropTypes.func,
  onContextMenu: PropTypes.func,
  onDoubleClick: PropTypes.func,
  searchClassName: PropTypes.string,
  searchPlaceholder: PropTypes.string,
  searchStyle: PropTypes.object,
  selectedKey: PropTypes.string,
  showFilteredOnly: PropTypes.bool,
  style: PropTypes.object,
  treeData: PropTypes.arrayOf(PropTypes.shape({
    key: PropTypes.string.isRequired,
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    label: PropTypes.any,
    isLeaf: PropTypes.bool
  })),
  treeDataSimpleJson: PropTypes.object,
  treeNodeFilterProp: PropTypes.string,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array, PropTypes.object]),
  virtualize: PropTypes.object,
  autoExpandParent: PropTypes.bool,
  expandAction: PropTypes.oneOf(strings.EXPAND_ACTION),
  searchRender: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  renderLabel: PropTypes.func,
  renderFullLabel: PropTypes.func,
  leafOnly: PropTypes.bool,
  loadedKeys: PropTypes.array,
  loadData: PropTypes.func,
  onLoad: PropTypes.func,
  disableStrictly: PropTypes.bool,
  draggable: PropTypes.bool,
  autoExpandWhenDragEnter: PropTypes.bool,
  hideDraggingNode: PropTypes.bool,
  renderDraggingNode: PropTypes.func,
  onDragEnd: PropTypes.func,
  onDragEnter: PropTypes.func,
  onDragLeave: PropTypes.func,
  onDragOver: PropTypes.func,
  onDragStart: PropTypes.func,
  onDrop: PropTypes.func,
  labelEllipsis: PropTypes.bool,
  checkRelation: PropTypes.string,
  'aria-label': PropTypes.string,
  preventScroll: PropTypes.bool
};
Tree.defaultProps = {
  showClear: true,
  disabled: false,
  blockNode: true,
  multiple: false,
  filterTreeNode: false,
  autoExpandParent: false,
  treeNodeFilterProp: 'label',
  defaultExpandAll: false,
  expandAll: false,
  onChangeWithObject: false,
  motion: true,
  leafOnly: false,
  showFilteredOnly: false,
  expandAction: false,
  disableStrictly: false,
  draggable: false,
  autoExpandWhenDragEnter: true,
  checkRelation: 'related'
};
Tree.TreeNode = TreeNode;
export default Tree;