import _isEqual from "lodash/isEqual";
import _isFunction from "lodash/isFunction";
import _get from "lodash/get";
import _isDate from "lodash/isDate";
import _stubFalse from "lodash/stubFalse";
import _noop from "lodash/noop";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";

/* eslint-disable jsx-a11y/click-events-have-key-events,jsx-a11y/interactive-supports-focus */

/* eslint-disable max-len */

/* eslint-disable jsx-a11y/click-events-have-key-events */

/* eslint-disable jsx-a11y/no-static-element-interactions */
import React from 'react';
import classnames from 'classnames';
import PropTypes from 'prop-types';
import ConfigContext from '../configProvider/context';
import DatePickerFoundation from '@douyinfe/semi-foundation/lib/es/datePicker/foundation';
import { cssClasses, strings, numbers } from '@douyinfe/semi-foundation/lib/es/datePicker/constants';
import { strings as popoverStrings, numbers as popoverNumbers } from '@douyinfe/semi-foundation/lib/es/popover/constants';
import BaseComponent from '../_base/baseComponent';
import Popover from '../popover/index';
import DateInput from './dateInput';
import MonthsGrid from './monthsGrid';
import QuickControl from './quickControl';
import Footer from './footer';
import Trigger from '../trigger';
import YearAndMonth from './yearAndMonth';
import '@douyinfe/semi-foundation/lib/es/datePicker/datePicker.css';
export default class DatePicker extends BaseComponent {
  constructor(props) {
    var _this;

    super(props);
    _this = this;

    this.setTriggerRef = node => this.triggerElRef.current = node; // Called when changes are selected by clicking on the selected date


    this.handleSelectedChange = (v, options) => this.foundation.handleSelectedChange(v, options); // Called when the year and month change


    this.handleYMSelectedChange = item => this.foundation.handleYMSelectedChange(item);

    this.disabledDisposeDate = function (date) {
      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }

      return _this.foundation.disabledDisposeDate(date, ...rest);
    };

    this.disabledDisposeTime = function (date) {
      for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        rest[_key2 - 1] = arguments[_key2];
      }

      return _this.foundation.disabledDisposeTime(date, ...rest);
    };

    this.handleOpenPanel = () => this.foundation.openPanel();

    this.handleInputChange = function () {
      return _this.foundation.handleInputChange(...arguments);
    };

    this.handleInsetInputChange = options => this.foundation.handleInsetInputChange(options);

    this.handleInputComplete = v => this.foundation.handleInputComplete(v);

    this.handleInputBlur = e => this.foundation.handleInputBlur(_get(e, 'nativeEvent.target.value'), e);

    this.handleInputFocus = function () {
      return _this.foundation.handleInputFocus(...arguments);
    };

    this.handleInputClear = e => this.foundation.handleInputClear(e);

    this.handleTriggerWrapperClick = e => this.foundation.handleTriggerWrapperClick(e);

    this.handleSetRangeFocus = rangeInputFocus => this.foundation.handleSetRangeFocus(rangeInputFocus);

    this.handleRangeInputBlur = (value, e) => this.foundation.handleRangeInputBlur(value, e);

    this.handleRangeInputClear = e => this.foundation.handleRangeInputClear(e);

    this.handleRangeEndTabPress = e => this.foundation.handleRangeEndTabPress(e);

    this.isAnotherPanelHasOpened = currentRangeInput => {
      if (currentRangeInput === 'rangeStart') {
        return this.focusRecordsRef.current.rangeEnd;
      } else {
        return this.focusRecordsRef.current.rangeStart;
      }
    };

    this.handleInsetDateFocus = (e, rangeType) => {
      const monthGridFoundation = _get(this, 'monthGrid.current.foundation');

      if (monthGridFoundation) {
        monthGridFoundation.showDatePanel(strings.PANEL_TYPE_LEFT);
        monthGridFoundation.showDatePanel(strings.PANEL_TYPE_RIGHT);
      }

      this.handleInputFocus(e, rangeType);
    };

    this.handleInsetTimeFocus = () => {
      const monthGridFoundation = _get(this, 'monthGrid.current.foundation');

      if (monthGridFoundation) {
        monthGridFoundation.showTimePicker(strings.PANEL_TYPE_LEFT);
        monthGridFoundation.showTimePicker(strings.PANEL_TYPE_RIGHT);
      }
    };

    this.handlePanelVisibleChange = visible => {
      this.foundation.handlePanelVisibleChange(visible);
    };

    this.handleConfirm = e => this.foundation.handleConfirm();

    this.handleCancel = e => this.foundation.handleCancel();

    this.renderFooter = (locale, localeCode) => {
      if (this.adapter.needConfirm()) {
        return /*#__PURE__*/React.createElement(Footer, _Object$assign({}, this.props, {
          locale: locale,
          localeCode: localeCode,
          onConfirmClick: this.handleConfirm,
          onCancelClick: this.handleCancel
        }));
      }

      return null;
    };

    this.renderPanel = (locale, localeCode, dateFnsLocale) => {
      const {
        dropdownClassName,
        dropdownStyle,
        density,
        topSlot,
        bottomSlot,
        insetInput,
        type,
        format,
        rangeSeparator,
        defaultPickerValue,
        presetPosition
      } = this.props;
      const {
        insetInputValue,
        value
      } = this.state;
      const wrapCls = classnames(cssClasses.PREFIX, {
        [cssClasses.PANEL_YAM]: this.adapter.typeIsYearOrMonth(),
        ["".concat(cssClasses.PREFIX, "-compact")]: density === 'compact'
      }, dropdownClassName);
      const insetInputProps = {
        dateFnsLocale,
        format,
        insetInputValue,
        rangeSeparator,
        type,
        value: value,
        handleInsetDateFocus: this.handleInsetDateFocus,
        handleInsetTimeFocus: this.handleInsetTimeFocus,
        onInsetInputChange: this.handleInsetInputChange,
        rangeInputStartRef: this.rangeInputStartRef,
        rangeInputEndRef: this.rangeInputEndRef,
        density,
        defaultPickerValue
      };
      return /*#__PURE__*/React.createElement("div", {
        ref: this.panelRef,
        className: wrapCls,
        style: dropdownStyle
      }, topSlot && /*#__PURE__*/React.createElement("div", {
        className: "".concat(cssClasses.PREFIX, "-topSlot"),
        "x-semi-prop": "topSlot"
      }, topSlot), presetPosition === "top" && this.renderQuickControls(), this.adapter.typeIsYearOrMonth() ? this.renderYearMonthPanel(locale, localeCode) : this.renderMonthGrid(locale, localeCode, dateFnsLocale), presetPosition === "bottom" && this.renderQuickControls(), bottomSlot && /*#__PURE__*/React.createElement("div", {
        className: "".concat(cssClasses.PREFIX, "-bottomSlot"),
        "x-semi-prop": "bottomSlot"
      }, bottomSlot), this.renderFooter(locale, localeCode));
    };

    this.renderYearMonthPanel = (locale, localeCode) => {
      const {
        density,
        presetPosition
      } = this.props;
      const date = this.state.value[0];
      let year = 0;
      let month = 0;

      if (_isDate(date)) {
        year = date.getFullYear();
        month = date.getMonth() + 1;
      }

      return /*#__PURE__*/React.createElement(YearAndMonth, {
        locale: locale,
        localeCode: localeCode,
        disabledDate: this.disabledDisposeDate,
        noBackBtn: true,
        monthCycled: true,
        onSelect: this.handleYMSelectedChange,
        currentYear: year,
        currentMonth: month,
        density: density,
        presetPosition: presetPosition,
        renderQuickControls: this.renderQuickControls(),
        renderDateInput: this.renderDateInput()
      });
    };

    this.wrapPopover = children => {
      const {
        panelShow
      } = this.state; // rtl changes the default position

      const {
        direction
      } = this.context;
      const defaultPosition = direction === 'rtl' ? 'bottomRight' : 'bottomLeft';
      const {
        motion,
        zIndex,
        position = defaultPosition,
        getPopupContainer,
        locale,
        localeCode,
        dateFnsLocale,
        stopPropagation,
        autoAdjustOverflow,
        spacing
      } = this.props;
      const mergedMotion = this.foundation.getMergedMotion(motion);
      return /*#__PURE__*/React.createElement(Popover, {
        getPopupContainer: getPopupContainer,
        // wrapWhenSpecial={false}
        autoAdjustOverflow: autoAdjustOverflow,
        zIndex: zIndex,
        motion: mergedMotion,
        content: this.renderPanel(locale, localeCode, dateFnsLocale),
        trigger: "custom",
        position: position,
        visible: panelShow,
        stopPropagation: stopPropagation,
        spacing: spacing,
        onVisibleChange: this.handlePanelVisibleChange
      }, children);
    };

    this.state = {
      panelShow: props.open || props.defaultOpen,
      isRange: false,
      inputValue: null,
      value: [],
      cachedSelectedValue: null,
      prevTimeZone: null,
      motionEnd: false,
      rangeInputFocus: undefined,
      autofocus: props.autoFocus || this.isRangeType(props.type, props.triggerRender) && (props.open || props.defaultOpen),
      insetInputValue: null,
      triggerDisabled: undefined
    };
    this.adapter.setCache('cachedSelectedValue', null);
    this.triggerElRef = /*#__PURE__*/React.createRef();
    this.panelRef = /*#__PURE__*/React.createRef();
    this.monthGrid = /*#__PURE__*/React.createRef();
    this.rangeInputStartRef = /*#__PURE__*/React.createRef();
    this.rangeInputEndRef = /*#__PURE__*/React.createRef();
    this.focusRecordsRef = /*#__PURE__*/React.createRef(); // @ts-ignore ignore readonly

    this.focusRecordsRef.current = {
      rangeStart: false,
      rangeEnd: false
    };
    this.foundation = new DatePickerFoundation(this.adapter);
  }

  get adapter() {
    var _this2 = this;

    return _Object$assign(_Object$assign({}, super.adapter), {
      togglePanel: panelShow => {
        this.setState({
          panelShow
        });

        if (!panelShow) {
          this.focusRecordsRef.current.rangeEnd = false;
          this.focusRecordsRef.current.rangeStart = false;
        }
      },
      registerClickOutSide: () => {
        if (this.clickOutSideHandler) {
          this.adapter.unregisterClickOutSide();
          this.clickOutSideHandler = null;
        }

        this.clickOutSideHandler = e => {
          if (this.adapter.needConfirm()) {
            return;
          }

          const triggerEl = this.triggerElRef && this.triggerElRef.current;
          const panelEl = this.panelRef && this.panelRef.current;
          const isInTrigger = triggerEl && triggerEl.contains(e.target);
          const isInPanel = panelEl && panelEl.contains(e.target);

          if (!isInTrigger && !isInPanel && this._mounted) {
            this.foundation.closePanel(e);
          }
        };

        document.addEventListener('mousedown', this.clickOutSideHandler);
      },
      unregisterClickOutSide: () => {
        document.removeEventListener('mousedown', this.clickOutSideHandler);
      },
      notifyBlur: function () {
        return _this2.props.onBlur(...arguments);
      },
      notifyFocus: function () {
        return _this2.props.onFocus(...arguments);
      },
      notifyClear: function () {
        return _this2.props.onClear(...arguments);
      },
      notifyChange: function () {
        return _this2.props.onChange(...arguments);
      },
      notifyCancel: function () {
        return _this2.props.onCancel(...arguments);
      },
      notifyConfirm: function () {
        return _this2.props.onConfirm(...arguments);
      },
      notifyOpenChange: function () {
        return _this2.props.onOpenChange(...arguments);
      },
      notifyPresetsClick: function () {
        return _this2.props.onPresetClick(...arguments);
      },
      updateValue: value => this.setState({
        value
      }),
      updatePrevTimezone: prevTimeZone => this.setState({
        prevTimeZone
      }),
      updateCachedSelectedValue: cachedSelectedValue => {
        let _cachedSelectedValue = cachedSelectedValue;

        if (cachedSelectedValue && !_Array$isArray(cachedSelectedValue)) {
          _cachedSelectedValue = [...cachedSelectedValue];
        }

        this.setState({
          cachedSelectedValue: _cachedSelectedValue
        });
      },
      updateInputValue: inputValue => {
        this.setState({
          inputValue
        });
      },
      updateInsetInputValue: insetInputValue => {
        const {
          insetInput
        } = this.props;

        if (insetInput && !_isEqual(insetInputValue, this.state.insetInputValue)) {
          this.setState({
            insetInputValue
          });
        }
      },
      needConfirm: () => {
        var _context;

        return _includesInstanceProperty(_context = ['dateTime', 'dateTimeRange']).call(_context, this.props.type) && this.props.needConfirm === true;
      },
      typeIsYearOrMonth: () => {
        var _context2;

        return _includesInstanceProperty(_context2 = ['month', 'year']).call(_context2, this.props.type);
      },
      setMotionEnd: motionEnd => this.setState({
        motionEnd
      }),
      setRangeInputFocus: rangeInputFocus => {
        const {
          preventScroll
        } = this.props;

        if (rangeInputFocus !== this.state.rangeInputFocus) {
          this.setState({
            rangeInputFocus
          });
        }

        switch (rangeInputFocus) {
          case 'rangeStart':
            const inputStartNode = _get(this, 'rangeInputStartRef.current');

            inputStartNode && inputStartNode.focus({
              preventScroll
            });
            /**
             * 解决选择完startDate，切换到endDate后panel被立马关闭的问题。
             * 用户打开panel，选了startDate后，会执行setRangeInputFocus('rangeEnd'),focus到endDateInput，
             * 同时会走到datePicker/foundation.js中的handleSelectedChange方法，在这个方法里会根据focusRecordsRef来判断是否可以关闭panel。
             * 如果在setRangeInputFocus里同步修改了focusRecordsRef的状态为true，那在handleSelectedChange里会误判startDate和endDate都已经完成选择，
             * 导致endDate还没选就关闭了panel
             *
             * Fix the problem that the panel is closed immediately after switching to endDate after starting Date is selected.
             * The user opens the panel and after starting Date is selected, setRangeInputFocus ('rangeEnd') will be executed, focus to endDateInput,
             * At the same time, it will go to the handleSelectedChange method in datePicker/foundation.js, where it will be determined whether the panel can be closed according to focusRecordsRef.
             * If the status of focusRecordsRef is modified synchronously in setRangeInputFocus to true, then in handleSelectedChange it will be misjudged that both begDate and endDate have completed the selection,
             * resulting in the panel being closed before endDate is selected
             */

            _setTimeout(() => {
              this.focusRecordsRef.current.rangeStart = true;
            }, 0);

            break;

          case 'rangeEnd':
            const inputEndNode = _get(this, 'rangeInputEndRef.current');

            inputEndNode && inputEndNode.focus({
              preventScroll
            });
            /**
             * 解决选择完startDate，切换到endDate后panel被立马关闭的问题。
             * 用户打开panel，选了startDate后，会执行setRangeInputFocus('rangeEnd'),focus到endDateInput，
             * 同时会走到datePicker/foundation.js中的handleSelectedChange方法，在这个方法里会根据focusRecordsRef来判断是否可以关闭panel。
             * 如果在setRangeInputFocus里同步修改了focusRecordsRef的状态为true，那在handleSelectedChange里会误判startDate和endDate都已经完成选择，
             * 导致endDate还没选就关闭了panel
             *
             * Fix the problem that the panel is closed immediately after switching to endDate after starting Date is selected.
             * The user opens the panel and after starting Date is selected, setRangeInputFocus ('rangeEnd') will be executed, focus to endDateInput,
             * At the same time, it will go to the handleSelectedChange method in datePicker/foundation.js, where it will be determined whether the panel can be closed according to focusRecordsRef.
             * If the status of focusRecordsRef is modified synchronously in setRangeInputFocus to true, then in handleSelectedChange it will be misjudged that both begDate and endDate have completed the selection,
             * resulting in the panel being closed before endDate is selected
             */

            _setTimeout(() => {
              this.focusRecordsRef.current.rangeEnd = true;
            }, 0);

            break;

          default:
            return;
        }
      },
      couldPanelClosed: () => this.focusRecordsRef.current.rangeStart && this.focusRecordsRef.current.rangeEnd,
      isEventTarget: e => e && e.target === e.currentTarget,
      setInsetInputFocus: () => {
        const {
          preventScroll
        } = this.props;
        const {
          rangeInputFocus
        } = this.state;

        switch (rangeInputFocus) {
          case 'rangeEnd':
            if (document.activeElement !== this.rangeInputEndRef.current) {
              const inputEndNode = _get(this, 'rangeInputEndRef.current');

              inputEndNode && inputEndNode.focus({
                preventScroll
              });
            }

            break;

          case 'rangeStart':
          default:
            if (document.activeElement !== this.rangeInputStartRef.current) {
              const inputStartNode = _get(this, 'rangeInputStartRef.current');

              inputStartNode && inputStartNode.focus({
                preventScroll
              });
            }

            break;
        }
      },
      setTriggerDisabled: disabled => {
        this.setState({
          triggerDisabled: disabled
        });
      }
    });
  }

  isRangeType(type, triggerRender) {
    return /range/i.test(type) && !_isFunction(triggerRender);
  }

  componentDidUpdate(prevProps) {
    if (prevProps.value !== this.props.value) {
      this.foundation.initFromProps(_Object$assign({}, this.props));
    } else if (this.props.timeZone !== prevProps.timeZone) {
      this.foundation.initFromProps({
        value: this.state.value,
        timeZone: this.props.timeZone,
        prevTimeZone: prevProps.timeZone
      });
    }

    if (prevProps.open !== this.props.open) {
      this.foundation.initPanelOpenStatus();

      if (!this.props.open) {
        this.foundation.clearRangeInputFocus();
      }
    }
  }

  componentDidMount() {
    this._mounted = true;
    super.componentDidMount();
  }

  componentWillUnmount() {
    this._mounted = false;
    super.componentWillUnmount();
  }

  renderMonthGrid(locale, localeCode, dateFnsLocale) {
    const {
      type,
      multiple,
      max,
      weekStartsOn,
      timePickerOpts,
      defaultPickerValue,
      format,
      hideDisabledOptions,
      disabledTimePicker,
      renderDate,
      renderFullDate,
      startDateOffset,
      endDateOffset,
      autoSwitchDate,
      density,
      syncSwitchMonth,
      onPanelChange,
      timeZone,
      triggerRender,
      insetInput,
      presetPosition
    } = this.props;
    const {
      cachedSelectedValue,
      motionEnd,
      rangeInputFocus
    } = this.state;
    const defaultValue = cachedSelectedValue;
    return /*#__PURE__*/React.createElement(MonthsGrid, {
      ref: this.monthGrid,
      locale: locale,
      localeCode: localeCode,
      dateFnsLocale: dateFnsLocale,
      weekStartsOn: weekStartsOn,
      type: type,
      multiple: multiple,
      max: max,
      format: format,
      disabledDate: this.disabledDisposeDate,
      hideDisabledOptions: hideDisabledOptions,
      disabledTimePicker: disabledTimePicker,
      disabledTime: this.disabledDisposeTime,
      defaultValue: defaultValue,
      defaultPickerValue: defaultPickerValue,
      timePickerOpts: timePickerOpts,
      isControlledComponent: !this.adapter.needConfirm() && this.isControlled('value'),
      onChange: this.handleSelectedChange,
      renderDate: renderDate,
      renderFullDate: renderFullDate,
      startDateOffset: startDateOffset,
      endDateOffset: endDateOffset,
      autoSwitchDate: autoSwitchDate,
      motionEnd: motionEnd,
      density: density,
      rangeInputFocus: rangeInputFocus,
      setRangeInputFocus: this.handleSetRangeFocus,
      isAnotherPanelHasOpened: this.isAnotherPanelHasOpened,
      syncSwitchMonth: syncSwitchMonth,
      onPanelChange: onPanelChange,
      timeZone: timeZone,
      focusRecordsRef: this.focusRecordsRef,
      triggerRender: triggerRender,
      insetInput: insetInput,
      presetPosition: presetPosition,
      renderQuickControls: this.renderQuickControls(),
      renderDateInput: this.renderDateInput()
    });
  }

  renderQuickControls() {
    const {
      presets,
      type,
      presetPosition,
      insetInput
    } = this.props;
    return /*#__PURE__*/React.createElement(QuickControl, {
      type: type,
      presets: presets,
      insetInput: insetInput,
      presetPosition: presetPosition,
      onPresetClick: (item, e) => this.foundation.handlePresetClick(item, e)
    });
  }

  renderDateInput() {
    const {
      insetInput,
      dateFnsLocale,
      density,
      type,
      format,
      rangeSeparator,
      defaultPickerValue
    } = this.props;
    const {
      insetInputValue,
      value
    } = this.state;
    const insetInputProps = {
      dateFnsLocale,
      format,
      insetInputValue,
      rangeSeparator,
      type,
      value: value,
      handleInsetDateFocus: this.handleInsetDateFocus,
      handleInsetTimeFocus: this.handleInsetTimeFocus,
      onInsetInputChange: this.handleInsetInputChange,
      rangeInputStartRef: this.rangeInputStartRef,
      rangeInputEndRef: this.rangeInputEndRef,
      density,
      defaultPickerValue
    };
    return insetInput ? /*#__PURE__*/React.createElement(DateInput, _Object$assign({}, insetInputProps, {
      insetInput: true
    })) : null;
  }

  renderInner(extraProps) {
    var _context3, _context4;

    const {
      type,
      format,
      multiple,
      disabled,
      showClear,
      insetLabel,
      insetLabelId,
      placeholder,
      validateStatus,
      inputStyle,
      prefix,
      locale,
      dateFnsLocale,
      triggerRender,
      size,
      inputReadOnly,
      rangeSeparator,
      insetInput,
      defaultPickerValue
    } = this.props;
    const {
      value,
      inputValue,
      rangeInputFocus,
      triggerDisabled
    } = this.state; // This class is not needed when triggerRender is function

    const isRangeType = this.isRangeType(type, triggerRender);
    const inputDisabled = disabled || insetInput && triggerDisabled;
    const inputCls = classnames("".concat(cssClasses.PREFIX, "-input"), {
      ["".concat(cssClasses.PREFIX, "-range-input")]: isRangeType,
      [_concatInstanceProperty(_context3 = "".concat(cssClasses.PREFIX, "-range-input-")).call(_context3, size)]: isRangeType && size,
      ["".concat(cssClasses.PREFIX, "-range-input-active")]: isRangeType && rangeInputFocus && !inputDisabled,
      ["".concat(cssClasses.PREFIX, "-range-input-disabled")]: isRangeType && inputDisabled,
      [_concatInstanceProperty(_context4 = "".concat(cssClasses.PREFIX, "-range-input-")).call(_context4, validateStatus)]: isRangeType && validateStatus
    });
    const phText = placeholder || locale.placeholder[type]; // i18n
    // These values should be passed to triggerRender, do not delete any key if it is not necessary

    const props = _Object$assign(_Object$assign({}, extraProps), {
      placeholder: phText,
      disabled: inputDisabled,
      inputValue,
      value: value,
      defaultPickerValue,
      onChange: this.handleInputChange,
      onEnterPress: this.handleInputComplete,
      // TODO: remove in next major version
      block: true,
      inputStyle,
      showClear,
      insetLabel,
      insetLabelId,
      type,
      format,
      multiple,
      validateStatus,
      inputReadOnly: inputReadOnly || insetInput,
      // onClick: this.handleOpenPanel,
      onBlur: this.handleInputBlur,
      onFocus: this.handleInputFocus,
      onClear: this.handleInputClear,
      prefix,
      size,
      autofocus: this.state.autofocus,
      dateFnsLocale,
      rangeInputFocus,
      rangeSeparator,
      onRangeBlur: this.handleRangeInputBlur,
      onRangeClear: this.handleRangeInputClear,
      onRangeEndTabPress: this.handleRangeEndTabPress,
      rangeInputStartRef: insetInput ? null : this.rangeInputStartRef,
      rangeInputEndRef: insetInput ? null : this.rangeInputEndRef
    });

    return /*#__PURE__*/React.createElement("div", {
      // tooltip will mount a11y props to children
      // eslint-disable-next-line jsx-a11y/role-has-required-aria-props
      role: "combobox",
      "aria-label": _Array$isArray(value) && value.length ? "Change date" : "Choose date",
      "aria-disabled": disabled,
      onClick: this.handleTriggerWrapperClick,
      className: inputCls
    }, typeof triggerRender === 'function' ? /*#__PURE__*/React.createElement(Trigger, _Object$assign({}, props, {
      triggerRender: triggerRender,
      componentName: "DatePicker",
      componentProps: _Object$assign({}, this.props)
    })) : /*#__PURE__*/React.createElement(DateInput, _Object$assign({}, props)));
  }

  render() {
    const {
      style,
      className,
      prefixCls
    } = this.props;
    const outerProps = {
      style,
      className: classnames(className, {
        [prefixCls]: true
      }),
      ref: this.setTriggerRef,
      'aria-invalid': this.props['aria-invalid'],
      'aria-errormessage': this.props['aria-errormessage'],
      'aria-labelledby': this.props['aria-labelledby'],
      'aria-describedby': this.props['aria-describedby'],
      'aria-required': this.props['aria-required']
    };
    const inner = this.renderInner();
    const wrappedInner = this.wrapPopover(inner);
    return /*#__PURE__*/React.createElement("div", _Object$assign({}, outerProps), wrappedInner);
  }

}
DatePicker.contextType = ConfigContext;
DatePicker.propTypes = {
  'aria-describedby': PropTypes.string,
  'aria-errormessage': PropTypes.string,
  'aria-invalid': PropTypes.bool,
  'aria-labelledby': PropTypes.string,
  'aria-required': PropTypes.bool,
  type: PropTypes.oneOf(strings.TYPE_SET),
  size: PropTypes.oneOf(strings.SIZE_SET),
  density: PropTypes.oneOf(strings.DENSITY_SET),
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.object, PropTypes.array]),
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.object, PropTypes.array]),
  defaultPickerValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.object, PropTypes.array]),
  disabledTime: PropTypes.func,
  disabledTimePicker: PropTypes.bool,
  hideDisabledOptions: PropTypes.bool,
  format: PropTypes.string,
  disabled: PropTypes.bool,
  multiple: PropTypes.bool,
  max: PropTypes.number,
  placeholder: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  presets: PropTypes.array,
  presetPosition: PropTypes.oneOf(strings.PRESET_POSITION_SET),
  onChange: PropTypes.func,
  onChangeWithDateFirst: PropTypes.bool,
  weekStartsOn: PropTypes.number,
  disabledDate: PropTypes.func,
  timePickerOpts: PropTypes.object,
  showClear: PropTypes.bool,
  onOpenChange: PropTypes.func,
  open: PropTypes.bool,
  defaultOpen: PropTypes.bool,
  motion: PropTypes.oneOfType([PropTypes.bool, PropTypes.func, PropTypes.object]),
  className: PropTypes.string,
  prefixCls: PropTypes.string,
  prefix: PropTypes.node,
  insetLabel: PropTypes.node,
  insetLabelId: PropTypes.string,
  zIndex: PropTypes.number,
  position: PropTypes.oneOf(popoverStrings.POSITION_SET),
  getPopupContainer: PropTypes.func,
  onCancel: PropTypes.func,
  onConfirm: PropTypes.func,
  needConfirm: PropTypes.bool,
  inputStyle: PropTypes.object,
  timeZone: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  triggerRender: PropTypes.func,
  stopPropagation: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
  autoAdjustOverflow: PropTypes.bool,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  onClear: PropTypes.func,
  style: PropTypes.object,
  autoFocus: PropTypes.bool,
  inputReadOnly: PropTypes.bool,
  validateStatus: PropTypes.oneOf(strings.STATUS),
  renderDate: PropTypes.func,
  renderFullDate: PropTypes.func,
  spacing: PropTypes.number,
  startDateOffset: PropTypes.func,
  endDateOffset: PropTypes.func,
  autoSwitchDate: PropTypes.bool,
  dropdownClassName: PropTypes.string,
  dropdownStyle: PropTypes.object,
  topSlot: PropTypes.node,
  bottomSlot: PropTypes.node,
  dateFnsLocale: PropTypes.object,
  // Support synchronous switching of months
  syncSwitchMonth: PropTypes.bool,
  // Callback function for panel date switching
  onPanelChange: PropTypes.func,
  rangeSeparator: PropTypes.string,
  preventScroll: PropTypes.bool
};
DatePicker.defaultProps = {
  onChangeWithDateFirst: true,
  autoAdjustOverflow: true,
  stopPropagation: true,
  motion: true,
  prefixCls: cssClasses.PREFIX,
  presetPosition: 'bottom',
  // position: 'bottomLeft',
  zIndex: popoverNumbers.DEFAULT_Z_INDEX,
  type: 'date',
  size: 'default',
  density: 'default',
  multiple: false,
  defaultOpen: false,
  disabledHours: _noop,
  disabledMinutes: _noop,
  disabledSeconds: _noop,
  hideDisabledOptions: false,
  onBlur: _noop,
  onFocus: _noop,
  onClear: _noop,
  onCancel: _noop,
  onConfirm: _noop,
  onChange: _noop,
  onOpenChange: _noop,
  onPanelChange: _noop,
  onPresetClick: _noop,
  weekStartsOn: numbers.WEEK_START_ON,
  disabledDate: _stubFalse,
  disabledTime: _stubFalse,
  inputReadOnly: false,
  spacing: numbers.SPACING,
  autoSwitchDate: true,
  syncSwitchMonth: false,
  rangeSeparator: strings.DEFAULT_SEPARATOR_RANGE,
  insetInput: false
};