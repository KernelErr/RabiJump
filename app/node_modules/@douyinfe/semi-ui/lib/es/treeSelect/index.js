import _isFunction from "lodash/isFunction";
import _get from "lodash/get";
import _noop from "lodash/noop";
import _isEmpty from "lodash/isEmpty";
import _isString from "lodash/isString";
import _isEqual from "lodash/isEqual";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _Set from "@babel/runtime-corejs3/core-js-stable/set";
import _Array$from from "@babel/runtime-corejs3/core-js-stable/array/from";
import _sliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/slice";
import React, { Fragment } from 'react';
import ReactDOM from 'react-dom';
import cls from 'classnames';
import PropTypes from 'prop-types';
import TreeSelectFoundation from '@douyinfe/semi-foundation/lib/es/treeSelect/foundation';
import { convertDataToEntities, flattenTreeData, calcExpandedKeysForValues, calcMotionKeys, findKeysForValues, calcCheckedKeys, calcExpandedKeys, getValueOrKey, normalizeKeyList, calcDisabledKeys, normalizeValue, updateKeys } from '@douyinfe/semi-foundation/lib/es/tree/treeUtil';
import { cssClasses, strings } from '@douyinfe/semi-foundation/lib/es/treeSelect/constants';
import { numbers as popoverNumbers } from '@douyinfe/semi-foundation/lib/es/popover/constants';
import { FixedSizeList as VirtualList } from 'react-window';
import '@douyinfe/semi-foundation/lib/es/tree/tree.css';
import '@douyinfe/semi-foundation/lib/es/treeSelect/treeSelect.css';
import BaseComponent from '../_base/baseComponent';
import ConfigContext from '../configProvider/context';
import TagGroup from '../tag/group';
import Tag from '../tag/index';
import Input from '../input/index';
import Popover from '../popover/index';
import AutoSizer from '../tree/autoSizer';
import TreeContext from '../tree/treeContext';
import TreeNode from '../tree/treeNode';
import NodeList from '../tree/nodeList';
import { cloneDeep } from '../tree/treeUtil';
import LocaleConsumer from '../locale/localeConsumer';
import Trigger from '../trigger';
import TagInput from '../tagInput';
import { isSemiIcon } from '../_utils';
import { IconChevronDown, IconClear, IconSearch } from '@douyinfe/semi-icons';
import CheckboxGroup from '../checkbox/checkboxGroup';
const prefixcls = cssClasses.PREFIX;
const prefixTree = cssClasses.PREFIX_TREE;
const key = 0;

class TreeSelect extends BaseComponent {
  constructor(props) {
    var _context2;

    super(props);

    this.renderSuffix = () => {
      const {
        suffix
      } = this.props;
      const suffixWrapperCls = cls({
        ["".concat(prefixcls, "-suffix")]: true,
        ["".concat(prefixcls, "-suffix-text")]: suffix && _isString(suffix),
        ["".concat(prefixcls, "-suffix-icon")]: isSemiIcon(suffix)
      });
      return /*#__PURE__*/React.createElement("div", {
        className: suffixWrapperCls,
        "x-semi-prop": "suffix"
      }, suffix);
    };

    this.renderPrefix = () => {
      const {
        prefix,
        insetLabel,
        insetLabelId
      } = this.props;
      const labelNode = prefix || insetLabel;
      const prefixWrapperCls = cls({
        ["".concat(prefixcls, "-prefix")]: true,
        // to be doublechecked
        ["".concat(prefixcls, "-inset-label")]: insetLabel,
        ["".concat(prefixcls, "-prefix-text")]: labelNode && _isString(labelNode),
        ["".concat(prefixcls, "-prefix-icon")]: isSemiIcon(labelNode)
      });
      return /*#__PURE__*/React.createElement("div", {
        className: prefixWrapperCls,
        id: insetLabelId,
        "x-semi-prop": "prefix,insetLabel"
      }, labelNode);
    };

    this.renderContent = () => {
      const {
        dropdownMinWidth
      } = this.state;
      const {
        dropdownStyle,
        dropdownClassName
      } = this.props;

      const style = _Object$assign({
        minWidth: dropdownMinWidth
      }, dropdownStyle);

      const popoverCls = cls(dropdownClassName, "".concat(prefixcls, "-popover"));
      return /*#__PURE__*/React.createElement("div", {
        className: popoverCls,
        style: style
      }, this.renderTree());
    };

    this.removeTag = removedKey => {
      this.foundation.removeTag(removedKey);
    };

    this.handleClick = e => {
      this.foundation.handleClick(e);
    };
    /* istanbul ignore next */


    this.handleSelectionEnterPress = e => {
      this.foundation.handleSelectionEnterPress(e);
    };

    this.hasValue = () => {
      const {
        multiple,
        checkRelation
      } = this.props;
      const {
        realCheckedKeys,
        checkedKeys,
        selectedKeys
      } = this.state;
      let hasValue = false;

      if (multiple) {
        if (checkRelation === 'related') {
          hasValue = Boolean(checkedKeys.size);
        } else if (checkRelation === 'unRelated') {
          hasValue = Boolean(realCheckedKeys.size);
        }
      } else {
        hasValue = Boolean(selectedKeys.length);
      }

      return hasValue;
    };

    this.showClearBtn = () => {
      const {
        showClear,
        disabled,
        searchPosition
      } = this.props;
      const {
        inputValue,
        isOpen,
        isHovering
      } = this.state;
      const triggerSearchHasInputValue = searchPosition === strings.SEARCH_POSITION_TRIGGER && inputValue;
      return showClear && (this.hasValue() || triggerSearchHasInputValue) && !disabled && (isOpen || isHovering);
    };

    this.renderTagList = () => {
      const {
        checkedKeys,
        keyEntities,
        disabledKeys,
        realCheckedKeys
      } = this.state;
      const {
        treeNodeLabelProp,
        leafOnly,
        disabled,
        disableStrictly,
        size,
        checkRelation,
        renderSelectedItem: propRenderSelectedItem
      } = this.props;
      const renderSelectedItem = _isFunction(propRenderSelectedItem) ? propRenderSelectedItem : item => ({
        isRenderInTag: true,
        content: _get(item, treeNodeLabelProp, null)
      });
      let renderKeys = [];

      if (checkRelation === 'related') {
        renderKeys = normalizeKeyList([...checkedKeys], keyEntities, leafOnly);
      } else if (checkRelation === 'unRelated' && _Object$keys(keyEntities).length > 0) {
        renderKeys = [...realCheckedKeys];
      }

      const tagList = []; // eslint-disable-next-line @typescript-eslint/no-shadow

      _forEachInstanceProperty(renderKeys).call(renderKeys, key => {
        const item = keyEntities[key].data;

        const onClose = (tagContent, e) => {
          if (e && typeof e.preventDefault === 'function') {
            // make sure that tag will not hidden immediately in controlled mode
            e.preventDefault();
          }

          this.removeTag(key);
        };

        const {
          content,
          isRenderInTag
        } = treeNodeLabelProp in item && item ? renderSelectedItem(item, {
          index: key,
          onClose
        }) : null;

        if (!content) {
          return;
        }

        const isDisabled = disabled || item.disabled || disableStrictly && disabledKeys.has(item.key);
        const tag = {
          closable: !isDisabled,
          color: 'white',
          visible: true,
          onClose,
          key,
          size: size === 'small' ? 'small' : 'large'
        };

        if (isRenderInTag) {
          // pass ReactNode list to tagList when using tagGroup custom mode
          tagList.push( /*#__PURE__*/React.createElement(Tag, _Object$assign({}, tag), content));
        } else {
          tagList.push(content);
        }
      });

      return tagList;
    };
    /**
     * When single selection and the search box is on trigger, the items displayed in the rendered search box
     */


    this.renderSingleTriggerSearchItem = () => {
      const {
        placeholder,
        disabled
      } = this.props;
      const {
        inputTriggerFocus
      } = this.state;
      const renderText = this.foundation.getRenderTextInSingle();
      const spanCls = cls("".concat(prefixcls, "-selection-TriggerSearchItem"), {
        ["".concat(prefixcls, "-selection-TriggerSearchItem-placeholder")]: (inputTriggerFocus || !renderText) && !disabled,
        ["".concat(prefixcls, "-selection-TriggerSearchItem-disabled")]: disabled
      });
      return /*#__PURE__*/React.createElement("span", {
        className: spanCls
      }, renderText ? renderText : placeholder);
    };
    /**
     * Single selection and the search box content rendered when the search box is on trigger
     */


    this.renderSingleTriggerSearch = () => {
      const {
        inputValue
      } = this.state;
      return /*#__PURE__*/React.createElement(React.Fragment, null, !inputValue && this.renderSingleTriggerSearchItem(), this.renderInput());
    };

    this.renderSelectContent = () => {
      const {
        multiple,
        placeholder,
        maxTagCount,
        searchPosition,
        filterTreeNode
      } = this.props;
      const isTriggerPositionSearch = filterTreeNode && searchPosition === strings.SEARCH_POSITION_TRIGGER; // searchPosition = trigger

      if (isTriggerPositionSearch) {
        return multiple ? this.renderTagInput() : this.renderSingleTriggerSearch();
      } // searchPosition = dropdown and single seleciton


      if (!multiple || !this.hasValue()) {
        const renderText = this.foundation.getRenderTextInSingle();
        const spanCls = cls({
          ["".concat(prefixcls, "-selection-placeholder")]: !renderText
        });
        return /*#__PURE__*/React.createElement("span", {
          className: spanCls
        }, renderText ? renderText : placeholder);
      } // searchPosition = dropdown and multiple seleciton


      const tagList = this.renderTagList(); // mode=custom to return tagList directly

      return /*#__PURE__*/React.createElement(TagGroup, {
        maxTagCount: maxTagCount,
        tagList: tagList,
        size: "large",
        mode: "custom"
      });
    };

    this.handleClear = e => {
      e && e.stopPropagation();
      this.foundation.handleClear(e);
    };
    /* istanbul ignore next */


    this.handleClearEnterPress = e => {
      e && e.stopPropagation();
      this.foundation.handleClearEnterPress(e);
    };

    this.handleMouseOver = e => {
      this.foundation.toggleHoverState(true);
    };

    this.handleMouseLeave = e => {
      this.foundation.toggleHoverState(false);
    };

    this.search = value => {
      const {
        isOpen
      } = this.state;

      if (!isOpen) {
        this.foundation.open();
      }

      this.foundation.handleInputChange(value);
    };

    this.close = () => {
      this.foundation.close(null);
    };

    this.renderArrow = () => {
      const showClearBtn = this.showClearBtn();
      const {
        arrowIcon
      } = this.props;

      if (showClearBtn) {
        return null;
      }

      return arrowIcon ? /*#__PURE__*/React.createElement("div", {
        className: cls("".concat(prefixcls, "-arrow")),
        "x-semi-prop": "arrowIcon"
      }, arrowIcon) : null;
    };

    this.renderClearBtn = () => {
      const showClearBtn = this.showClearBtn();
      const clearCls = cls("".concat(prefixcls, "-clearbtn"));

      if (showClearBtn) {
        return /*#__PURE__*/React.createElement("div", {
          role: 'button',
          tabIndex: 0,
          "aria-label": "Clear TreeSelect value",
          className: clearCls,
          onClick: this.handleClear,
          onKeyPress: this.handleClearEnterPress
        }, /*#__PURE__*/React.createElement(IconClear, null));
      }

      return null;
    };

    this.renderSelection = () => {
      const {
        disabled,
        multiple,
        filterTreeNode,
        validateStatus,
        prefix,
        suffix,
        style,
        size,
        insetLabel,
        className,
        placeholder,
        showClear,
        leafOnly,
        searchPosition,
        triggerRender
      } = this.props;
      const {
        isOpen,
        isInput,
        inputValue,
        selectedKeys,
        checkedKeys,
        keyEntities
      } = this.state;
      const filterable = Boolean(filterTreeNode);
      const useCustomTrigger = typeof triggerRender === 'function';
      const mouseEvent = showClear ? {
        onMouseEnter: e => this.handleMouseOver(e),
        onMouseLeave: e => this.handleMouseLeave(e)
      } : {};
      const isTriggerPositionSearch = searchPosition === strings.SEARCH_POSITION_TRIGGER && filterable;

      const isEmptyTriggerSearch = isTriggerPositionSearch && _isEmpty(checkedKeys);

      const isValueTriggerSearch = isTriggerPositionSearch && !_isEmpty(checkedKeys);
      const classNames = useCustomTrigger ? cls(className) : cls(prefixcls, {
        ["".concat(prefixcls, "-focus")]: isOpen && !isInput,
        ["".concat(prefixcls, "-disabled")]: disabled,
        ["".concat(prefixcls, "-single")]: !multiple,
        ["".concat(prefixcls, "-multiple")]: multiple,
        ["".concat(prefixcls, "-multiple-tagInput-empty")]: multiple && isEmptyTriggerSearch,
        ["".concat(prefixcls, "-multiple-tagInput-notEmpty")]: multiple && isValueTriggerSearch,
        ["".concat(prefixcls, "-filterable")]: filterable,
        ["".concat(prefixcls, "-error")]: validateStatus === 'error',
        ["".concat(prefixcls, "-warning")]: validateStatus === 'warning',
        ["".concat(prefixcls, "-small")]: size === 'small',
        ["".concat(prefixcls, "-large")]: size === 'large',
        ["".concat(prefixcls, "-with-prefix")]: prefix || insetLabel,
        ["".concat(prefixcls, "-with-suffix")]: suffix,
        ["".concat(prefixcls, "-with-suffix")]: suffix
      }, className);
      const triggerRenderKeys = multiple ? normalizeKeyList([...checkedKeys], keyEntities, leafOnly) : selectedKeys;
      const inner = useCustomTrigger ? /*#__PURE__*/React.createElement(Trigger, {
        inputValue: inputValue,
        // eslint-disable-next-line @typescript-eslint/no-shadow
        value: _mapInstanceProperty(triggerRenderKeys).call(triggerRenderKeys, key => _get(keyEntities, [key, 'data'])),
        disabled: disabled,
        placeholder: placeholder,
        onClear: this.handleClear,
        componentName: 'TreeSelect',
        triggerRender: triggerRender,
        componentProps: _Object$assign({}, this.props)
      }) : [/*#__PURE__*/React.createElement(Fragment, {
        key: 'prefix'
      }, prefix || insetLabel ? this.renderPrefix() : null), /*#__PURE__*/React.createElement(Fragment, {
        key: 'selection'
      }, /*#__PURE__*/React.createElement("div", {
        className: "".concat(prefixcls, "-selection")
      }, this.renderSelectContent())), /*#__PURE__*/React.createElement(Fragment, {
        key: 'suffix'
      }, suffix ? this.renderSuffix() : null), /*#__PURE__*/React.createElement(Fragment, {
        key: 'clearBtn'
      }, showClear || isTriggerPositionSearch && inputValue ? this.renderClearBtn() : null), /*#__PURE__*/React.createElement(Fragment, {
        key: 'arrow'
      }, this.renderArrow())];
      const tabIndex = disabled ? null : 0;
      /**
       * Reasons for disabling the a11y eslint rule:
       * The following attributes(aria-controls,aria-expanded) will be automatically added by Tooltip, no need to declare here
       */

      return /*#__PURE__*/React.createElement("div", _Object$assign({
        // eslint-disable-next-line jsx-a11y/role-has-required-aria-props
        role: 'combobox',
        "aria-disabled": disabled,
        "aria-haspopup": "tree",
        tabIndex: tabIndex,
        className: classNames,
        style: style,
        ref: this.triggerRef,
        onClick: this.handleClick,
        onKeyPress: this.handleSelectionEnterPress,
        "aria-invalid": this.props['aria-invalid'],
        "aria-errormessage": this.props['aria-errormessage'],
        "aria-label": this.props['aria-label'],
        "aria-labelledby": this.props['aria-labelledby'],
        "aria-describedby": this.props['aria-describedby'],
        "aria-required": this.props['aria-required']
      }, mouseEvent), inner);
    }; // eslint-disable-next-line @typescript-eslint/no-shadow


    this.renderTagItem = (key, idx) => {
      var _context;

      const {
        keyEntities,
        disabledKeys
      } = this.state;
      const {
        size,
        leafOnly,
        disabled,
        disableStrictly,
        renderSelectedItem: propRenderSelectedItem,
        treeNodeLabelProp
      } = this.props;
      const keyList = normalizeKeyList([key], keyEntities, leafOnly);

      const nodes = _mapInstanceProperty(keyList).call(keyList, i => keyEntities[i].data);

      const value = getValueOrKey(nodes);
      const tagCls = cls("".concat(prefixcls, "-selection-tag"), {
        ["".concat(prefixcls, "-selection-tag-disabled")]: disabled
      });
      const nodeHaveData = !_isEmpty(nodes) && !_isEmpty(nodes[0]);
      const isDisableStrictlyNode = disableStrictly && nodeHaveData && disabledKeys.has(nodes[0].key);
      const closable = nodeHaveData && !nodes[0].disabled && !disabled && !isDisableStrictlyNode;

      const onClose = (tagChildren, e) => {
        // When value has not changed, prevent clicking tag closeBtn to close tag
        e.preventDefault();
        this.removeTag(key);
      };

      const tagProps = {
        size: size === 'small' ? 'small' : 'large',
        key: _concatInstanceProperty(_context = "tag-".concat(value, "-")).call(_context, idx),
        color: 'white',
        className: tagCls,
        closable,
        onClose
      };
      const item = nodes[0];
      const renderSelectedItem = _isFunction(propRenderSelectedItem) ? propRenderSelectedItem : selectedItem => ({
        isRenderInTag: true,
        content: _get(selectedItem, treeNodeLabelProp, null)
      });

      if (_isFunction(renderSelectedItem)) {
        const {
          content,
          isRenderInTag
        } = treeNodeLabelProp in item && item ? renderSelectedItem(item, {
          index: idx,
          onClose
        }) : null;

        if (isRenderInTag) {
          return /*#__PURE__*/React.createElement(Tag, _Object$assign({}, tagProps), content);
        } else {
          return content;
        }
      }

      return /*#__PURE__*/React.createElement(Tag, _Object$assign({}, tagProps), value);
    };

    this.renderTagInput = () => {
      const {
        leafOnly,
        disabled,
        size,
        searchAutoFocus,
        placeholder,
        maxTagCount,
        checkRelation
      } = this.props;
      const {
        keyEntities,
        checkedKeys,
        inputValue,
        realCheckedKeys
      } = this.state;
      let keyList = [];

      if (checkRelation === 'related') {
        keyList = normalizeKeyList(checkedKeys, keyEntities, leafOnly);
      } else if (checkRelation === 'unRelated') {
        keyList = [...realCheckedKeys];
      }

      return /*#__PURE__*/React.createElement(TagInput, {
        maxTagCount: maxTagCount,
        disabled: disabled,
        onInputChange: v => this.search(v),
        ref: this.tagInputRef,
        placeholder: placeholder,
        value: keyList,
        inputValue: inputValue,
        size: size,
        autoFocus: searchAutoFocus,
        renderTagItem: (itemKey, index) => this.renderTagItem(itemKey, index),
        onRemove: itemKey => this.removeTag(itemKey)
      });
    }; // render Tree


    this.renderInput = () => {
      const {
        searchPlaceholder,
        searchRender,
        showSearchClear,
        searchPosition,
        searchAutoFocus,
        multiple,
        disabled
      } = this.props;
      const isDropdownPositionSearch = searchPosition === strings.SEARCH_POSITION_DROPDOWN;
      const inputcls = cls({
        ["".concat(prefixTree, "-input")]: isDropdownPositionSearch,
        ["".concat(prefixcls, "-inputTrigger")]: !isDropdownPositionSearch
      });
      const {
        inputValue
      } = this.state;
      const baseInputProps = {
        value: inputValue,
        className: inputcls,
        onChange: value => this.search(value)
      };
      const inputDropdownProps = {
        showClear: showSearchClear,
        prefix: /*#__PURE__*/React.createElement(IconSearch, null)
      };
      const inputTriggerProps = {
        onFocus: e => this.foundation.handleInputTriggerFocus(),
        onBlur: e => this.foundation.handleInputTriggerBlur(),
        disabled
      };
      const realInputProps = isDropdownPositionSearch ? inputDropdownProps : inputTriggerProps;
      const wrapperCls = cls({
        ["".concat(prefixTree, "-search-wrapper")]: isDropdownPositionSearch,
        ["".concat(prefixcls, "-triggerSingleSearch-wrapper")]: !isDropdownPositionSearch && !multiple
      });
      const useCusSearch = typeof searchRender === 'function' || typeof searchRender === 'boolean';

      if (useCusSearch && !searchRender) {
        return null;
      }

      return /*#__PURE__*/React.createElement("div", {
        className: wrapperCls
      }, /*#__PURE__*/React.createElement(LocaleConsumer, {
        componentName: "TreeSelect"
      }, locale => {
        const placeholder = isDropdownPositionSearch ? searchPlaceholder || locale.searchPlaceholder : '';

        if (useCusSearch) {
          return searchRender(_Object$assign(_Object$assign(_Object$assign({}, realInputProps), baseInputProps), {
            placeholder
          }));
        }

        return /*#__PURE__*/React.createElement(Input, _Object$assign({
          "aria-label": 'Filter TreeSelect item',
          ref: this.inputRef,
          autofocus: searchAutoFocus,
          placeholder: placeholder
        }, baseInputProps, realInputProps));
      }));
    };

    this.renderEmpty = () => {
      const {
        emptyContent
      } = this.props;

      if (emptyContent) {
        return /*#__PURE__*/React.createElement(TreeNode, {
          empty: true,
          emptyContent: this.props.emptyContent
        });
      } else {
        return /*#__PURE__*/React.createElement(LocaleConsumer, {
          componentName: "Tree"
        }, locale => /*#__PURE__*/React.createElement(TreeNode, {
          empty: true,
          emptyContent: locale.emptyText
        }));
      }
    };

    this.onNodeLoad = data => new _Promise(resolve => this.foundation.setLoadKeys(data, resolve));

    this.onNodeSelect = (e, treeNode) => {
      this.foundation.handleNodeSelect(e, treeNode);
    };

    this.onNodeCheck = (e, treeNode) => {
      this.foundation.handleNodeSelect(e, treeNode);
    };

    this.onNodeExpand = (e, treeNode) => {
      this.foundation.handleNodeExpand(e, treeNode);
    };

    this.getTreeNodeRequiredProps = () => {
      const {
        expandedKeys,
        selectedKeys,
        checkedKeys,
        halfCheckedKeys,
        keyEntities,
        filteredKeys
      } = this.state;
      return {
        expandedKeys: expandedKeys || new _Set(),
        selectedKeys: selectedKeys || [],
        checkedKeys: checkedKeys || new _Set(),
        halfCheckedKeys: halfCheckedKeys || new _Set(),
        filteredKeys: filteredKeys || new _Set(),
        keyEntities
      };
    };

    this.getTreeNodeKey = treeNode => {
      const {
        data
      } = treeNode; // eslint-disable-next-line @typescript-eslint/no-shadow

      const {
        key
      } = data;
      return key;
    };
    /* Event handler function after popover is closed */


    this.handlePopoverClose = isVisible => {
      const {
        filterTreeNode
      } = this.props;

      if (isVisible === false && Boolean(filterTreeNode)) {
        this.foundation.clearInput();
      }
    };

    this.renderTreeNode = (treeNode, ind, style) => {
      const {
        data
      } = treeNode; // eslint-disable-next-line @typescript-eslint/no-shadow

      const {
        key
      } = data;
      const treeNodeProps = this.foundation.getTreeNodeProps(key);

      if (!treeNodeProps) {
        return null;
      }

      return /*#__PURE__*/React.createElement(TreeNode, _Object$assign({}, treeNodeProps, data, {
        key: key,
        data: data,
        style: style
      }));
    };

    this.itemKey = (index, data) => {
      // Find the item at the specified index.
      const item = data[index]; // Return a value that uniquely identifies this item.

      return item.key;
    };

    this.renderNodeList = () => {
      const {
        flattenNodes,
        motionKeys,
        motionType,
        filteredKeys
      } = this.state;
      const {
        direction
      } = this.context;
      const {
        virtualize,
        motionExpand
      } = this.props;
      const isExpandControlled = ('expandedKeys' in this.props);

      if (!virtualize || _isEmpty(virtualize)) {
        return /*#__PURE__*/React.createElement(NodeList, {
          flattenNodes: flattenNodes,
          flattenList: this._flattenNodes,
          motionKeys: motionExpand ? motionKeys : new _Set([]),
          motionType: motionType,
          // When motionKeys is empty, but filteredKeys is not empty (that is, the search hits), this situation should be distinguished from ordinary motionKeys
          searchTargetIsDeep: isExpandControlled && motionExpand && _isEmpty(motionKeys) && !_isEmpty(filteredKeys),
          onMotionEnd: this.onMotionEnd,
          renderTreeNode: this.renderTreeNode
        });
      }

      const option = _ref => {
        let {
          index,
          style,
          data
        } = _ref;
        return this.renderTreeNode(data[index], index, style);
      };

      return /*#__PURE__*/React.createElement(AutoSizer, {
        defaultHeight: virtualize.height,
        defaultWidth: virtualize.width
      }, _ref2 => {
        let {
          height,
          width
        } = _ref2;
        return /*#__PURE__*/React.createElement(VirtualList, {
          itemCount: flattenNodes.length,
          itemSize: virtualize.itemSize,
          height: height,
          width: width,
          // @ts-ignore avoid strict check of itemKey
          itemKey: this.itemKey,
          itemData: flattenNodes,
          className: "".concat(prefixTree, "-virtual-list"),
          style: {
            direction
          }
        }, option);
      });
    };

    this.renderTree = () => {
      const {
        keyEntities,
        motionKeys,
        motionType,
        inputValue,
        filteredKeys,
        flattenNodes,
        checkedKeys,
        realCheckedKeys
      } = this.state;
      const {
        loadData,
        filterTreeNode,
        disabled,
        multiple,
        showFilteredOnly,
        motionExpand,
        outerBottomSlot,
        outerTopSlot,
        expandAction,
        labelEllipsis,
        virtualize,
        optionListStyle,
        searchPosition,
        renderLabel,
        renderFullLabel,
        checkRelation
      } = this.props;
      const wrapperCls = cls("".concat(prefixTree, "-wrapper"));
      const listCls = cls("".concat(prefixTree, "-option-list"), {
        ["".concat(prefixTree, "-option-list-block")]: true
      });
      const searchNoRes = Boolean(inputValue) && !filteredKeys.size;
      const noData = _isEmpty(flattenNodes) || showFilteredOnly && searchNoRes;
      const isDropdownPositionSearch = searchPosition === strings.SEARCH_POSITION_DROPDOWN;
      return /*#__PURE__*/React.createElement(TreeContext.Provider, {
        value: {
          loadData,
          treeDisabled: disabled,
          motion: motionExpand,
          motionKeys,
          motionType,
          expandAction,
          filterTreeNode,
          keyEntities,
          onNodeClick: this.onNodeClick,
          onNodeDoubleClick: this.onNodeDoubleClick,
          // tree node will call this function when treeNode is right clicked
          onNodeRightClick: _noop,
          onNodeExpand: this.onNodeExpand,
          onNodeSelect: this.onNodeSelect,
          onNodeCheck: this.onNodeCheck,
          renderTreeNode: this.renderTreeNode,
          multiple,
          showFilteredOnly,
          isSearching: Boolean(inputValue),
          renderLabel,
          renderFullLabel,
          labelEllipsis: typeof labelEllipsis === 'undefined' ? virtualize : labelEllipsis
        }
      }, /*#__PURE__*/React.createElement("div", {
        className: wrapperCls
      }, outerTopSlot, !outerTopSlot && filterTreeNode && isDropdownPositionSearch && this.renderInput(), /*#__PURE__*/React.createElement("div", {
        className: listCls,
        role: "tree",
        "aria-multiselectable": multiple ? true : false,
        style: optionListStyle
      }, noData ? this.renderEmpty() : multiple ? /*#__PURE__*/React.createElement(CheckboxGroup, {
        value: _Array$from(checkRelation === 'related' ? checkedKeys : realCheckedKeys)
      }, this.renderNodeList()) : this.renderNodeList()), outerBottomSlot));
    };

    this.state = {
      inputTriggerFocus: false,
      isOpen: false,
      isInput: false,
      rePosKey: key,
      dropdownMinWidth: null,
      inputValue: '',
      keyEntities: {},
      treeData: [],
      flattenNodes: [],
      selectedKeys: [],
      checkedKeys: new _Set(),
      halfCheckedKeys: new _Set(),
      realCheckedKeys: new _Set([]),
      disabledKeys: new _Set(),
      motionKeys: new _Set([]),
      motionType: 'hide',
      expandedKeys: new _Set(props.expandedKeys),
      filteredKeys: new _Set(),
      filteredExpandedKeys: new _Set(),
      filteredShownKeys: new _Set(),
      prevProps: null,
      isHovering: false,
      cachedKeyValuePairs: {},
      loadedKeys: new _Set(),
      loadingKeys: new _Set()
    };
    this.inputRef = /*#__PURE__*/React.createRef();
    this.tagInputRef = /*#__PURE__*/React.createRef();
    this.triggerRef = /*#__PURE__*/React.createRef();
    this.optionsRef = /*#__PURE__*/React.createRef();
    this.clickOutsideHandler = null;
    this.foundation = new TreeSelectFoundation(this.adapter);
    this.treeSelectID = _sliceInstanceProperty(_context2 = Math.random().toString(36)).call(_context2, 2);

    this.onMotionEnd = () => {
      this.adapter.rePositionDropdown();
    };
  } // eslint-disable-next-line max-lines-per-function


  static getDerivedStateFromProps(props, prevState) {
    const {
      prevProps,
      rePosKey
    } = prevState;

    const needUpdate = name => !prevProps && name in props || prevProps && !_isEqual(prevProps[name], props[name]);

    let treeData;
    const withObject = props.onChangeWithObject;
    let keyEntities = prevState.keyEntities || {};
    let valueEntities = prevState.cachedKeyValuePairs || {};
    const newState = {
      prevProps: props
    }; // TreeNode

    if (needUpdate('treeData')) {
      treeData = props.treeData;
      newState.treeData = treeData;
      const entitiesMap = convertDataToEntities(treeData);
      newState.keyEntities = _Object$assign({}, entitiesMap.keyEntities);
      keyEntities = newState.keyEntities;
      newState.cachedKeyValuePairs = _Object$assign({}, entitiesMap.valueEntities);
      valueEntities = newState.cachedKeyValuePairs;
    } // if treeData keys changes, we won't show animation


    if (treeData && props.motion && !_isEqual(_Object$keys(newState.keyEntities), _Object$keys(prevState.keyEntities))) {
      if (prevProps && props.motion) {
        newState.motionKeys = new _Set([]);
        newState.motionType = null;
      }
    }

    const expandAllWhenDataChange = needUpdate('treeData') && props.expandAll; // expandedKeys

    if (needUpdate('expandedKeys') || prevProps && needUpdate('autoExpandParent')) {
      newState.expandedKeys = calcExpandedKeys(props.expandedKeys, keyEntities, props.autoExpandParent || !prevProps); // only show animation when treeData does not change

      if (prevProps && props.motion && !treeData) {
        const {
          motionKeys,
          motionType
        } = calcMotionKeys(prevState.expandedKeys, newState.expandedKeys, keyEntities);
        newState.motionKeys = new _Set(motionKeys);
        newState.motionType = motionType;
      }
    } else if (!prevProps && (props.defaultExpandAll || props.expandAll) || expandAllWhenDataChange) {
      newState.expandedKeys = new _Set(_Object$keys(keyEntities));
    } else if (!prevProps && props.defaultExpandedKeys) {
      newState.expandedKeys = calcExpandedKeys(props.defaultExpandedKeys, keyEntities);
    } else if (!prevProps && props.defaultValue) {
      newState.expandedKeys = calcExpandedKeysForValues(normalizeValue(props.defaultValue, withObject), keyEntities, props.multiple, valueEntities);
    } else if (!prevProps && props.value) {
      newState.expandedKeys = calcExpandedKeysForValues(normalizeValue(props.value, withObject), keyEntities, props.multiple, valueEntities);
    } // flattenNodes


    if (treeData || needUpdate('expandedKeys')) {
      const flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys);
      newState.flattenNodes = flattenNodes;
    } // selectedKeys: single mode controlled


    const isMultiple = props.multiple;

    if (!isMultiple) {
      if (needUpdate('value')) {
        newState.selectedKeys = findKeysForValues(normalizeValue(props.value, withObject), valueEntities, isMultiple);
      } else if (!prevProps && props.defaultValue) {
        newState.selectedKeys = findKeysForValues(normalizeValue(props.defaultValue, withObject), valueEntities, isMultiple);
      } else if (treeData) {
        // If `treeData` changed, we also need check it
        if (props.value) {
          newState.selectedKeys = findKeysForValues(normalizeValue(props.value, withObject) || '', valueEntities, isMultiple);
        } else {
          newState.selectedKeys = updateKeys(prevState.selectedKeys, keyEntities);
        }
      }
    } else {
      // checkedKeys: multiple mode controlled || data changed
      let checkedKeyValues;

      if (needUpdate('value')) {
        checkedKeyValues = findKeysForValues(normalizeValue(props.value, withObject), valueEntities, isMultiple);
      } else if (!prevProps && props.defaultValue) {
        checkedKeyValues = findKeysForValues(normalizeValue(props.defaultValue, withObject), valueEntities, isMultiple);
      } else if (treeData) {
        // If `treeData` changed, we also need check it
        if (props.value) {
          checkedKeyValues = findKeysForValues(normalizeValue(props.value, withObject) || [], valueEntities, isMultiple);
        } else {
          checkedKeyValues = updateKeys(prevState.checkedKeys, keyEntities);
        }
      }

      if (checkedKeyValues) {
        if (props.checkRelation === 'unRelated') {
          newState.realCheckedKeys = new _Set(checkedKeyValues);
        } else if (props.checkRelation === 'related') {
          const {
            checkedKeys,
            halfCheckedKeys
          } = calcCheckedKeys(checkedKeyValues, keyEntities);
          newState.checkedKeys = checkedKeys;
          newState.halfCheckedKeys = halfCheckedKeys;
        }
      }
    } // loadedKeys


    if (needUpdate('loadedKeys')) {
      newState.loadedKeys = new _Set(props.loadedKeys);
    } // ================== rePosKey ==================


    if (needUpdate('treeData') || needUpdate('value')) {
      newState.rePosKey = rePosKey + 1;
    } // ================ disableStrictly =================


    if (treeData && props.disableStrictly && props.checkRelation === 'related') {
      newState.disabledKeys = calcDisabledKeys(keyEntities);
    }

    return newState;
  }

  get adapter() {
    var _this = this;

    const filterAdapter = {
      updateInputValue: value => {
        this.setState({
          inputValue: value
        });
      }
    };
    const treeSelectAdapter = {
      registerClickOutsideHandler: cb => {
        const clickOutsideHandler = e => {
          const optionInstance = this.optionsRef && this.optionsRef.current;
          const triggerDom = this.triggerRef && this.triggerRef.current; // eslint-disable-next-line

          const optionsDom = ReactDOM.findDOMNode(optionInstance);
          const target = e.target;

          if (optionsDom && (!optionsDom.contains(target) || !optionsDom.contains(target.parentNode)) && triggerDom && !triggerDom.contains(target)) {
            cb(e);
          }
        };

        this.clickOutsideHandler = clickOutsideHandler;
        document.addEventListener('mousedown', clickOutsideHandler, false);
      },
      unregisterClickOutsideHandler: () => {
        document.removeEventListener('mousedown', this.clickOutsideHandler, false);
        this.clickOutsideHandler = null;
      },
      rePositionDropdown: () => {
        let {
          rePosKey
        } = this.state;
        rePosKey = rePosKey + 1;
        this.setState({
          rePosKey
        });
      }
    };
    const treeAdapter = {
      updateState: states => {
        this.setState(_Object$assign({}, states));
      },
      notifySelect: (selectKey, bool, node) => {
        this.props.onSelect && this.props.onSelect(selectKey, bool, node);
      },
      notifySearch: (input, filteredExpandedKeys) => {
        this.props.onSearch && this.props.onSearch(input, filteredExpandedKeys);
      },
      cacheFlattenNodes: bool => {
        this._flattenNodes = bool ? cloneDeep(this.state.flattenNodes) : null;
      },
      notifyLoad: (newLoadedKeys, data) => {
        const {
          onLoad
        } = this.props;
        _isFunction(onLoad) && onLoad(newLoadedKeys, data);
      }
    };
    return _Object$assign(_Object$assign(_Object$assign(_Object$assign(_Object$assign({}, super.adapter), filterAdapter), treeSelectAdapter), treeAdapter), {
      updateLoadKeys: (data, resolve) => {
        this.setState(_ref3 => {
          let {
            loadedKeys,
            loadingKeys
          } = _ref3;
          return this.foundation.handleNodeLoad(loadedKeys, loadingKeys, data, resolve);
        });
      },
      updateState: states => {
        this.setState(_Object$assign({}, states));
      },
      openMenu: () => {
        this.setState({
          isOpen: true
        }, () => {
          this.props.onVisibleChange(true);
        });
      },
      closeMenu: cb => {
        this.setState({
          isOpen: false
        }, () => {
          cb && cb();
          this.props.onVisibleChange(false);
        });
      },
      getTriggerWidth: () => {
        const el = this.triggerRef.current;
        return el && el.getBoundingClientRect().width;
      },
      setOptionWrapperWidth: width => {
        this.setState({
          dropdownMinWidth: width
        });
      },
      notifyChange: (value, node, e) => {
        this.props.onChange && this.props.onChange(value, node, e);
      },
      notifyChangeWithObject: (node, e) => {
        this.props.onChange && this.props.onChange(node, e);
      },
      notifyExpand: (expandedKeys, _ref4) => {
        let {
          expanded: bool,
          node
        } = _ref4;
        this.props.onExpand && this.props.onExpand([...expandedKeys], {
          expanded: bool,
          node
        });

        if (bool && this.props.loadData) {
          this.onNodeLoad(node);
        }
      },
      notifyFocus: function () {
        _this.props.onFocus && _this.props.onFocus(...arguments);
      },
      notifyBlur: function () {
        _this.props.onBlur && _this.props.onBlur(...arguments);
      },
      toggleHovering: bool => {
        this.setState({
          isHovering: bool
        });
      },
      updateInputFocus: bool => {} // eslint-disable-line

    });
  }

  componentDidMount() {
    this.foundation.init();
  }

  componentWillUnmount() {
    this.foundation.destroy();
  }

  render() {
    const content = this.renderContent();
    const {
      motion,
      zIndex,
      mouseLeaveDelay,
      mouseEnterDelay,
      autoAdjustOverflow,
      stopPropagation,
      getPopupContainer
    } = this.props;
    const {
      isOpen,
      rePosKey
    } = this.state;
    const selection = this.renderSelection();
    const pos = 'bottomLeft';
    return /*#__PURE__*/React.createElement(Popover, {
      stopPropagation: stopPropagation,
      getPopupContainer: getPopupContainer,
      zIndex: zIndex,
      motion: motion,
      ref: this.optionsRef,
      content: content,
      visible: isOpen,
      trigger: "custom",
      rePosKey: rePosKey,
      position: pos,
      autoAdjustOverflow: autoAdjustOverflow,
      mouseLeaveDelay: mouseLeaveDelay,
      mouseEnterDelay: mouseEnterDelay,
      onVisibleChange: this.handlePopoverClose
    }, selection);
  }

}

TreeSelect.contextType = ConfigContext;
TreeSelect.propTypes = {
  'aria-describedby': PropTypes.string,
  'aria-errormessage': PropTypes.string,
  'aria-invalid': PropTypes.bool,
  'aria-labelledby': PropTypes.string,
  'aria-required': PropTypes.bool,
  loadedKeys: PropTypes.arrayOf(PropTypes.string),
  loadData: PropTypes.func,
  onLoad: PropTypes.func,
  arrowIcon: PropTypes.node,
  defaultOpen: PropTypes.bool,
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  defaultExpandAll: PropTypes.bool,
  defaultExpandedKeys: PropTypes.array,
  expandAll: PropTypes.bool,
  disabled: PropTypes.bool,
  disableStrictly: PropTypes.bool,
  // Whether to turn on the input box filtering function, when it is a function, it represents a custom filtering function
  filterTreeNode: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  multiple: PropTypes.bool,
  searchPlaceholder: PropTypes.string,
  searchAutoFocus: PropTypes.bool,
  virtualize: PropTypes.object,
  treeNodeFilterProp: PropTypes.string,
  onChange: PropTypes.func,
  onSearch: PropTypes.func,
  onSelect: PropTypes.func,
  onExpand: PropTypes.func,
  onChangeWithObject: PropTypes.bool,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array, PropTypes.object]),
  expandedKeys: PropTypes.array,
  autoExpandParent: PropTypes.bool,
  showClear: PropTypes.bool,
  showSearchClear: PropTypes.bool,
  autoAdjustOverflow: PropTypes.bool,
  showFilteredOnly: PropTypes.bool,
  motionExpand: PropTypes.bool,
  emptyContent: PropTypes.node,
  leafOnly: PropTypes.bool,
  treeData: PropTypes.arrayOf(PropTypes.shape({
    key: PropTypes.string.isRequired,
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    label: PropTypes.any
  })),
  dropdownClassName: PropTypes.string,
  dropdownStyle: PropTypes.object,
  motion: PropTypes.oneOfType([PropTypes.bool, PropTypes.object, PropTypes.func]),
  placeholder: PropTypes.string,
  maxTagCount: PropTypes.number,
  size: PropTypes.oneOf(strings.SIZE_SET),
  className: PropTypes.string,
  style: PropTypes.object,
  treeNodeLabelProp: PropTypes.string,
  suffix: PropTypes.node,
  prefix: PropTypes.node,
  insetLabel: PropTypes.node,
  insetLabelId: PropTypes.string,
  zIndex: PropTypes.number,
  getPopupContainer: PropTypes.func,
  dropdownMatchSelectWidth: PropTypes.bool,
  validateStatus: PropTypes.oneOf(strings.STATUS),
  mouseEnterDelay: PropTypes.number,
  mouseLeaveDelay: PropTypes.number,
  triggerRender: PropTypes.func,
  stopPropagation: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
  outerBottomSlot: PropTypes.node,
  outerTopSlot: PropTypes.node,
  onVisibleChange: PropTypes.func,
  expandAction: PropTypes.oneOf(['click', 'doubleClick', false]),
  searchPosition: PropTypes.oneOf([strings.SEARCH_POSITION_DROPDOWN, strings.SEARCH_POSITION_TRIGGER]),
  clickToHide: PropTypes.bool,
  renderLabel: PropTypes.func,
  renderFullLabel: PropTypes.func,
  labelEllipsis: PropTypes.bool,
  optionListStyle: PropTypes.object,
  searchRender: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  renderSelectedItem: PropTypes.func,
  checkRelation: PropTypes.string,
  'aria-label': PropTypes.string
};
TreeSelect.defaultProps = {
  searchPosition: strings.SEARCH_POSITION_DROPDOWN,
  arrowIcon: /*#__PURE__*/React.createElement(IconChevronDown, null),
  autoExpandParent: false,
  autoAdjustOverflow: true,
  stopPropagation: true,
  motion: true,
  motionExpand: true,
  expandAll: false,
  zIndex: popoverNumbers.DEFAULT_Z_INDEX,
  disableStrictly: false,
  multiple: false,
  filterTreeNode: false,
  size: 'default',
  treeNodeFilterProp: 'label',
  onChangeWithObject: false,
  treeNodeLabelProp: 'label',
  dropdownMatchSelectWidth: true,
  defaultOpen: false,
  showSearchClear: true,
  showClear: false,
  onVisibleChange: _noop,
  expandAction: false,
  clickToHide: true,
  searchAutoFocus: false,
  checkRelation: 'related',
  'aria-label': 'TreeSelect'
};
export default TreeSelect;