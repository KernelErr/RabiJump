import _get from "lodash/get";
import _set from "lodash/set";
import _cloneDeepWith from "lodash/cloneDeepWith";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _Object$keys from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _Array$from from "@babel/runtime-corejs3/core-js-stable/array/from";

/* eslint-disable max-len */

/* argus-disable unPkgSensitiveInfo */
import React from 'react';
import warning from '@douyinfe/semi-foundation/lib/es/utils/warning';
import { findAll } from '@douyinfe/semi-foundation/lib/es/utils/getHighlight';
import { isHTMLElement } from '@douyinfe/semi-foundation/lib/es/utils/dom';
/**
 * stop propagation
 *
 * @param {React.MouseEvent<HTMLElement>} e React mouse event object
 * @param {boolean} noImmediate Skip stopping immediate propagation
 */

export function stopPropagation(e, noImmediate) {
  if (e && typeof e.stopPropagation === 'function') {
    e.stopPropagation();
  }

  if (!noImmediate && e.nativeEvent && typeof e.nativeEvent.stopImmediatePropagation === 'function') {
    e.nativeEvent.stopImmediatePropagation();
  }
}
/**
 *
 * @param {any} value
 * @param {Function} customizer
 * @returns {any}
 * use in Table, Form, Navigation
 */

export function cloneDeep(value, customizer) {
  return _cloneDeepWith(value, v => {
    if (typeof customizer === 'function') {
      return customizer(v);
    }

    if (typeof v === 'function' || /*#__PURE__*/React.isValidElement(v)) {
      return v;
    }

    if (Object.prototype.toString.call(v) === '[object Error]') {
      return v;
    }

    if (_Array$isArray(v) && v.length === 0) {
      const keys = _Object$keys(v);

      if (keys.length) {
        const newArray = [];

        _forEachInstanceProperty(keys).call(keys, key => {
          _set(newArray, key, v[key]);
        }); // internal-issues:887


        warning(_get(process, 'env.NODE_ENV') !== 'production', "[Semi] You may use an out-of-bounds array. In some cases, your program may not behave as expected.\n                    The maximum length of an array is 4294967295.\n                    Please check whether the array subscript in your data exceeds the maximum value of the JS array subscript");
        return newArray;
      } else {
        return undefined;
      }
    }

    return undefined;
  });
}
/**
 * [getHighLightTextHTML description]
 *
 * @param   {string} sourceString [source content text]
 * @param   {Array<string>} searchWords [keywords to be highlighted]
 * @param   {object} option
 * @param   {true}      option.highlightTag [The tag wrapped by the highlighted content, mark is used by default]
 * @param   {true}      option.highlightClassName
 * @param   {true}      option.highlightStyle
 * @param   {boolean}   option.caseSensitive
 *
 * @return  {Array<object>}
 */

export const getHighLightTextHTML = _ref => {
  let {
    sourceString = '',
    searchWords = [],
    option = {
      autoEscape: true,
      caseSensitive: false
    }
  } = _ref;
  const chunks = findAll(_Object$assign({
    sourceString,
    searchWords
  }, option));
  const markEle = option.highlightTag || 'mark';
  const highlightClassName = option.highlightClassName || '';
  const highlightStyle = option.highlightStyle || {};
  return _mapInstanceProperty(chunks).call(chunks, (chunk, index) => {
    const {
      end,
      start,
      highlight
    } = chunk;
    const text = sourceString.substr(start, end - start);

    if (highlight) {
      return /*#__PURE__*/React.createElement(markEle, {
        style: highlightStyle,
        className: highlightClassName,
        key: text + index
      }, text);
    } else {
      return text;
    }
  });
};
/**
 * register matchFn and unMatchFn callback while media query
 * @param {string} media media string
 * @param {object} param param object
 * @returns function
 */

export const registerMediaQuery = (media, _ref2) => {
  let {
    match,
    unmatch,
    callInInit = true
  } = _ref2;

  if (typeof window !== 'undefined') {
    const mediaQueryList = window.matchMedia(media);

    function handlerMediaChange(e) {
      if (e.matches) {
        match && match(e);
      } else {
        unmatch && unmatch(e);
      }
    }

    callInInit && handlerMediaChange(mediaQueryList);

    if (Object.prototype.hasOwnProperty.call(mediaQueryList, 'addEventListener')) {
      mediaQueryList.addEventListener('change', handlerMediaChange);
      return () => mediaQueryList.removeEventListener('change', handlerMediaChange);
    }

    mediaQueryList.addListener(handlerMediaChange);
    return () => mediaQueryList.removeListener(handlerMediaChange);
  }

  return () => undefined;
};
/**
 * Determine whether the incoming element is a built-in icon
 * @param icon 元素
 * @returns boolean
 */

export const isSemiIcon = icon => /*#__PURE__*/React.isValidElement(icon) && _get(icon.type, 'elementType') === 'Icon';
export function getActiveElement() {
  return document ? document.activeElement : null;
}
export function isNodeContainsFocus(node) {
  const activeElement = getActiveElement();
  return activeElement === node || node.contains(activeElement);
}
export function getFocusableElements(node) {
  if (!isHTMLElement(node)) {
    return [];
  }

  const focusableSelectorsList = ["input:not([disabled]):not([tabindex='-1'])", "textarea:not([disabled]):not([tabindex='-1'])", "button:not([disabled]):not([tabindex='-1'])", "a[href]:not([tabindex='-1'])", "select:not([disabled]):not([tabindex='-1'])", "area[href]:not([tabindex='-1'])", "iframe:not([tabindex='-1'])", "object:not([tabindex='-1'])", "*[tabindex]:not([tabindex='-1'])", "*[contenteditable]:not([tabindex='-1'])"];
  const focusableSelectorsStr = focusableSelectorsList.join(','); // we are not filtered elements which are invisible

  const focusableElements = _Array$from(node.querySelectorAll(focusableSelectorsStr));

  return focusableElements;
}