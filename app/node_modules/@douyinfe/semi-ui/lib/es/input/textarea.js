import _isFunction from "lodash/isFunction";
import _omit from "lodash/omit";
import _noop from "lodash/noop";
import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && _indexOfInstanceProperty(e).call(e, p) < 0) t[p] = s[p];

  if (s != null && typeof _Object$getOwnPropertySymbols === "function") for (var i = 0, p = _Object$getOwnPropertySymbols(s); i < p.length; i++) {
    if (_indexOfInstanceProperty(e).call(e, p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
/* eslint-disable no-unused-vars */


import React from 'react';
import cls from 'classnames';
import PropTypes from 'prop-types';
import TextAreaFoundation from '@douyinfe/semi-foundation/lib/es/input/textareaFoundation';
import { cssClasses } from '@douyinfe/semi-foundation/lib/es/input/constants';
import BaseComponent from '../_base/baseComponent';
import '@douyinfe/semi-foundation/lib/es/input/textarea.css';
import { IconClear } from '@douyinfe/semi-icons';
const prefixCls = cssClasses.PREFIX;

class TextArea extends BaseComponent {
  constructor(props) {
    super(props);

    this.handleClear = e => {
      this.foundation.handleClear(e);
    };

    this.setRef = node => {
      this.libRef.current = node;
      const {
        forwardRef
      } = this.props;

      if (typeof forwardRef === 'function') {
        forwardRef(node);
      } else if (forwardRef && typeof forwardRef === 'object') {
        forwardRef.current = node;
      }
    };

    this.state = {
      value: '',
      isFocus: false,
      isHover: false,
      height: 0,
      minLength: props.minLength
    };
    this.focusing = false;
    this.foundation = new TextAreaFoundation(this.adapter);
    this.libRef = /*#__PURE__*/React.createRef();
    this._resizeLock = false;
  }

  get adapter() {
    return _Object$assign(_Object$assign({}, super.adapter), {
      setValue: value => this.setState({
        value
      }, () => {
        if (this.props.autosize) {
          this.foundation.resizeTextarea();
        }
      }),
      getRef: () => this.libRef,
      toggleFocusing: focusing => this.setState({
        isFocus: focusing
      }),
      toggleHovering: hovering => this.setState({
        isHover: hovering
      }),
      notifyChange: (val, e) => {
        this.props.onChange(val, e);
      },
      notifyClear: e => this.props.onClear(e),
      notifyBlur: (val, e) => this.props.onBlur(e),
      notifyFocus: (val, e) => this.props.onFocus(e),
      notifyKeyDown: e => {
        this.props.onKeyDown(e);
      },
      notifyHeightUpdate: height => {
        this.setState({
          height
        });
        this.props.onResize({
          height
        });
      },
      notifyPressEnter: e => {
        this.props.onEnterPress && this.props.onEnterPress(e);
      },
      setMinLength: minLength => this.setState({
        minLength
      })
    });
  }

  static getDerivedStateFromProps(props, state) {
    const willUpdateStates = {};

    if (props.value !== state.cachedValue) {
      willUpdateStates.value = props.value;
      willUpdateStates.cachedValue = props.value;
    }

    return willUpdateStates;
  }

  componentDidMount() {
    this.foundation.init();
    this._resizeListener = null;

    if (this.props.autosize) {
      // Working around Firefox bug which runs resize listeners even when other JS is running at the same moment
      // causing competing rerenders (due to setState in the listener) in React.
      // More can be found here - facebook/react#6324
      // // Reference to https://github.com/andreypopp/react-textarea-autosize/
      this._resizeListener = () => {
        if (this._resizeLock) {
          return;
        }

        this._resizeLock = true;
        this.foundation.resizeTextarea(() => {
          this._resizeLock = false;
        });
      };

      window.addEventListener('resize', this._resizeListener);
    }
  }

  componentWillUnmount() {
    this.foundation.destroy();
    this._resizeListener && window.removeEventListener('resize', this._resizeListener);
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.props.value !== prevProps.value && this.props.autosize) {
      this.foundation.resizeTextarea();
    }
  }

  renderClearBtn() {
    const {
      showClear
    } = this.props;
    const displayClearBtn = this.foundation.isAllowClear();
    const clearCls = cls("".concat(prefixCls, "-clearbtn"), {
      ["".concat(prefixCls, "-clearbtn-hidden")]: !displayClearBtn
    });

    if (showClear) {
      return (
        /*#__PURE__*/
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
        React.createElement("div", {
          className: clearCls,
          onClick: this.handleClear
        }, /*#__PURE__*/React.createElement(IconClear, null))
      );
    }

    return null;
  }

  renderCounter() {
    let counter, current, total, countCls;
    const {
      showCounter,
      maxCount,
      getValueLength
    } = this.props;

    if (showCounter || maxCount) {
      const {
        value
      } = this.state; // eslint-disable-next-line no-nested-ternary

      current = value ? _isFunction(getValueLength) ? getValueLength(value) : value.length : 0;
      total = maxCount || null;
      countCls = cls("".concat(prefixCls, "-textarea-counter"), {
        ["".concat(prefixCls, "-textarea-counter-exceed")]: current > total
      });
      counter = /*#__PURE__*/React.createElement("div", {
        className: countCls
      }, current, total ? '/' : null, total);
    } else {
      counter = null;
    }

    return counter;
  }

  render() {
    var _context;

    const _a = this.props,
          {
      autosize,
      placeholder,
      onEnterPress,
      onResize,
      // resize,
      disabled,
      readonly,
      className,
      showCounter,
      validateStatus,
      maxCount,
      defaultValue,
      style,
      forwardRef,
      getValueLength,
      maxLength,
      minLength,
      showClear
    } = _a,
          rest = __rest(_a, ["autosize", "placeholder", "onEnterPress", "onResize", "disabled", "readonly", "className", "showCounter", "validateStatus", "maxCount", "defaultValue", "style", "forwardRef", "getValueLength", "maxLength", "minLength", "showClear"]);

    const {
      isFocus,
      value,
      minLength: stateMinLength
    } = this.state;
    const wrapperCls = cls(className, "".concat(prefixCls, "-textarea-wrapper"), {
      ["".concat(prefixCls, "-textarea-wrapper-disabled")]: disabled,
      ["".concat(prefixCls, "-textarea-wrapper-readonly")]: readonly,
      [_concatInstanceProperty(_context = "".concat(prefixCls, "-textarea-wrapper-")).call(_context, validateStatus)]: Boolean(validateStatus),
      ["".concat(prefixCls, "-textarea-wrapper-focus")]: isFocus // [`${prefixCls}-textarea-wrapper-resize`]: !autosize && resize,

    }); // const ref = this.props.forwardRef || this.textAreaRef;

    const itemCls = cls("".concat(prefixCls, "-textarea"), {
      ["".concat(prefixCls, "-textarea-disabled")]: disabled,
      ["".concat(prefixCls, "-textarea-readonly")]: readonly,
      ["".concat(prefixCls, "-textarea-autosize")]: autosize,
      ["".concat(prefixCls, "-textarea-showClear")]: showClear
    });

    const itemProps = _Object$assign(_Object$assign({}, _omit(rest, 'insetLabel', 'insetLabelId', 'getValueLength', 'onClear', 'showClear')), {
      className: itemCls,
      disabled,
      readOnly: readonly,
      placeholder: !placeholder ? null : placeholder,
      onChange: e => this.foundation.handleChange(e.target.value, e),
      onFocus: e => this.foundation.handleFocus(e),
      onBlur: e => this.foundation.handleBlur(e.nativeEvent),
      onKeyDown: e => this.foundation.handleKeyDown(e),
      value: value === null || value === undefined ? '' : value
    });

    if (!_isFunction(getValueLength)) {
      itemProps.maxLength = maxLength;
    }

    if (stateMinLength) {
      itemProps.minLength = stateMinLength;
    }

    return /*#__PURE__*/React.createElement("div", {
      className: wrapperCls,
      style: style,
      onMouseEnter: e => this.foundation.handleMouseEnter(e),
      onMouseLeave: e => this.foundation.handleMouseLeave(e)
    }, /*#__PURE__*/React.createElement("textarea", _Object$assign({}, itemProps, {
      ref: this.setRef
    })), this.renderClearBtn(), this.renderCounter());
  }

}

TextArea.propTypes = {
  autosize: PropTypes.bool,
  placeholder: PropTypes.string,
  value: PropTypes.string,
  rows: PropTypes.number,
  cols: PropTypes.number,
  maxCount: PropTypes.number,
  onEnterPress: PropTypes.func,
  validateStatus: PropTypes.string,
  className: PropTypes.string,
  style: PropTypes.object,
  showClear: PropTypes.bool,
  onClear: PropTypes.func,
  onResize: PropTypes.func,
  getValueLength: PropTypes.func // TODO
  // resize: PropTypes.bool,

};
TextArea.defaultProps = {
  autosize: false,
  rows: 4,
  cols: 20,
  showCounter: false,
  showClear: false,
  onEnterPress: _noop,
  onChange: _noop,
  onBlur: _noop,
  onFocus: _noop,
  onKeyDown: _noop,
  onResize: _noop,
  onClear: _noop // resize: false,

};
const ForwardTextarea = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(TextArea, _Object$assign({}, props, {
  forwardRef: ref
})));
export default ForwardTextarea;