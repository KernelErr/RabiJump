import _isArray from "lodash/isArray";
import _isEmpty from "lodash/isEmpty";
import _omit from "lodash/omit";
import _noop from "lodash/noop";
import _isEqual from "lodash/isEqual";
import _Map from "@babel/runtime-corejs3/core-js-stable/map";
import _Set from "@babel/runtime-corejs3/core-js-stable/set";
import _bindInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/bind";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
import _filterInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/filter";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _findInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/find";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _valuesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/values";
import React from 'react';
import cls from 'classnames';
import { SortableContainer, SortableElement, SortableHandle } from 'react-sortable-hoc';
import PropTypes from 'prop-types';
import TransferFoundation from '@douyinfe/semi-foundation/lib/es/transfer/foundation';
import { _generateDataByType, _generateSelectedItems } from '@douyinfe/semi-foundation/lib/es/transfer/transferUtils';
import { cssClasses, strings } from '@douyinfe/semi-foundation/lib/es/transfer/constants';
import '@douyinfe/semi-foundation/lib/es/transfer/transfer.css';
import BaseComponent from '../_base/baseComponent';
import LocaleConsumer from '../locale/localeConsumer';
import { Checkbox } from '../checkbox/index';
import Input from '../input/index';
import Spin from '../spin';
import Button from '../button';
import Tree from '../tree';
import { IconClose, IconSearch, IconHandle } from '@douyinfe/semi-icons';
const prefixcls = cssClasses.PREFIX;

class Transfer extends BaseComponent {
  constructor(props) {
    var _context, _context2, _context3;

    super(props);
    this._treeRef = null;
    const {
      defaultValue = [],
      dataSource,
      type
    } = props;
    this.foundation = new TransferFoundation(this.adapter);
    this.state = {
      data: [],
      selectedItems: new _Map(),
      searchResult: new _Set(),
      inputValue: ''
    };

    if (Boolean(dataSource) && _isArray(dataSource)) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore Avoid reporting errors this.state.xxx is read-only
      this.state.data = _generateDataByType(dataSource, type);
    }

    if (Boolean(defaultValue) && _isArray(defaultValue)) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore Avoid reporting errors this.state.xxx is read-only
      this.state.selectedItems = _generateSelectedItems(defaultValue, this.state.data);
    }

    this.onSelectOrRemove = _bindInstanceProperty(_context = this.onSelectOrRemove).call(_context, this);
    this.onInputChange = _bindInstanceProperty(_context2 = this.onInputChange).call(_context2, this);
    this.onSortEnd = _bindInstanceProperty(_context3 = this.onSortEnd).call(_context3, this);
  }

  static getDerivedStateFromProps(props, state) {
    const {
      value,
      dataSource,
      type,
      filter
    } = props;
    const mergedState = {};
    let newData = state.data;
    let newSelectedItems = state.selectedItems;

    if (Boolean(dataSource) && _Array$isArray(dataSource)) {
      newData = _generateDataByType(dataSource, type);
      mergedState.data = newData;
    }

    if (Boolean(value) && _Array$isArray(value)) {
      newSelectedItems = _generateSelectedItems(value, newData);
      mergedState.selectedItems = newSelectedItems;
    }

    if (!_isEqual(state.data, newData)) {
      if (typeof state.inputValue === 'string' && state.inputValue !== '') {
        const filterFunc = typeof filter === 'function' ? item => filter(state.inputValue, item) : item => {
          var _context4;

          return typeof item.label === 'string' && _includesInstanceProperty(_context4 = item.label).call(_context4, state.inputValue);
        };

        const searchData = _filterInstanceProperty(newData).call(newData, filterFunc);

        const searchResult = new _Set(_mapInstanceProperty(searchData).call(searchData, item => item.key));
        mergedState.searchResult = searchResult;
      }
    }

    return _isEmpty(mergedState) ? null : mergedState;
  }

  get adapter() {
    return _Object$assign(_Object$assign({}, super.adapter), {
      getSelected: () => new _Map(this.state.selectedItems),
      updateSelected: selectedItems => {
        this.setState({
          selectedItems
        });
      },
      notifyChange: (values, items) => {
        this.props.onChange(values, items);
      },
      notifySearch: input => {
        this.props.onSearch(input);
      },
      notifySelect: item => {
        this.props.onSelect(item);
      },
      notifyDeselect: item => {
        this.props.onDeselect(item);
      },
      updateInput: input => {
        this.setState({
          inputValue: input
        });
      },
      updateSearchResult: searchResult => {
        this.setState({
          searchResult
        });
      },
      searchTree: keyword => {
        this._treeRef && this._treeRef.search(keyword); // TODO check this._treeRef.current?
      }
    });
  }

  onInputChange(value) {
    this.foundation.handleInputChange(value);
  }

  onSelectOrRemove(item) {
    this.foundation.handleSelectOrRemove(item);
  }

  onSortEnd(callbackProps) {
    this.foundation.handleSortEnd(callbackProps);
  }

  renderFilter(locale) {
    const {
      inputProps,
      filter,
      disabled
    } = this.props;

    if (typeof filter === 'boolean' && !filter) {
      return null;
    }

    return /*#__PURE__*/React.createElement("div", {
      role: "search",
      "aria-label": "Transfer filter",
      className: "".concat(prefixcls, "-filter")
    }, /*#__PURE__*/React.createElement(Input, _Object$assign({
      prefix: /*#__PURE__*/React.createElement(IconSearch, null),
      placeholder: locale.placeholder,
      showClear: true,
      value: this.state.inputValue,
      disabled: disabled,
      onChange: this.onInputChange
    }, inputProps)));
  }

  renderHeader(headerConfig) {
    const {
      disabled
    } = this.props;
    const {
      totalContent,
      allContent,
      onAllClick,
      type,
      showButton
    } = headerConfig;
    const headerCls = cls({
      ["".concat(prefixcls, "-header")]: true,
      ["".concat(prefixcls, "-right-header")]: type === 'right',
      ["".concat(prefixcls, "-left-header")]: type === 'left'
    });
    return /*#__PURE__*/React.createElement("div", {
      className: headerCls
    }, /*#__PURE__*/React.createElement("span", {
      className: "".concat(prefixcls, "-header-total")
    }, totalContent), showButton ? /*#__PURE__*/React.createElement(Button, {
      theme: "borderless",
      disabled: disabled,
      type: "tertiary",
      size: "small",
      className: "".concat(prefixcls, "-header-all"),
      onClick: onAllClick
    }, allContent) : null);
  }

  renderLeftItem(item, index) {
    const {
      renderSourceItem,
      disabled
    } = this.props;
    const {
      selectedItems
    } = this.state;
    const checked = selectedItems.has(item.key);

    if (renderSourceItem) {
      return renderSourceItem(_Object$assign(_Object$assign({}, item), {
        checked,
        onChange: () => this.onSelectOrRemove(item)
      }));
    }

    const leftItemCls = cls({
      ["".concat(prefixcls, "-item")]: true,
      ["".concat(prefixcls, "-item-disabled")]: item.disabled
    });
    return /*#__PURE__*/React.createElement(Checkbox, {
      key: index,
      disabled: item.disabled || disabled,
      className: leftItemCls,
      checked: checked,
      role: "listitem",
      onChange: () => this.onSelectOrRemove(item),
      "x-semi-children-alias": "dataSource[".concat(index, "].label")
    }, item.label);
  }

  renderLeft(locale) {
    var _context5;

    const {
      data,
      selectedItems,
      inputValue,
      searchResult
    } = this.state;
    const {
      loading,
      type,
      emptyContent,
      renderSourcePanel,
      dataSource
    } = this.props;
    const totalToken = locale.total;
    const inSearchMode = inputValue !== '';
    const showNumber = inSearchMode ? searchResult.size : data.length;
    const filterData = inSearchMode ? _filterInstanceProperty(data).call(data, item => searchResult.has(item.key)) : data; // Whether to select all should be a judgment, whether the filtered data on the left is a subset of the selected items
    // For example, the filtered data on the left is 1, 3, 4;
    // The selected option is 1,2,3,4, it is true
    // The selected option is 2,3,4, then it is false

    const leftContainesNotInSelected = Boolean(_findInstanceProperty(filterData).call(filterData, f => !selectedItems.has(f.key)));
    const totalText = totalToken.replace('${total}', "".concat(showNumber));
    const headerConfig = {
      totalContent: totalText,
      allContent: leftContainesNotInSelected ? locale.selectAll : locale.clearSelectAll,
      onAllClick: () => this.foundation.handleAll(leftContainesNotInSelected),
      type: 'left',
      showButton: type !== strings.TYPE_TREE_TO_LIST
    };
    const inputCom = this.renderFilter(locale);
    const headerCom = this.renderHeader(headerConfig);
    const noMatch = inSearchMode && searchResult.size === 0;
    const emptySearch = emptyContent.search ? emptyContent.search : locale.emptySearch;
    const emptyLeft = emptyContent.left ? emptyContent.left : locale.emptyLeft;
    const emptyCom = this.renderEmpty('left', inputValue ? emptySearch : emptyLeft);
    const loadingCom = /*#__PURE__*/React.createElement(Spin, null);
    let content = null;

    switch (true) {
      case loading:
        content = loadingCom;
        break;

      case noMatch:
        content = emptyCom;
        break;

      case type === strings.TYPE_TREE_TO_LIST:
        content = /*#__PURE__*/React.createElement(React.Fragment, null, headerCom, this.renderLeftTree());
        break;

      case !noMatch && (type === strings.TYPE_LIST || type === strings.TYPE_GROUP_LIST):
        content = /*#__PURE__*/React.createElement(React.Fragment, null, headerCom, this.renderLeftList(filterData));
        break;

      default:
        content = null;
        break;
    }

    const {
      values
    } = this.foundation.getValuesAndItemsFromMap(selectedItems);
    const renderProps = {
      loading,
      noMatch,
      filterData,
      sourceData: data,
      propsDataSource: dataSource,
      allChecked: !leftContainesNotInSelected,
      showNumber,
      inputValue,
      selectedItems,
      value: values,
      onSelect: _bindInstanceProperty(_context5 = this.foundation.handleSelect).call(_context5, this.foundation),
      onAllClick: () => this.foundation.handleAll(leftContainesNotInSelected),
      onSearch: this.onInputChange,
      onSelectOrRemove: item => this.onSelectOrRemove(item)
    };

    if (renderSourcePanel) {
      return renderSourcePanel(renderProps);
    }

    return /*#__PURE__*/React.createElement("section", {
      className: "".concat(prefixcls, "-left")
    }, inputCom, content);
  }

  renderGroupTitle(group, index) {
    const groupCls = cls("".concat(prefixcls, "-group-title"));
    return /*#__PURE__*/React.createElement("div", {
      className: groupCls,
      key: "title-".concat(index)
    }, group.title);
  }

  renderLeftTree() {
    const {
      selectedItems
    } = this.state;
    const {
      disabled,
      dataSource,
      treeProps
    } = this.props;
    const {
      values
    } = this.foundation.getValuesAndItemsFromMap(selectedItems);

    const onChange = value => {
      this.foundation.handleSelect(value);
    };

    const restTreeProps = _omit(treeProps, ['value', 'ref', 'onChange']);

    return /*#__PURE__*/React.createElement(Tree, _Object$assign({
      disabled: disabled,
      treeData: dataSource,
      multiple: true,
      disableStrictly: true,
      value: values,
      defaultExpandAll: true,
      leafOnly: true,
      ref: tree => this._treeRef = tree,
      filterTreeNode: true,
      searchRender: false,
      searchStyle: {
        padding: 0
      },
      style: {
        flex: 1,
        overflow: 'overlay'
      },
      onChange: onChange
    }, restTreeProps));
  }

  renderLeftList(visibileItems) {
    const content = [];
    const groupStatus = new _Map();

    _forEachInstanceProperty(visibileItems).call(visibileItems, (item, index) => {
      const parentGroup = item._parent;
      const optionContent = this.renderLeftItem(item, index);

      if (parentGroup && groupStatus.has(parentGroup.title)) {
        // group content already insert
        content.push(optionContent);
      } else if (parentGroup) {
        const groupContent = this.renderGroupTitle(parentGroup, index);
        groupStatus.set(parentGroup.title, true);
        content.push(groupContent);
        content.push(optionContent);
      } else {
        content.push(optionContent);
      }
    });

    return /*#__PURE__*/React.createElement("div", {
      className: "".concat(prefixcls, "-left-list"),
      role: "list",
      "aria-label": "Option list"
    }, content);
  }

  renderRightItem(item) {
    const {
      renderSelectedItem,
      draggable,
      type,
      showPath
    } = this.props;

    const onRemove = () => this.foundation.handleSelectOrRemove(item);

    const rightItemCls = cls({
      ["".concat(prefixcls, "-item")]: true,
      ["".concat(prefixcls, "-right-item")]: true,
      ["".concat(prefixcls, "-right-item-draggable")]: draggable
    });
    const shouldShowPath = type === strings.TYPE_TREE_TO_LIST && showPath === true;
    const label = shouldShowPath ? this.foundation._generatePath(item) : item.label;

    if (renderSelectedItem) {
      return renderSelectedItem(_Object$assign(_Object$assign({}, item), {
        onRemove,
        sortableHandle: SortableHandle
      }));
    }

    const DragHandle = SortableHandle(() => /*#__PURE__*/React.createElement(IconHandle, {
      role: "button",
      "aria-label": "Drag and sort",
      className: "".concat(prefixcls, "-right-item-drag-handler")
    }));
    return (
      /*#__PURE__*/
      // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
      React.createElement("div", {
        role: "listitem",
        className: rightItemCls,
        key: item.key
      }, draggable ? /*#__PURE__*/React.createElement(DragHandle, null) : null, /*#__PURE__*/React.createElement("div", {
        className: "".concat(prefixcls, "-right-item-text")
      }, label), /*#__PURE__*/React.createElement(IconClose, {
        onClick: onRemove,
        "aria-disabled": item.disabled,
        className: cls("".concat(prefixcls, "-item-close-icon"), {
          ["".concat(prefixcls, "-item-close-icon-disabled")]: item.disabled
        })
      }))
    );
  }

  renderEmpty(type, emptyText) {
    const emptyCls = cls({
      ["".concat(prefixcls, "-empty")]: true,
      ["".concat(prefixcls, "-right-empty")]: type === 'right',
      ["".concat(prefixcls, "-left-empty")]: type === 'left'
    });
    return /*#__PURE__*/React.createElement("div", {
      "aria-label": "empty",
      className: emptyCls
    }, emptyText);
  }

  renderRightSortableList(selectedData) {
    // when choose some items && draggable is true
    const SortableItem = SortableElement(props => this.renderRightItem(props.item));
    const SortableList = SortableContainer(_ref => {
      let {
        items
      } = _ref;
      return /*#__PURE__*/React.createElement("div", {
        className: "".concat(prefixcls, "-right-list"),
        role: "list",
        "aria-label": "Selected list"
      }, _mapInstanceProperty(items).call(items, (item, index) =>
      /*#__PURE__*/
      // @ts-ignore skip SortableItem type check
      React.createElement(SortableItem, {
        key: item.label,
        index: index,
        item: item
      }))) // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore see reasons: https://github.com/clauderic/react-sortable-hoc/issues/206
      ;
    }, {
      distance: 10
    }); // @ts-ignore skip SortableItem type check

    const sortList = /*#__PURE__*/React.createElement(SortableList, {
      useDragHandle: true,
      onSortEnd: this.onSortEnd,
      items: selectedData
    });
    return sortList;
  }

  renderRight(locale) {
    const {
      selectedItems
    } = this.state;
    const {
      emptyContent,
      renderSelectedPanel,
      draggable
    } = this.props;
    const selectedData = [..._valuesInstanceProperty(selectedItems).call(selectedItems)]; // when custom render panel

    const renderProps = {
      length: selectedData.length,
      selectedData,
      onClear: () => this.foundation.handleClear(),
      onRemove: item => this.foundation.handleSelectOrRemove(item),
      onSortEnd: props => this.onSortEnd(props)
    };

    if (renderSelectedPanel) {
      return renderSelectedPanel(renderProps);
    }

    const selectedToken = locale.selected;
    const selectedText = selectedToken.replace('${total}', "".concat(selectedData.length));
    const headerConfig = {
      totalContent: selectedText,
      allContent: locale.clear,
      onAllClick: () => this.foundation.handleClear(),
      type: 'right',
      showButton: Boolean(selectedData.length)
    };
    const headerCom = this.renderHeader(headerConfig);
    const emptyCom = this.renderEmpty('right', emptyContent.right ? emptyContent.right : locale.emptyRight);
    const panelCls = "".concat(prefixcls, "-right");
    let content = null;

    switch (true) {
      // when empty
      case !selectedData.length:
        content = emptyCom;
        break;

      case selectedData.length && !draggable:
        const list = /*#__PURE__*/React.createElement("div", {
          className: "".concat(prefixcls, "-right-list"),
          role: "list",
          "aria-label": "Selected list"
        }, _mapInstanceProperty(selectedData).call(selectedData, item => this.renderRightItem(_Object$assign({}, item))));
        content = list;
        break;

      case selectedData.length && draggable:
        content = this.renderRightSortableList(selectedData);
        break;

      default:
        break;
    }

    return /*#__PURE__*/React.createElement("section", {
      className: panelCls
    }, headerCom, content);
  }

  render() {
    const {
      className,
      style,
      disabled,
      renderSelectedPanel,
      renderSourcePanel
    } = this.props;
    const transferCls = cls(prefixcls, className, {
      ["".concat(prefixcls, "-disabled")]: disabled,
      ["".concat(prefixcls, "-custom-panel")]: renderSelectedPanel && renderSourcePanel
    });
    return /*#__PURE__*/React.createElement(LocaleConsumer, {
      componentName: "Transfer"
    }, locale => /*#__PURE__*/React.createElement("div", {
      className: transferCls,
      style: style
    }, this.renderLeft(locale), this.renderRight(locale)));
  }

}

Transfer.propTypes = {
  style: PropTypes.object,
  className: PropTypes.string,
  disabled: PropTypes.bool,
  dataSource: PropTypes.array,
  filter: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  onSearch: PropTypes.func,
  inputProps: PropTypes.object,
  value: PropTypes.array,
  defaultValue: PropTypes.array,
  onChange: PropTypes.func,
  onSelect: PropTypes.func,
  onDeselect: PropTypes.func,
  renderSourceItem: PropTypes.func,
  renderSelectedItem: PropTypes.func,
  loading: PropTypes.bool,
  type: PropTypes.oneOf(['list', 'groupList', 'treeList']),
  treeProps: PropTypes.object,
  showPath: PropTypes.bool,
  emptyContent: PropTypes.shape({
    search: PropTypes.node,
    left: PropTypes.node,
    right: PropTypes.node
  }),
  renderSourcePanel: PropTypes.func,
  renderSelectedPanel: PropTypes.func,
  draggable: PropTypes.bool
};
Transfer.defaultProps = {
  type: strings.TYPE_LIST,
  dataSource: [],
  onSearch: _noop,
  onChange: _noop,
  onSelect: _noop,
  onDeselect: _noop,
  onClear: _noop,
  defaultValue: [],
  emptyContent: {},
  showPath: false
};
export default Transfer;