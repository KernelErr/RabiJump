import _isFunction from "lodash/isFunction";
import _isEmpty from "lodash/isEmpty";
import _each from "lodash/each";
import _omit from "lodash/omit";
import _get from "lodash/get";
import _noop from "lodash/noop";
import _throttle from "lodash/throttle";
import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _Object$getOwnPropertySymbols from "@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _setTimeout from "@babel/runtime-corejs3/core-js-stable/set-timeout";

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && _indexOfInstanceProperty(e).call(e, p) < 0) t[p] = s[p];

  if (s != null && typeof _Object$getOwnPropertySymbols === "function") for (var i = 0, p = _Object$getOwnPropertySymbols(s); i < p.length; i++) {
    if (_indexOfInstanceProperty(e).call(e, p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
/* eslint-disable prefer-destructuring, max-lines-per-function, react/no-find-dom-node, max-len, @typescript-eslint/no-empty-function */


import React, { isValidElement, cloneElement } from 'react';
import ReactDOM from 'react-dom';
import classNames from 'classnames';
import PropTypes from 'prop-types';
import { BASE_CLASS_PREFIX } from '@douyinfe/semi-foundation/lib/es/base/constants';
import warning from '@douyinfe/semi-foundation/lib/es/utils/warning';
import Event from '@douyinfe/semi-foundation/lib/es/utils/Event';
import { convertDOMRectToObject } from '@douyinfe/semi-foundation/lib/es/utils/dom';
import TooltipFoundation from '@douyinfe/semi-foundation/lib/es/tooltip/foundation';
import { strings, cssClasses, numbers } from '@douyinfe/semi-foundation/lib/es/tooltip/constants';
import { getUuidShort } from '@douyinfe/semi-foundation/lib/es/utils/uuid';
import '@douyinfe/semi-foundation/lib/es/tooltip/tooltip.css';
import BaseComponent from '../_base/baseComponent';
import { isHTMLElement } from '../_base/reactUtils';
import { getActiveElement, getFocusableElements, stopPropagation } from '../_utils';
import Portal from '../_portal/index';
import ConfigContext from '../configProvider/context';
import TriangleArrow from './TriangleArrow';
import TriangleArrowVertical from './TriangleArrowVertical';
import TooltipTransition from './TooltipStyledTransition';
import ArrowBoundingShape from './ArrowBoundingShape';
const prefix = cssClasses.PREFIX;
const positionSet = strings.POSITION_SET;
const triggerSet = strings.TRIGGER_SET;
const blockDisplays = ['flex', 'block', 'table', 'flow-root', 'grid'];

const defaultGetContainer = () => document.body;

export default class Tooltip extends BaseComponent {
  constructor(props) {
    super(props);

    this.setContainerEl = node => this.containerEl = {
      current: node
    };

    this.isSpecial = elem => {
      if (isHTMLElement(elem)) {
        return Boolean(elem.disabled);
      } else if ( /*#__PURE__*/isValidElement(elem)) {
        const disabled = _get(elem, 'props.disabled');

        if (disabled) {
          return strings.STATUS_DISABLED;
        }

        const loading = _get(elem, 'props.loading');
        /* Only judge the loading state of the Button, and no longer judge other components */


        const isButton = !_isEmpty(elem) && !_isEmpty(elem.type) && elem.type.name === 'Button' || elem.type.name === 'IconButton';

        if (loading && isButton) {
          return strings.STATUS_LOADING;
        }
      }

      return false;
    }; // willEnter = () => {
    // this.foundation.calcPosition();
    // this.setState({ visible: true });
    // };


    this.didLeave = () => {
      this.adapter.unregisterClickOutsideHandler();
      this.adapter.unregisterScrollHandler();
      this.adapter.unregisterResizeHandler();
      this.adapter.removePortal();
    };

    this.renderIcon = () => {
      const {
        placement
      } = this.state;
      const {
        showArrow,
        prefixCls,
        style
      } = this.props;
      let icon = null;
      const triangleCls = classNames(["".concat(prefixCls, "-icon-arrow")]);

      const bgColor = _get(style, 'backgroundColor');

      const iconComponent = _includesInstanceProperty(placement).call(placement, 'left') || _includesInstanceProperty(placement).call(placement, 'right') ? /*#__PURE__*/React.createElement(TriangleArrowVertical, null) : /*#__PURE__*/React.createElement(TriangleArrow, null);

      if (showArrow) {
        if ( /*#__PURE__*/isValidElement(showArrow)) {
          icon = showArrow;
        } else {
          icon = /*#__PURE__*/React.cloneElement(iconComponent, {
            className: triangleCls,
            style: {
              color: bgColor,
              fill: 'currentColor'
            }
          });
        }
      }

      return icon;
    };

    this.handlePortalInnerClick = e => {
      if (this.props.clickToHide) {
        this.foundation.hide();
      }

      if (this.props.stopPropagation) {
        stopPropagation(e);
      }
    };

    this.handlePortalMouseDown = e => {
      if (this.props.stopPropagation) {
        stopPropagation(e);
      }
    };

    this.handlePortalInnerKeyDown = e => {
      this.foundation.handleContainerKeydown(e);
    };

    this.renderContentNode = content => {
      const contentProps = {
        initialFocusRef: this.initialFocusRef
      };
      return !_isFunction(content) ? content : content(contentProps);
    };

    this.renderPortal = () => {
      const {
        containerStyle = {},
        visible,
        portalEventSet,
        placement,
        transitionState,
        id,
        isPositionUpdated
      } = this.state;
      const {
        prefixCls,
        content,
        showArrow,
        style,
        motion,
        role,
        zIndex
      } = this.props;
      const contentNode = this.renderContentNode(content);
      const {
        className: propClassName
      } = this.props;
      const direction = this.context.direction;
      const className = classNames(propClassName, {
        ["".concat(prefixCls, "-wrapper")]: true,
        ["".concat(prefixCls, "-wrapper-show")]: visible,
        ["".concat(prefixCls, "-with-arrow")]: Boolean(showArrow),
        ["".concat(prefixCls, "-rtl")]: direction === 'rtl'
      });
      const icon = this.renderIcon();

      const portalInnerStyle = _omit(containerStyle, motion ? ['transformOrigin'] : undefined);

      const transformOrigin = _get(containerStyle, 'transformOrigin');

      const inner = motion && isPositionUpdated ? /*#__PURE__*/React.createElement(TooltipTransition, {
        position: placement,
        didLeave: this.didLeave,
        motion: motion
      }, transitionState === 'enter' ? _ref => {
        let {
          animateCls,
          animateStyle,
          animateEvents
        } = _ref;
        return /*#__PURE__*/React.createElement("div", _Object$assign({
          className: classNames(className, animateCls),
          style: _Object$assign(_Object$assign(_Object$assign({
            visibility: 'visible'
          }, animateStyle), {
            transformOrigin
          }), style)
        }, portalEventSet, animateEvents, {
          role: role,
          "x-placement": placement,
          id: id
        }), contentNode, icon);
      } : null) : /*#__PURE__*/React.createElement("div", _Object$assign({
        className: className
      }, portalEventSet, {
        "x-placement": placement,
        style: _Object$assign({
          visibility: motion ? 'hidden' : 'visible'
        }, style)
      }), contentNode, icon);
      return /*#__PURE__*/React.createElement(Portal, {
        getPopupContainer: this.props.getPopupContainer,
        style: {
          zIndex
        }
      }, /*#__PURE__*/React.createElement("div", {
        className: "".concat(BASE_CLASS_PREFIX, "-portal-inner"),
        style: portalInnerStyle,
        ref: this.setContainerEl,
        onClick: this.handlePortalInnerClick,
        onMouseDown: this.handlePortalMouseDown,
        onKeyDown: this.handlePortalInnerKeyDown
      }, inner));
    };

    this.wrapSpan = elem => {
      const {
        wrapperClassName
      } = this.props;

      const display = _get(elem, 'props.style.display');

      const block = _get(elem, 'props.block');

      const style = {
        display: 'inline-block'
      };

      if (block || _includesInstanceProperty(blockDisplays).call(blockDisplays, display)) {
        style.width = '100%';
      } // eslint-disable-next-line jsx-a11y/no-static-element-interactions


      return /*#__PURE__*/React.createElement("span", {
        className: wrapperClassName,
        style: style
      }, elem);
    };

    this.mergeEvents = (rawEvents, events) => {
      const mergedEvents = {};

      _each(events, (handler, key) => {
        if (typeof handler === 'function') {
          mergedEvents[key] = function () {
            handler(...arguments);

            if (rawEvents && typeof rawEvents[key] === 'function') {
              rawEvents[key](...arguments);
            }
          };
        }
      });

      return mergedEvents;
    };

    this.state = {
      visible: false,

      /**
       *
       * Note: The transitionState parameter is equivalent to isInsert
       */
      transitionState: '',
      triggerEventSet: {},
      portalEventSet: {},
      containerStyle: {// zIndex: props.zIndex,
      },
      isInsert: false,
      placement: props.position || 'top',
      transitionStyle: {},
      isPositionUpdated: false,
      id: props.wrapperId // auto generate id, will be used by children.aria-describedby & content.id, improve a11y

    };
    this.foundation = new TooltipFoundation(this.adapter);
    this.eventManager = new Event();
    this.triggerEl = /*#__PURE__*/React.createRef();
    this.containerEl = /*#__PURE__*/React.createRef();
    this.initialFocusRef = /*#__PURE__*/React.createRef();
    this.clickOutsideHandler = null;
    this.resizeHandler = null;
    this.isWrapped = false; // Identifies whether a span element is wrapped

    this.containerPosition = undefined;
  }

  get adapter() {
    var _this = this;

    return _Object$assign(_Object$assign({}, super.adapter), {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      on: function () {
        return _this.eventManager.on(...arguments);
      },
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      off: function () {
        return _this.eventManager.off(...arguments);
      },
      insertPortal: (content, _a) => {
        var {
          position
        } = _a,
            containerStyle = __rest(_a, ["position"]);

        this.setState({
          isInsert: true,
          transitionState: 'enter',
          containerStyle: _Object$assign(_Object$assign({}, this.state.containerStyle), containerStyle)
        }, () => {
          _setTimeout(() => {
            // waiting child component mounted
            this.eventManager.emit('portalInserted');
          }, 0);
        });
      },
      removePortal: () => {
        this.setState({
          isInsert: false,
          isPositionUpdated: false
        });
      },
      getEventName: () => ({
        mouseEnter: 'onMouseEnter',
        mouseLeave: 'onMouseLeave',
        mouseOut: 'onMouseOut',
        mouseOver: 'onMouseOver',
        click: 'onClick',
        focus: 'onFocus',
        blur: 'onBlur',
        keydown: 'onKeyDown'
      }),
      registerTriggerEvent: triggerEventSet => {
        this.setState({
          triggerEventSet
        });
      },
      unregisterTriggerEvent: () => {},
      registerPortalEvent: portalEventSet => {
        this.setState({
          portalEventSet
        });
      },
      unregisterPortalEvent: () => {},
      getTriggerBounding: () => {
        // eslint-disable-next-line
        // It may be a React component or an html element
        // There is no guarantee that triggerE l.current can get the real dom, so call findDOMNode to ensure that you can get the real dom
        const triggerDOM = this.adapter.getTriggerNode();
        this.triggerEl.current = triggerDOM;
        return triggerDOM && triggerDOM.getBoundingClientRect();
      },
      // Gets the outer size of the specified container
      getPopupContainerRect: () => {
        const container = this.getPopupContainer();
        let rect = null;

        if (container && isHTMLElement(container)) {
          const boundingRect = convertDOMRectToObject(container.getBoundingClientRect());
          rect = _Object$assign(_Object$assign({}, boundingRect), {
            scrollLeft: container.scrollLeft,
            scrollTop: container.scrollTop
          });
        }

        return rect;
      },
      containerIsBody: () => {
        const container = this.getPopupContainer();
        return container === document.body;
      },
      containerIsRelative: () => {
        const container = this.getPopupContainer();
        const computedStyle = window.getComputedStyle(container);
        return computedStyle.getPropertyValue('position') === 'relative';
      },
      containerIsRelativeOrAbsolute: () => {
        var _context;

        return _includesInstanceProperty(_context = ['relative', 'absolute']).call(_context, this.containerPosition);
      },
      // Get the size of the pop-up layer
      getWrapperBounding: () => {
        const el = this.containerEl && this.containerEl.current;
        return el && el.getBoundingClientRect();
      },
      getDocumentElementBounding: () => document.documentElement.getBoundingClientRect(),
      setPosition: _a => {
        var {
          position
        } = _a,
            style = __rest(_a, ["position"]);

        this.setState({
          containerStyle: _Object$assign(_Object$assign({}, this.state.containerStyle), style),
          placement: position,
          isPositionUpdated: true
        }, () => {
          this.eventManager.emit('positionUpdated');
        });
      },
      updatePlacementAttr: placement => {
        this.setState({
          placement
        });
      },
      togglePortalVisible: (visible, cb) => {
        const willUpdateStates = {};

        if (this.adapter.canMotion()) {
          willUpdateStates.transitionState = visible ? 'enter' : 'leave';
          willUpdateStates.visible = visible;
        } else {
          willUpdateStates.visible = visible;
        }

        this.mounted && this.setState(willUpdateStates, () => {
          cb();
        });
      },
      registerClickOutsideHandler: cb => {
        if (this.clickOutsideHandler) {
          this.adapter.unregisterClickOutsideHandler();
        }

        this.clickOutsideHandler = e => {
          if (!this.mounted) {
            return false;
          }

          let el = this.triggerEl && this.triggerEl.current;
          let popupEl = this.containerEl && this.containerEl.current;
          el = ReactDOM.findDOMNode(el);
          popupEl = ReactDOM.findDOMNode(popupEl);

          if (el && !el.contains(e.target) && popupEl && !popupEl.contains(e.target) || this.props.clickTriggerToHide) {
            this.props.onClickOutSide(e);
            cb();
          }
        };

        window.addEventListener('mousedown', this.clickOutsideHandler);
      },
      unregisterClickOutsideHandler: () => {
        if (this.clickOutsideHandler) {
          window.removeEventListener('mousedown', this.clickOutsideHandler);
          this.clickOutsideHandler = null;
        }
      },
      registerResizeHandler: cb => {
        if (this.resizeHandler) {
          this.adapter.unregisterResizeHandler();
        }

        this.resizeHandler = _throttle(e => {
          if (!this.mounted) {
            return false;
          }

          cb(e);
        }, 10);
        window.addEventListener('resize', this.resizeHandler, false);
      },
      unregisterResizeHandler: () => {
        if (this.resizeHandler) {
          window.removeEventListener('resize', this.resizeHandler, false);
          this.resizeHandler = null;
        }
      },
      notifyVisibleChange: visible => {
        this.props.onVisibleChange(visible);
      },
      registerScrollHandler: rePositionCb => {
        if (this.scrollHandler) {
          this.adapter.unregisterScrollHandler();
        }

        this.scrollHandler = _throttle(e => {
          if (!this.mounted) {
            return false;
          }

          const triggerDOM = this.adapter.getTriggerNode();
          const isRelativeScroll = e.target.contains(triggerDOM);

          if (isRelativeScroll) {
            const scrollPos = {
              x: e.target.scrollLeft,
              y: e.target.scrollTop
            };
            rePositionCb(scrollPos);
          }
        }, 10); // When it is greater than 16ms, it will be very obvious

        window.addEventListener('scroll', this.scrollHandler, true);
      },
      unregisterScrollHandler: () => {
        if (this.scrollHandler) {
          window.removeEventListener('scroll', this.scrollHandler, true);
          this.scrollHandler = null;
        }
      },
      canMotion: () => Boolean(this.props.motion),
      updateContainerPosition: () => {
        const container = this.getPopupContainer();

        if (container && isHTMLElement(container)) {
          // getComputedStyle need first parameter is Element type
          const computedStyle = window.getComputedStyle(container);
          const position = computedStyle.getPropertyValue('position');
          this.containerPosition = position;
        }
      },
      getContainerPosition: () => this.containerPosition,
      getContainer: () => this.containerEl && this.containerEl.current,
      getTriggerNode: () => {
        let triggerDOM = this.triggerEl.current;

        if (!isHTMLElement(this.triggerEl.current)) {
          triggerDOM = ReactDOM.findDOMNode(this.triggerEl.current);
        }

        return triggerDOM;
      },
      getFocusableElements: node => {
        return getFocusableElements(node);
      },
      getActiveElement: () => {
        return getActiveElement();
      },
      setInitialFocus: () => {
        const {
          preventScroll
        } = this.props;

        const focusRefNode = _get(this, 'initialFocusRef.current');

        if (focusRefNode && 'focus' in focusRefNode) {
          focusRefNode.focus({
            preventScroll
          });
        }
      },
      notifyEscKeydown: event => {
        this.props.onEscKeyDown(event);
      },
      setId: () => {
        this.setState({
          id: getUuidShort()
        });
      }
    });
  }

  componentDidMount() {
    this.mounted = true;
    this.getPopupContainer = this.props.getPopupContainer || this.context.getPopupContainer || defaultGetContainer;
    this.foundation.init();
  }

  componentWillUnmount() {
    this.mounted = false;
    this.foundation.destroy();
  }
  /** for transition - end */


  rePosition() {
    return this.foundation.calcPosition();
  }

  componentDidUpdate(prevProps, prevState) {
    warning(this.props.mouseLeaveDelay < this.props.mouseEnterDelay, "[Semi Tooltip] 'mouseLeaveDelay' cannot be less than 'mouseEnterDelay', which may cause the dropdown layer to not be hidden.");

    if (prevProps.visible !== this.props.visible) {
      this.props.visible ? this.foundation.delayShow() : this.foundation.delayHide();
    }

    if (prevProps.rePosKey !== this.props.rePosKey) {
      this.rePosition();
    }
  }

  render() {
    const {
      isInsert,
      triggerEventSet,
      visible,
      id
    } = this.state;
    const {
      wrapWhenSpecial,
      role,
      trigger
    } = this.props;
    let {
      children
    } = this.props;

    const childrenStyle = _Object$assign({}, _get(children, 'props.style'));

    const extraStyle = {};

    if (wrapWhenSpecial) {
      const isSpecial = this.isSpecial(children);

      if (isSpecial) {
        childrenStyle.pointerEvents = 'none';

        if (isSpecial === strings.STATUS_DISABLED) {
          extraStyle.cursor = 'not-allowed';
        }

        children = /*#__PURE__*/cloneElement(children, {
          style: childrenStyle
        });

        if (trigger !== 'custom') {
          // no need to wrap span when trigger is custom, cause it don't need bind event
          children = this.wrapSpan(children);
        }

        this.isWrapped = true;
      } else if (! /*#__PURE__*/isValidElement(children)) {
        children = this.wrapSpan(children);
        this.isWrapped = true;
      }
    } // eslint-disable-next-line prefer-const


    let ariaAttribute = {}; // Take effect when used by Popover component

    if (role === 'dialog') {
      ariaAttribute['aria-expanded'] = visible ? 'true' : 'false';
      ariaAttribute['aria-haspopup'] = 'dialog';
      ariaAttribute['aria-controls'] = id;
    } else {
      ariaAttribute['aria-describedby'] = id;
    } // The incoming children is a single valid element, otherwise wrap a layer with span


    const newChild = /*#__PURE__*/React.cloneElement(children, _Object$assign(_Object$assign(_Object$assign(_Object$assign({}, ariaAttribute), children.props), this.mergeEvents(children.props, triggerEventSet)), {
      style: _Object$assign(_Object$assign({}, _get(children, 'props.style')), extraStyle),
      className: classNames(_get(children, 'props.className')),
      // to maintain refs with callback
      ref: node => {
        // Keep your own reference
        this.triggerEl.current = node; // Call the original ref, if any

        const {
          ref
        } = children; // this.log('tooltip render() - get ref', ref);

        if (typeof ref === 'function') {
          ref(node);
        } else if (ref && typeof ref === 'object') {
          ref.current = node;
        }
      },
      tabIndex: children.props.tabIndex || 0 // a11y keyboard, in some condition select's tabindex need to -1 or 0 

    })); // If you do not add a layer of div, in order to bind the events and className in the tooltip, you need to cloneElement children, but this time it may overwrite the children's original ref reference
    // So if the user adds ref to the content, you need to use callback ref: https://github.com/facebook/react/issues/8873

    return /*#__PURE__*/React.createElement(React.Fragment, null, isInsert ? this.renderPortal() : null, newChild);
  }

}
Tooltip.contextType = ConfigContext;
Tooltip.propTypes = {
  children: PropTypes.node,
  motion: PropTypes.oneOfType([PropTypes.bool, PropTypes.object, PropTypes.func]),
  autoAdjustOverflow: PropTypes.bool,
  position: PropTypes.oneOf(positionSet),
  getPopupContainer: PropTypes.func,
  mouseEnterDelay: PropTypes.number,
  mouseLeaveDelay: PropTypes.number,
  trigger: PropTypes.oneOf(triggerSet).isRequired,
  className: PropTypes.string,
  wrapperClassName: PropTypes.string,
  clickToHide: PropTypes.bool,
  // used with trigger === hover, private
  clickTriggerToHide: PropTypes.bool,
  visible: PropTypes.bool,
  style: PropTypes.object,
  content: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  prefixCls: PropTypes.string,
  onVisibleChange: PropTypes.func,
  onClickOutSide: PropTypes.func,
  spacing: PropTypes.number,
  showArrow: PropTypes.oneOfType([PropTypes.bool, PropTypes.node]),
  zIndex: PropTypes.number,
  rePosKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  arrowBounding: ArrowBoundingShape,
  transformFromCenter: PropTypes.bool,
  arrowPointAtCenter: PropTypes.bool,
  stopPropagation: PropTypes.bool,
  // private
  role: PropTypes.string,
  wrapWhenSpecial: PropTypes.bool,
  guardFocus: PropTypes.bool,
  returnFocusOnClose: PropTypes.bool,
  preventScroll: PropTypes.bool
};
Tooltip.defaultProps = {
  arrowBounding: numbers.ARROW_BOUNDING,
  autoAdjustOverflow: true,
  arrowPointAtCenter: true,
  trigger: 'hover',
  transformFromCenter: true,
  position: 'top',
  prefixCls: prefix,
  role: 'tooltip',
  mouseEnterDelay: numbers.MOUSE_ENTER_DELAY,
  mouseLeaveDelay: numbers.MOUSE_LEAVE_DELAY,
  motion: true,
  onVisibleChange: _noop,
  onClickOutSide: _noop,
  spacing: numbers.SPACING,
  showArrow: true,
  wrapWhenSpecial: true,
  zIndex: numbers.DEFAULT_Z_INDEX,
  closeOnEsc: false,
  guardFocus: false,
  returnFocusOnClose: false,
  onEscKeyDown: _noop,
  disableFocusListener: false,
  disableArrowKeyDown: false
};