import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _findInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/find";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _sliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/slice";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _Array$from from "@babel/runtime-corejs3/core-js-stable/array/from";
import _Set from "@babel/runtime-corejs3/core-js-stable/set";
import _Object$entries from "@babel/runtime-corejs3/core-js-stable/object/entries";
import React from 'react';
import ReactDOM from 'react-dom';
import cls from 'classnames';
import PropTypes from 'prop-types';
import ConfigContext from '../configProvider/context';
import NotificationListFoundation from '@douyinfe/semi-foundation/lib/es/notification/notificationListFoundation';
import { cssClasses, strings } from '@douyinfe/semi-foundation/lib/es/notification/constants';
import Notice from './notice';
import BaseComponent from '../_base/baseComponent';
import '@douyinfe/semi-foundation/lib/es/notification/notification.css';
import NoticeTransition from './NoticeTransition';
import getUuid from '@douyinfe/semi-foundation/lib/es/utils/uuid';
import useNotification from './useNotification';
let ref = null;
const defaultConfig = {
  duration: 3,
  position: 'topRight',
  motion: true,
  content: '',
  title: '',
  zIndex: 1010
};

class NotificationList extends BaseComponent {
  constructor(props) {
    var _this;

    super(props);
    _this = this;

    this.add = noticeOpts => this.foundation.addNotice(noticeOpts);

    this.remove = id => {
      this.foundation.removeNotice(String(id));
    };

    this.destroyAll = () => this.foundation.destroyAll();

    this.renderNoticeInPosition = function (notices, position) {
      let removedItems = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      const className = cls(cssClasses.LIST); // TODO notifyOnClose

      if (notices.length) {
        const style = _this.setPosInStyle(notices[0]);

        return (
          /*#__PURE__*/
          // @ts-ignore
          React.createElement("div", {
            placement: position,
            key: position,
            className: className,
            style: style
          }, _mapInstanceProperty(notices).call(notices, (notice, index) => notice.motion ? /*#__PURE__*/React.createElement(NoticeTransition, {
            key: notice.id || index,
            position: position,
            motion: notice.motion
          }, _findInstanceProperty(removedItems).call(removedItems, item => item.id === notice.id) ? null : transitionStyle => /*#__PURE__*/React.createElement(Notice, _Object$assign({}, notice, {
            style: _Object$assign(_Object$assign({}, transitionStyle), notice.style),
            key: notice.id,
            close: _this.remove
          }))) : /*#__PURE__*/React.createElement(Notice, _Object$assign({}, notice, {
            style: _Object$assign({}, notice.style),
            key: notice.id,
            close: _this.remove
          }))))
        );
      }

      return null;
    };

    this.state = {
      notices: [],
      removedItems: []
    };
    this.noticeStorage = [];
    this.removeItemStorage = [];
    this.foundation = new NotificationListFoundation(this.adapter);
  }

  get adapter() {
    var _this2 = this;

    return _Object$assign(_Object$assign({}, super.adapter), {
      updateNotices: function (notices) {
        let removedItems = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        _this2.noticeStorage = [...notices];
        _this2.removeItemStorage = [...removedItems]; // setState is async sometimes and react often merges state, so use "this" , make sure other code always get right data.

        _this2.setState({
          notices,
          removedItems
        });
      },
      getNotices: () => this.noticeStorage
    });
  }

  static addNotice(notice) {
    const id = getUuid('notification');

    if (!ref) {
      const {
        getPopupContainer
      } = notice;
      const div = document.createElement('div');

      if (!this.wrapperId) {
        var _context;

        this.wrapperId = _sliceInstanceProperty(_context = getUuid('notification-wrapper')).call(_context, 0, 32);
      }

      div.className = cssClasses.WRAPPER;
      div.id = this.wrapperId;
      div.style.zIndex = String(typeof notice.zIndex === 'number' ? notice.zIndex : defaultConfig.zIndex);

      if (getPopupContainer) {
        const container = getPopupContainer();
        container.appendChild(div);
      } else {
        document.body.appendChild(div);
      }

      ReactDOM.render( /*#__PURE__*/React.createElement(NotificationList, {
        ref: instance => ref = instance
      }), div, () => {
        ref.add(_Object$assign(_Object$assign({}, notice), {
          id
        }));
      });
    } else {
      ref.add(_Object$assign(_Object$assign({}, notice), {
        id
      }));
    }

    return id;
  }

  static removeNotice(id) {
    if (ref) {
      ref.remove(id);
    }

    return id;
  }

  static info(opts) {
    return this.addNotice(_Object$assign(_Object$assign(_Object$assign({}, defaultConfig), opts), {
      type: 'info'
    }));
  }

  static success(opts) {
    return this.addNotice(_Object$assign(_Object$assign(_Object$assign({}, defaultConfig), opts), {
      type: 'success'
    }));
  }

  static error(opts) {
    return this.addNotice(_Object$assign(_Object$assign(_Object$assign({}, defaultConfig), opts), {
      type: 'error'
    }));
  }

  static warning(opts) {
    return this.addNotice(_Object$assign(_Object$assign(_Object$assign({}, defaultConfig), opts), {
      type: 'warning'
    }));
  }

  static open(opts) {
    return this.addNotice(_Object$assign(_Object$assign(_Object$assign({}, defaultConfig), opts), {
      type: 'default'
    }));
  }

  static close(id) {
    return this.removeNotice(id);
  }

  static destroyAll() {
    if (ref) {
      ref.destroyAll();
      const wrapper = document.querySelector("#".concat(this.wrapperId));
      ReactDOM.unmountComponentAtNode(wrapper);
      wrapper && wrapper.parentNode.removeChild(wrapper);
      ref = null;
      this.wrapperId = null;
    }
  }

  static config(opts) {
    var _context2;

    _mapInstanceProperty(_context2 = ['top', 'left', 'bottom', 'right']).call(_context2, pos => {
      if (pos in opts) {
        defaultConfig[pos] = opts[pos];
      }
    });

    if (typeof opts.zIndex === 'number') {
      defaultConfig.zIndex = opts.zIndex;
    }

    if (typeof opts.duration === 'number') {
      defaultConfig.duration = opts.duration;
    }

    if (typeof opts.position === 'string') {
      defaultConfig.position = opts.position;
    }
  }

  setPosInStyle(noticeInstance) {
    var _context3;

    const style = {};

    _forEachInstanceProperty(_context3 = ['top', 'left', 'bottom', 'right']).call(_context3, pos => {
      if (pos in noticeInstance) {
        const val = noticeInstance[pos];
        style[pos] = typeof val === 'number' ? "".concat(val, "px") : val;
      }
    });

    return style;
  }

  render() {
    var _context4;

    let {
      notices
    } = this.state;
    const {
      removedItems
    } = this.state;
    notices = _Array$from(new _Set([...notices, ...removedItems]));
    const noticesInPosition = {
      top: [],
      topLeft: [],
      topRight: [],
      bottom: [],
      bottomLeft: [],
      bottomRight: []
    };

    _forEachInstanceProperty(notices).call(notices, notice => {
      const direction = notice.direction || this.context.direction;
      const defaultPosition = direction === 'rtl' ? 'topLeft' : 'topRight';
      const position = notice.position || defaultPosition;
      noticesInPosition[position].push(notice);
    });

    const noticesList = _mapInstanceProperty(_context4 = _Object$entries(noticesInPosition)).call(_context4, obj => {
      const pos = obj[0];
      const noticesInPos = obj[1];
      return this.renderNoticeInPosition(noticesInPos, pos, removedItems);
    });

    return /*#__PURE__*/React.createElement(React.Fragment, null, noticesList);
  }

}

NotificationList.contextType = ConfigContext;
NotificationList.propTypes = {
  style: PropTypes.object,
  className: PropTypes.string,
  direction: PropTypes.oneOf(strings.directions)
};
NotificationList.defaultProps = {};
NotificationList.useNotification = useNotification;
export default NotificationList;