import _flatten from "lodash/flatten";
import _noop from "lodash/noop";
import _isNumber from "lodash/isNumber";
import _isFunction from "lodash/isFunction";
import _isEmpty from "lodash/isEmpty";
import _isString from "lodash/isString";
import _isEqual from "lodash/isEqual";
import _isSet from "lodash/isSet";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _Set from "@babel/runtime-corejs3/core-js-stable/set";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import React, { Fragment } from 'react';
import ReactDOM from 'react-dom';
import cls from 'classnames';
import PropTypes from 'prop-types';
import CascaderFoundation from '@douyinfe/semi-foundation/lib/es/cascader/foundation';
import { cssClasses, strings } from '@douyinfe/semi-foundation/lib/es/cascader/constants';
import { numbers as popoverNumbers } from '@douyinfe/semi-foundation/lib/es/popover/constants';
import '@douyinfe/semi-foundation/lib/es/cascader/cascader.css';
import { IconClear, IconChevronDown } from '@douyinfe/semi-icons';
import { findKeysForValues, convertDataToEntities, calcMergeType } from '@douyinfe/semi-foundation/lib/es/cascader/util';
import { calcCheckedKeys, normalizeKeyList, calcDisabledKeys } from '@douyinfe/semi-foundation/lib/es/tree/treeUtil';
import ConfigContext from '../configProvider/context';
import BaseComponent from '../_base/baseComponent';
import Input from '../input/index';
import Popover from '../popover/index';
import Item from './item';
import Trigger from '../trigger';
import Tag from '../tag';
import TagInput from '../tagInput';
import { isSemiIcon } from '../_utils';
const prefixcls = cssClasses.PREFIX;
const resetkey = 0;

class Cascader extends BaseComponent {
  constructor(props) {
    super(props);

    this.handleInputChange = value => {
      this.foundation.handleInputChange(value);
    };

    this.handleTagRemove = (e, tagValuePath) => {
      this.foundation.handleTagRemove(e, tagValuePath);
    };

    this.renderTagItem = (value, idx, type) => {
      const {
        keyEntities,
        disabledKeys
      } = this.state;
      const {
        size,
        disabled,
        displayProp,
        displayRender,
        disableStrictly
      } = this.props;
      const nodeKey = type === strings.IS_VALUE ? findKeysForValues(value, keyEntities)[0] : value;
      const isDsiabled = disabled || keyEntities[nodeKey].data.disabled || disableStrictly && disabledKeys.has(nodeKey);

      if (!_isEmpty(keyEntities) && !_isEmpty(keyEntities[nodeKey])) {
        const tagCls = cls("".concat(prefixcls, "-selection-tag"), {
          ["".concat(prefixcls, "-selection-tag-disabled")]: isDsiabled
        }); // custom render tags

        if (_isFunction(displayRender)) {
          return displayRender(keyEntities[nodeKey], idx); // default render tags
        } else {
          var _context;

          return /*#__PURE__*/React.createElement(Tag, {
            size: size === 'default' ? 'large' : size,
            key: _concatInstanceProperty(_context = "tag-".concat(nodeKey, "-")).call(_context, idx),
            color: "white",
            className: tagCls,
            closable: true,
            onClose: (tagChildren, e) => {
              // When value has not changed, prevent clicking tag closeBtn to close tag
              e.preventDefault();
              this.handleTagRemove(e, keyEntities[nodeKey].valuePath);
            }
          }, keyEntities[nodeKey].data[displayProp]);
        }
      }

      return null;
    };

    this.handleItemClick = (e, item) => {
      this.foundation.handleItemClick(e, item);
    };

    this.handleItemHover = (e, item) => {
      this.foundation.handleItemHover(e, item);
    };

    this.onItemCheckboxClick = item => {
      this.foundation.onItemCheckboxClick(item);
    };

    this.handleListScroll = (e, ind) => {
      this.foundation.handleListScroll(e, ind);
    };

    this.renderContent = () => {
      const {
        inputValue,
        isSearching,
        activeKeys,
        selectedKeys,
        checkedKeys,
        halfCheckedKeys,
        loadedKeys,
        loadingKeys
      } = this.state;
      const {
        filterTreeNode,
        dropdownClassName,
        dropdownStyle,
        loadData,
        emptyContent,
        separator,
        topSlot,
        bottomSlot,
        showNext,
        multiple
      } = this.props;
      const searchable = Boolean(filterTreeNode) && isSearching;
      const popoverCls = cls(dropdownClassName, "".concat(prefixcls, "-popover"));
      const renderData = this.foundation.getRenderData();
      const content = /*#__PURE__*/React.createElement("div", {
        className: popoverCls,
        role: "listbox",
        style: dropdownStyle
      }, topSlot, /*#__PURE__*/React.createElement(Item, {
        activeKeys: activeKeys,
        selectedKeys: selectedKeys,
        separator: separator,
        loadedKeys: loadedKeys,
        loadingKeys: loadingKeys,
        onItemClick: this.handleItemClick,
        onItemHover: this.handleItemHover,
        showNext: showNext,
        onItemCheckboxClick: this.onItemCheckboxClick,
        onListScroll: this.handleListScroll,
        searchable: searchable,
        keyword: inputValue,
        emptyContent: emptyContent,
        loadData: loadData,
        data: renderData,
        multiple: multiple,
        checkedKeys: checkedKeys,
        halfCheckedKeys: halfCheckedKeys
      }), bottomSlot);
      return content;
    };

    this.renderPlusN = hiddenTag => {
      const {
        disabled,
        showRestTagsPopover,
        restTagsPopoverProps
      } = this.props;
      const plusNCls = cls("".concat(prefixcls, "-selection-n"), {
        ["".concat(prefixcls, "-selection-n-disabled")]: disabled
      });
      const renderPlusNChildren = /*#__PURE__*/React.createElement("span", {
        className: plusNCls
      }, "+", hiddenTag.length);
      return showRestTagsPopover && !disabled ? /*#__PURE__*/React.createElement(Popover, _Object$assign({
        content: hiddenTag,
        showArrow: true,
        trigger: "hover",
        position: "top",
        autoAdjustOverflow: true
      }, restTagsPopoverProps), renderPlusNChildren) : renderPlusNChildren;
    };

    this.renderMultipleTags = () => {
      var _context2;

      const {
        autoMergeValue,
        maxTagCount
      } = this.props;
      const {
        checkedKeys,
        resolvedCheckedKeys
      } = this.state;
      const realKeys = this.mergeType === strings.NONE_MERGE_TYPE ? checkedKeys : resolvedCheckedKeys;
      const displayTag = [];
      const hiddenTag = [];

      _forEachInstanceProperty(_context2 = [...realKeys]).call(_context2, (checkedKey, idx) => {
        const notExceedMaxTagCount = !_isNumber(maxTagCount) || maxTagCount >= idx + 1;
        const item = this.renderTagItem(checkedKey, idx, strings.IS_KEY);

        if (notExceedMaxTagCount) {
          displayTag.push(item);
        } else {
          hiddenTag.push(item);
        }
      });

      return /*#__PURE__*/React.createElement(React.Fragment, null, displayTag, !_isEmpty(hiddenTag) && this.renderPlusN(hiddenTag));
    };

    this.renderDisplayText = () => {
      const {
        displayProp,
        separator,
        displayRender
      } = this.props;
      const {
        selectedKeys
      } = this.state;
      let displayText = '';

      if (selectedKeys.size) {
        const displayPath = this.foundation.getItemPropPath([...selectedKeys][0], displayProp);

        if (displayRender && typeof displayRender === 'function') {
          displayText = displayRender(displayPath);
        } else {
          displayText = _mapInstanceProperty(displayPath).call(displayPath, (path, index) => {
            var _context3;

            return /*#__PURE__*/React.createElement(Fragment, {
              key: _concatInstanceProperty(_context3 = "".concat(path, "-")).call(_context3, index)
            }, index < displayPath.length - 1 ? /*#__PURE__*/React.createElement(React.Fragment, null, path, separator) : path);
          });
        }
      }

      return displayText;
    };

    this.renderSelectContent = () => {
      const {
        placeholder,
        filterTreeNode,
        multiple
      } = this.props;
      const {
        checkedKeys
      } = this.state;
      const searchable = Boolean(filterTreeNode);

      if (!searchable) {
        if (multiple) {
          if (_isEmpty(checkedKeys)) {
            return /*#__PURE__*/React.createElement("span", {
              className: "".concat(prefixcls, "-selection-placeholder")
            }, placeholder);
          }

          return this.renderMultipleTags();
        } else {
          const displayText = this.renderDisplayText();
          const spanCls = cls({
            ["".concat(prefixcls, "-selection-placeholder")]: !displayText
          });
          return /*#__PURE__*/React.createElement("span", {
            className: spanCls
          }, displayText ? displayText : placeholder);
        }
      }

      const input = multiple ? this.renderTagInput() : this.renderInput();
      return input;
    };

    this.renderSuffix = () => {
      const {
        suffix
      } = this.props;
      const suffixWrapperCls = cls({
        ["".concat(prefixcls, "-suffix")]: true,
        ["".concat(prefixcls, "-suffix-text")]: suffix && _isString(suffix),
        ["".concat(prefixcls, "-suffix-icon")]: isSemiIcon(suffix)
      });
      return /*#__PURE__*/React.createElement("div", {
        className: suffixWrapperCls,
        "x-semi-prop": "suffix"
      }, suffix);
    };

    this.renderPrefix = () => {
      const {
        prefix,
        insetLabel,
        insetLabelId
      } = this.props;
      const labelNode = prefix || insetLabel;
      const prefixWrapperCls = cls({
        ["".concat(prefixcls, "-prefix")]: true,
        // to be doublechecked
        ["".concat(prefixcls, "-inset-label")]: insetLabel,
        ["".concat(prefixcls, "-prefix-text")]: labelNode && _isString(labelNode),
        ["".concat(prefixcls, "-prefix-icon")]: isSemiIcon(labelNode)
      });
      return /*#__PURE__*/React.createElement("div", {
        className: prefixWrapperCls,
        id: insetLabelId,
        "x-semi-prop": "prefix,insetLabel"
      }, labelNode);
    };

    this.renderCustomTrigger = () => {
      const {
        disabled,
        triggerRender,
        multiple
      } = this.props;
      const {
        selectedKeys,
        inputValue,
        inputPlaceHolder,
        resolvedCheckedKeys,
        checkedKeys
      } = this.state;
      let realValue;

      if (multiple) {
        if (this.mergeType === strings.NONE_MERGE_TYPE) {
          realValue = checkedKeys;
        } else {
          realValue = resolvedCheckedKeys;
        }
      } else {
        realValue = [...selectedKeys][0];
      }

      return /*#__PURE__*/React.createElement(Trigger, {
        value: realValue,
        inputValue: inputValue,
        onChange: this.handleInputChange,
        onClear: this.handleClear,
        placeholder: inputPlaceHolder,
        disabled: disabled,
        triggerRender: triggerRender,
        componentName: 'Cascader',
        componentProps: _Object$assign({}, this.props)
      });
    };

    this.handleMouseOver = () => {
      this.foundation.toggleHoverState(true);
    };

    this.handleMouseLeave = () => {
      this.foundation.toggleHoverState(false);
    };

    this.handleClear = e => {
      e && e.stopPropagation();
      this.foundation.handleClear();
    };
    /**
     * A11y: simulate clear button click
     */

    /* istanbul ignore next */


    this.handleClearEnterPress = e => {
      e && e.stopPropagation();
      this.foundation.handleClearEnterPress(e);
    };

    this.showClearBtn = () => {
      const {
        showClear,
        disabled,
        multiple
      } = this.props;
      const {
        selectedKeys,
        isOpen,
        isHovering,
        checkedKeys
      } = this.state;
      const hasValue = selectedKeys.size;
      const multipleWithHaveValue = multiple && checkedKeys.size;
      return showClear && (hasValue || multipleWithHaveValue) && !disabled && (isOpen || isHovering);
    };

    this.renderClearBtn = () => {
      const clearCls = cls("".concat(prefixcls, "-clearbtn"));
      const allowClear = this.showClearBtn();

      if (allowClear) {
        return /*#__PURE__*/React.createElement("div", {
          className: clearCls,
          onClick: this.handleClear,
          onKeyPress: this.handleClearEnterPress,
          role: "button",
          tabIndex: 0
        }, /*#__PURE__*/React.createElement(IconClear, null));
      }

      return null;
    };

    this.renderArrow = () => {
      const {
        arrowIcon
      } = this.props;
      const showClearBtn = this.showClearBtn();

      if (showClearBtn) {
        return null;
      }

      return arrowIcon ? /*#__PURE__*/React.createElement("div", {
        className: cls("".concat(prefixcls, "-arrow")),
        "x-semi-prop": "arrowIcon"
      }, arrowIcon) : null;
    };

    this.renderSelection = () => {
      const {
        disabled,
        multiple,
        filterTreeNode,
        style,
        size,
        className,
        validateStatus,
        prefix,
        suffix,
        insetLabel,
        triggerRender,
        showClear,
        id
      } = this.props;
      const {
        isOpen,
        isFocus,
        isInput,
        checkedKeys
      } = this.state;
      const filterable = Boolean(filterTreeNode);
      const useCustomTrigger = typeof triggerRender === 'function';
      const classNames = useCustomTrigger ? cls(className) : cls(prefixcls, className, {
        ["".concat(prefixcls, "-focus")]: isFocus || isOpen && !isInput,
        ["".concat(prefixcls, "-disabled")]: disabled,
        ["".concat(prefixcls, "-single")]: true,
        ["".concat(prefixcls, "-filterable")]: filterable,
        ["".concat(prefixcls, "-error")]: validateStatus === 'error',
        ["".concat(prefixcls, "-warning")]: validateStatus === 'warning',
        ["".concat(prefixcls, "-small")]: size === 'small',
        ["".concat(prefixcls, "-large")]: size === 'large',
        ["".concat(prefixcls, "-with-prefix")]: prefix || insetLabel,
        ["".concat(prefixcls, "-with-suffix")]: suffix
      });
      const mouseEvent = showClear ? {
        onMouseEnter: () => this.handleMouseOver(),
        onMouseLeave: () => this.handleMouseLeave()
      } : {};
      const sectionCls = cls("".concat(prefixcls, "-selection"), {
        ["".concat(prefixcls, "-selection-multiple")]: multiple && !_isEmpty(checkedKeys)
      });
      const inner = useCustomTrigger ? this.renderCustomTrigger() : [/*#__PURE__*/React.createElement(Fragment, {
        key: 'prefix'
      }, prefix || insetLabel ? this.renderPrefix() : null), /*#__PURE__*/React.createElement(Fragment, {
        key: 'selection'
      }, /*#__PURE__*/React.createElement("div", {
        className: sectionCls
      }, this.renderSelectContent())), /*#__PURE__*/React.createElement(Fragment, {
        key: 'clearbtn'
      }, this.renderClearBtn()), /*#__PURE__*/React.createElement(Fragment, {
        key: 'suffix'
      }, suffix ? this.renderSuffix() : null), /*#__PURE__*/React.createElement(Fragment, {
        key: 'arrow'
      }, this.renderArrow())];
      /**
       * Reasons for disabling the a11y eslint rule:
       * The following attributes(aria-controls,aria-expanded) will be automatically added by Tooltip, no need to declare here
       */

      return /*#__PURE__*/React.createElement("div", _Object$assign({
        className: classNames,
        style: style,
        ref: this.triggerRef,
        onClick: e => this.foundation.handleClick(e),
        onKeyPress: e => this.foundation.handleSelectionEnterPress(e),
        "aria-invalid": this.props['aria-invalid'],
        "aria-errormessage": this.props['aria-errormessage'],
        "aria-label": this.props['aria-label'],
        "aria-labelledby": this.props['aria-labelledby'],
        "aria-describedby": this.props['aria-describedby'],
        "aria-required": this.props['aria-required'],
        id: id
      }, mouseEvent, {
        // eslint-disable-next-line jsx-a11y/role-has-required-aria-props
        role: "combobox",
        tabIndex: 0
      }), inner);
    };

    this.state = {
      disabledKeys: new _Set(),
      isOpen: props.defaultOpen,

      /* By changing rePosKey, the dropdown position can be refreshed */
      rePosKey: resetkey,

      /* A data structure for storing cascader data items */
      keyEntities: {},

      /* Selected and show tick icon */
      selectedKeys: new _Set([]),

      /* The key of the activated node */
      activeKeys: new _Set([]),

      /* The key of the filtered node */
      filteredKeys: new _Set([]),

      /* Value of input box */
      inputValue: '',

      /* Is searching */
      isSearching: false,

      /* The placeholder of input box */
      inputPlaceHolder: props.searchPlaceholder || props.placeholder,

      /* Cache props */
      prevProps: {},

      /* Is hovering */
      isHovering: false,

      /* Key of checked node, when multiple */
      checkedKeys: new _Set([]),

      /* Key of half checked node, when multiple */
      halfCheckedKeys: new _Set([]),

      /* Auto merged checkedKeys or leaf checkedKeys, when multiple */
      resolvedCheckedKeys: new _Set([]),

      /* Keys of loaded item */
      loadedKeys: new _Set(),

      /* Keys of loading item */
      loadingKeys: new _Set(),

      /* Mark whether this rendering has triggered asynchronous loading of data */
      loading: false,
      showInput: false
    };
    this.options = {};
    this.isEmpty = false;
    this.mergeType = calcMergeType(props.autoMergeValue, props.leafOnly);
    this.inputRef = /*#__PURE__*/React.createRef();
    this.triggerRef = /*#__PURE__*/React.createRef();
    this.optionsRef = /*#__PURE__*/React.createRef();
    this.clickOutsideHandler = null;
    this.foundation = new CascaderFoundation(this.adapter);
  }

  get adapter() {
    var _this = this;

    const filterAdapter = {
      updateInputValue: value => {
        this.setState({
          inputValue: value
        });
      },
      updateInputPlaceHolder: value => {
        this.setState({
          inputPlaceHolder: value
        });
      },
      focusInput: () => {
        const {
          preventScroll
        } = this.props;

        if (this.inputRef && this.inputRef.current) {
          // TODO: check the reason
          this.inputRef.current.focus({
            preventScroll
          });
        }
      }
    };
    const cascaderAdapter = {
      registerClickOutsideHandler: cb => {
        const clickOutsideHandler = e => {
          const optionInstance = this.optionsRef && this.optionsRef.current;
          const triggerDom = this.triggerRef && this.triggerRef.current;
          const optionsDom = ReactDOM.findDOMNode(optionInstance);
          const target = e.target;

          if (optionsDom && (!optionsDom.contains(target) || !optionsDom.contains(target.parentNode)) && triggerDom && !triggerDom.contains(target)) {
            cb(e);
          }
        };

        this.clickOutsideHandler = clickOutsideHandler;
        document.addEventListener('mousedown', clickOutsideHandler, false);
      },
      unregisterClickOutsideHandler: () => {
        document.removeEventListener('mousedown', this.clickOutsideHandler, false);
      },
      rePositionDropdown: () => {
        let {
          rePosKey
        } = this.state;
        rePosKey = rePosKey + 1;
        this.setState({
          rePosKey
        });
      }
    };
    return _Object$assign(_Object$assign(_Object$assign(_Object$assign({}, super.adapter), filterAdapter), cascaderAdapter), {
      updateStates: states => {
        this.setState(_Object$assign({}, states));
      },
      openMenu: () => {
        this.setState({
          isOpen: true
        });
      },
      closeMenu: cb => {
        this.setState({
          isOpen: false
        }, () => {
          cb && cb();
        });
      },
      updateSelection: selectedKeys => this.setState({
        selectedKeys
      }),
      notifyChange: value => {
        this.props.onChange && this.props.onChange(value);
      },
      notifySelect: selected => {
        this.props.onSelect && this.props.onSelect(selected);
      },
      notifyOnSearch: input => {
        this.props.onSearch && this.props.onSearch(input);
      },
      notifyFocus: function () {
        _this.props.onFocus && _this.props.onFocus(...arguments);
      },
      notifyBlur: function () {
        _this.props.onBlur && _this.props.onBlur(...arguments);
      },
      notifyDropdownVisibleChange: visible => {
        this.props.onDropdownVisibleChange(visible);
      },
      toggleHovering: bool => {
        this.setState({
          isHovering: bool
        });
      },
      notifyLoadData: (selectedOpt, callback) => {
        const {
          loadData
        } = this.props;

        if (loadData) {
          new _Promise(resolve => {
            loadData(selectedOpt).then(() => {
              callback();
              this.setState({
                loading: false
              });
              resolve();
            });
          });
        }
      },
      notifyOnLoad: (newLoadedKeys, data) => {
        const {
          onLoad
        } = this.props;
        onLoad && onLoad(newLoadedKeys, data);
      },
      notifyListScroll: (e, _ref) => {
        let {
          panelIndex,
          activeNode
        } = _ref;
        this.props.onListScroll(e, {
          panelIndex,
          activeNode
        });
      },
      notifyOnExceed: data => this.props.onExceed(data),
      notifyClear: () => this.props.onClear(),
      toggleInputShow: (showInput, cb) => {
        this.setState({
          showInput
        }, () => {
          cb();
        });
      },
      updateFocusState: isFocus => {
        this.setState({
          isFocus
        });
      }
    });
  }

  static getDerivedStateFromProps(props, prevState) {
    const {
      multiple,
      value,
      defaultValue,
      onChangeWithObject,
      leafOnly,
      autoMergeValue
    } = props;
    const {
      prevProps
    } = prevState;
    let keyEntities = prevState.keyEntities || {};
    const newState = {};

    const needUpdate = name => {
      const firstInProps = _isEmpty(prevProps) && name in props;
      const nameHasChange = prevProps && !_isEqual(prevProps[name], props[name]);
      return firstInProps || nameHasChange;
    };

    const needUpdateData = () => {
      const firstInProps = !prevProps && 'treeData' in props;
      const treeDataHasChange = prevProps && prevProps.treeData !== props.treeData;
      return firstInProps || treeDataHasChange;
    };

    const getRealKeys = (realValue, keyEntities) => {
      // normallizedValue is used to save the value in two-dimensional array format
      let normallizedValue = [];

      if (_Array$isArray(realValue)) {
        normallizedValue = _Array$isArray(realValue[0]) ? realValue : [realValue];
      } else {
        if (realValue !== undefined) {
          normallizedValue = [[realValue]];
        }
      } // formatValuePath is used to save value of valuePath


      const formatValuePath = [];

      _forEachInstanceProperty(normallizedValue).call(normallizedValue, valueItem => {
        const formatItem = onChangeWithObject ? _mapInstanceProperty(valueItem).call(valueItem, i => i === null || i === void 0 ? void 0 : i.value) : valueItem;
        formatValuePath.push(formatItem);
      }); // formatKeys is used to save key of value


      const formatKeys = [];

      _forEachInstanceProperty(formatValuePath).call(formatValuePath, v => {
        const formatKeyItem = findKeysForValues(v, keyEntities);
        !_isEmpty(formatKeyItem) && formatKeys.push(formatKeyItem);
      });

      return formatKeys;
    };

    const needUpdateTreeData = needUpdate('treeData') || needUpdateData();
    const needUpdateValue = needUpdate('value') || _isEmpty(prevProps) && defaultValue;

    if (multiple) {
      // when value and treedata need updated
      if (needUpdateTreeData || needUpdateValue) {
        // update state.keyEntities
        if (needUpdateTreeData) {
          newState.treeData = props.treeData;
          keyEntities = convertDataToEntities(props.treeData);
          newState.keyEntities = keyEntities;
        }

        let realKeys = prevState.checkedKeys; // when data was updated

        if (needUpdateValue) {
          const realValue = needUpdate('value') ? value : defaultValue;
          realKeys = getRealKeys(realValue, keyEntities);
        } else {
          // needUpdateValue is false
          // if treeData is updated & Cascader is controlled, realKeys should be recalculated
          if (needUpdateTreeData && 'value' in props) {
            const realValue = value;
            realKeys = getRealKeys(realValue, keyEntities);
          }
        }

        if (_isSet(realKeys)) {
          realKeys = [...realKeys];
        }

        const calRes = calcCheckedKeys(_flatten(realKeys), keyEntities);
        const checkedKeys = new _Set(calRes.checkedKeys);
        const halfCheckedKeys = new _Set(calRes.halfCheckedKeys); // disableStrictly

        if (props.disableStrictly) {
          newState.disabledKeys = calcDisabledKeys(keyEntities);
        }

        const isLeafOnlyMerge = calcMergeType(autoMergeValue, leafOnly) === strings.LEAF_ONLY_MERGE_TYPE;
        newState.prevProps = props;
        newState.checkedKeys = checkedKeys;
        newState.halfCheckedKeys = halfCheckedKeys;
        newState.resolvedCheckedKeys = new _Set(normalizeKeyList(checkedKeys, keyEntities, isLeafOnlyMerge));
      }
    }

    return newState;
  }

  componentDidMount() {
    this.foundation.init();
  }

  componentWillUnmount() {
    this.foundation.destroy();
  }

  componentDidUpdate(prevProps) {
    let isOptionsChanged = false;

    if (!_isEqual(prevProps.treeData, this.props.treeData)) {
      isOptionsChanged = true;
      this.foundation.collectOptions();
    }

    if (prevProps.value !== this.props.value && !isOptionsChanged) {
      this.foundation.handleValueChange(this.props.value);
    }
  }

  renderTagInput() {
    var _context4;

    const {
      size,
      disabled,
      placeholder,
      maxTagCount,
      showRestTagsPopover,
      restTagsPopoverProps
    } = this.props;
    const {
      inputValue,
      checkedKeys,
      keyEntities,
      resolvedCheckedKeys
    } = this.state;
    const tagInputcls = cls("".concat(prefixcls, "-tagInput-wrapper"));
    const tagValue = [];
    const realKeys = this.mergeType === strings.NONE_MERGE_TYPE ? checkedKeys : resolvedCheckedKeys;

    _forEachInstanceProperty(_context4 = [...realKeys]).call(_context4, checkedKey => {
      if (!_isEmpty(keyEntities[checkedKey])) {
        tagValue.push(keyEntities[checkedKey].valuePath);
      }
    });

    return /*#__PURE__*/React.createElement(TagInput, {
      className: tagInputcls,
      ref: this.inputRef,
      disabled: disabled,
      size: size,
      // TODO Modify logic, not modify type
      value: tagValue,
      showRestTagsPopover: showRestTagsPopover,
      restTagsPopoverProps: restTagsPopoverProps,
      maxTagCount: maxTagCount,
      renderTagItem: (value, index) => this.renderTagItem(value, index, strings.IS_VALUE),
      inputValue: inputValue,
      onInputChange: this.handleInputChange,
      // TODO Modify logic, not modify type
      onRemove: v => this.handleTagRemove(null, v),
      placeholder: placeholder
    });
  }

  renderInput() {
    const {
      size,
      disabled
    } = this.props;
    const inputcls = cls("".concat(prefixcls, "-input"));
    const {
      inputValue,
      inputPlaceHolder,
      showInput
    } = this.state;
    const inputProps = {
      disabled,
      value: inputValue,
      className: inputcls,
      onChange: this.handleInputChange
    };
    const wrappercls = cls({
      ["".concat(prefixcls, "-search-wrapper")]: true
    });
    const displayText = this.renderDisplayText();
    const spanCls = cls({
      ["".concat(prefixcls, "-selection-placeholder")]: !displayText,
      ["".concat(prefixcls, "-selection-text-hide")]: showInput && inputValue,
      ["".concat(prefixcls, "-selection-text-inactive")]: showInput && !inputValue
    });
    return /*#__PURE__*/React.createElement("div", {
      className: wrappercls
    }, /*#__PURE__*/React.createElement("span", {
      className: spanCls
    }, displayText ? displayText : inputPlaceHolder), showInput && /*#__PURE__*/React.createElement(Input, _Object$assign({
      ref: this.inputRef,
      size: size
    }, inputProps)));
  }

  render() {
    const {
      zIndex,
      getPopupContainer,
      autoAdjustOverflow,
      stopPropagation,
      mouseLeaveDelay,
      mouseEnterDelay,
      position
    } = this.props;
    const {
      isOpen,
      rePosKey
    } = this.state;
    const {
      direction
    } = this.context;
    const content = this.renderContent();
    const selection = this.renderSelection();
    const pos = position !== null && position !== void 0 ? position : direction === 'rtl' ? 'bottomRight' : 'bottomLeft';
    const mergedMotion = this.foundation.getMergedMotion();
    return /*#__PURE__*/React.createElement(Popover, {
      getPopupContainer: getPopupContainer,
      zIndex: zIndex,
      motion: mergedMotion,
      ref: this.optionsRef,
      content: content,
      visible: isOpen,
      trigger: "custom",
      rePosKey: rePosKey,
      position: pos,
      autoAdjustOverflow: autoAdjustOverflow,
      stopPropagation: stopPropagation,
      mouseLeaveDelay: mouseLeaveDelay,
      mouseEnterDelay: mouseEnterDelay
    }, selection);
  }

}

Cascader.contextType = ConfigContext;
Cascader.propTypes = {
  'aria-labelledby': PropTypes.string,
  'aria-invalid': PropTypes.bool,
  'aria-errormessage': PropTypes.string,
  'aria-describedby': PropTypes.string,
  'aria-required': PropTypes.bool,
  'aria-label': PropTypes.string,
  arrowIcon: PropTypes.node,
  changeOnSelect: PropTypes.bool,
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  disabled: PropTypes.bool,
  dropdownClassName: PropTypes.string,
  dropdownStyle: PropTypes.object,
  emptyContent: PropTypes.node,
  motion: PropTypes.oneOfType([PropTypes.bool, PropTypes.func, PropTypes.object]),

  /* show search input, if passed in a function, used as custom filter */
  filterTreeNode: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  filterLeafOnly: PropTypes.bool,
  placeholder: PropTypes.string,
  searchPlaceholder: PropTypes.string,
  size: PropTypes.oneOf(strings.SIZE_SET),
  style: PropTypes.object,
  className: PropTypes.string,
  treeData: PropTypes.arrayOf(PropTypes.shape({
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    label: PropTypes.any
  })),
  treeNodeFilterProp: PropTypes.string,
  suffix: PropTypes.node,
  prefix: PropTypes.node,
  insetLabel: PropTypes.node,
  insetLabelId: PropTypes.string,
  id: PropTypes.string,
  displayProp: PropTypes.string,
  displayRender: PropTypes.func,
  onChange: PropTypes.func,
  onSearch: PropTypes.func,
  onSelect: PropTypes.func,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  children: PropTypes.node,
  getPopupContainer: PropTypes.func,
  zIndex: PropTypes.number,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array]),
  validateStatus: PropTypes.oneOf(strings.VALIDATE_STATUS),
  showNext: PropTypes.oneOf([strings.SHOW_NEXT_BY_CLICK, strings.SHOW_NEXT_BY_HOVER]),
  stopPropagation: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
  showClear: PropTypes.bool,
  defaultOpen: PropTypes.bool,
  autoAdjustOverflow: PropTypes.bool,
  onDropdownVisibleChange: PropTypes.func,
  triggerRender: PropTypes.func,
  onListScroll: PropTypes.func,
  onChangeWithObject: PropTypes.bool,
  bottomSlot: PropTypes.node,
  topSlot: PropTypes.node,
  multiple: PropTypes.bool,
  autoMergeValue: PropTypes.bool,
  maxTagCount: PropTypes.number,
  showRestTagsPopover: PropTypes.bool,
  restTagsPopoverProps: PropTypes.object,
  max: PropTypes.number,
  separator: PropTypes.string,
  onExceed: PropTypes.func,
  onClear: PropTypes.func,
  loadData: PropTypes.func,
  onLoad: PropTypes.func,
  loadedKeys: PropTypes.array,
  disableStrictly: PropTypes.bool,
  leafOnly: PropTypes.bool,
  enableLeafClick: PropTypes.bool,
  preventScroll: PropTypes.bool,
  position: PropTypes.string
};
Cascader.defaultProps = {
  leafOnly: false,
  arrowIcon: /*#__PURE__*/React.createElement(IconChevronDown, null),
  stopPropagation: true,
  motion: true,
  defaultOpen: false,
  zIndex: popoverNumbers.DEFAULT_Z_INDEX,
  showClear: false,
  autoClearSearchValue: true,
  changeOnSelect: false,
  disableStrictly: false,
  autoMergeValue: true,
  multiple: false,
  filterTreeNode: false,
  filterLeafOnly: true,
  showRestTagsPopover: false,
  restTagsPopoverProps: {},
  separator: ' / ',
  size: 'default',
  treeNodeFilterProp: 'label',
  displayProp: 'label',
  treeData: [],
  showNext: strings.SHOW_NEXT_BY_CLICK,
  onExceed: _noop,
  onClear: _noop,
  onDropdownVisibleChange: _noop,
  onListScroll: _noop,
  enableLeafClick: false,
  'aria-label': 'Cascader'
};
export default Cascader;