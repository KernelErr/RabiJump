"use strict";

var _WeakMap = require("@babel/runtime-corejs3/core-js-stable/weak-map");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _bind = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/bind"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));

var _splice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/splice"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _isUndefined2 = _interopRequireDefault(require("lodash/isUndefined"));

var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));

var _react = _interopRequireWildcard(require("react"));

var _uuid = require("@douyinfe/semi-foundation/lib/cjs/utils/uuid");

var _context6 = require("./context");

var _warning = _interopRequireDefault(require("@douyinfe/semi-foundation/lib/cjs/utils/warning"));

function _getRequireWildcardCache(nodeInterop) { if (typeof _WeakMap !== "function") return null; var cacheBabelInterop = new _WeakMap(); var cacheNodeInterop = new _WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { _Object$defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable react/destructuring-assignment */
const filterArrayByIndex = (array, index) => (0, _filter.default)(array).call(array, (item, i) => i !== index);

const getUuidByArray = array => (0, _map.default)(array).call(array, () => (0, _uuid.getUuidv4)());

const getUpdateKey = arrayField => {
  if (!arrayField) {
    return undefined;
  }

  if (arrayField && arrayField.updateKey) {
    return arrayField.updateKey;
  }

  return undefined;
};

const initValueAdapter = initValue => {
  const iv = [];

  if ((0, _isArray.default)(initValue)) {
    return initValue;
  } else {
    (0, _warning.default)(!(0, _isUndefined2.default)(initValue), '[Semi Form ArrayField] initValue of ArrayField must be an array. Please check the type of your props');
    return iv;
  }
};
/**
 *
 * @param {any[]} value
 * @param {string[]} oldKeys
 * @returns string[]
 */


const generateKeys = (value, oldKeys) => {
  const val = initValueAdapter(value);
  const newKeys = getUuidByArray(val); // return newKeys;

  const keys = (0, _map.default)(newKeys).call(newKeys, (key, i) => oldKeys && oldKeys[i] ? oldKeys[i] : key);
  return keys;
};

class ArrayFieldComponent extends _react.Component {
  constructor(props, context) {
    var _context, _context2, _context3;

    super(props, context);
    const initValueInProps = this.props.initValue;
    const {
      field
    } = this.props;
    const initValueInForm = context.getValue(field);
    const initValue = initValueInProps || initValueInForm;
    this.state = {
      keys: generateKeys(initValue)
    };
    this.add = (0, _bind.default)(_context = this.add).call(_context, this);
    this.addWithInitValue = (0, _bind.default)(_context2 = this.addWithInitValue).call(_context2, this);
    this.remove = (0, _bind.default)(_context3 = this.remove).call(_context3, this);
    this.cacheFieldValues = null;
    this.cacheUpdateKey = null;
    /*
        If updateKey exists, it means that the arrayField (usually a nested ArrayField not at the first level) is only re-mounted due to setValues,
        and the fields it contains do not need to consume initValue
    */
    // whether the fields inside arrayField should use props.initValue in current render process

    this.shouldUseInitValue = !context.getArrayField(field); // Separate the arrays that reset and the usual add and remove modify, otherwise they will affect each other

    const initValueCopyForFormState = (0, _cloneDeep2.default)(initValue);
    const initValueCopyForReset = (0, _cloneDeep2.default)(initValue);
    context.registerArrayField(field, initValueCopyForReset); // register ArrayField will update state.updateKey to render, So there is no need to execute forceUpdate here

    context.updateStateValue(field, initValueCopyForFormState, {
      notNotify: true,
      notUpdate: true
    });
  }

  componentWillUnmount() {
    const updater = this.context;
    const {
      field
    } = this.props;
    updater.unRegisterArrayField(field);
  }

  componentDidUpdate() {
    const updater = this.context;
    const {
      field
    } = this.props;
    const {
      keys
    } = this.state;
    const fieldValues = updater.getValue(field);
    const updateKey = getUpdateKey(updater.getArrayField(field)); // when update form outside, like use formApi.setValue('field', [{newItem1, newItem2}]),  formApi.setValues
    // re generate keys to update arrayField;

    if (updateKey !== this.cacheUpdateKey) {
      const newKeys = generateKeys(fieldValues, keys); // eslint-disable-next-line

      this.setState({
        keys: newKeys
      });
      this.cacheUpdateKey = updateKey;

      if (this.cacheUpdateKey !== null) {
        this.shouldUseInitValue = false;
      }
    }
  }

  add() {
    const {
      keys
    } = this.state;
    keys.push((0, _uuid.getUuidv4)());
    this.shouldUseInitValue = true;
    this.setState({
      keys
    });
  }

  addWithInitValue(lineObject) {
    var _context4;

    const updater = this.context;
    const {
      field
    } = this.props;
    const newArrayFieldVal = updater.getValue(field) ? (0, _slice.default)(_context4 = updater.getValue(field)).call(_context4) : [];
    newArrayFieldVal.push(lineObject);
    updater.updateStateValue(field, newArrayFieldVal, {});
    updater.updateArrayField(field, {
      updateKey: new Date().valueOf()
    });
  }

  remove(i) {
    const updater = this.context;
    const {
      keys
    } = this.state;
    const {
      field
    } = this.props;
    const newKeys = filterArrayByIndex(keys, i); // Make sure that all the keys in the line are removed, because some keys are not taken over by the field, only set in the initValue

    let newArrayFieldError = updater.getError(field);
    const opts = {
      notNotify: true,
      notUpdate: true
    };

    if ((0, _isArray.default)(newArrayFieldError)) {
      newArrayFieldError = (0, _slice.default)(newArrayFieldError).call(newArrayFieldError);
      (0, _splice.default)(newArrayFieldError).call(newArrayFieldError, i, 1);
      updater.updateStateError(field, newArrayFieldError, opts);
    } // if (Array.isArray(newArrayFieldTouched)) {
    //     newArrayFieldTouched = newArrayFieldTouched.slice();
    //     newArrayFieldTouched.splice(i, 1);
    //     updater.updateStateTouched(field, newArrayFieldTouched, opts);
    // }


    let newArrayFieldValue = updater.getValue(field);

    if ((0, _isArray.default)(newArrayFieldValue)) {
      newArrayFieldValue = (0, _slice.default)(newArrayFieldValue).call(newArrayFieldValue);
      (0, _splice.default)(newArrayFieldValue).call(newArrayFieldValue, i, 1);
      updater.updateStateValue(field, newArrayFieldValue);
    }

    this.setState({
      keys: newKeys
    });
  }

  render() {
    const {
      children,
      field
    } = this.props;
    const {
      keys
    } = this.state;
    const arrayFields = (0, _map.default)(keys).call(keys, (key, i) => {
      var _context5;

      return {
        // key: i,
        key,
        field: (0, _concat.default)(_context5 = "".concat(field, "[")).call(_context5, i, "]"),
        remove: () => this.remove(i)
      };
    });
    const {
      add
    } = this;
    const {
      addWithInitValue
    } = this;
    const contextVal = {
      shouldUseInitValue: this.shouldUseInitValue
    };
    return /*#__PURE__*/_react.default.createElement(_context6.ArrayFieldContext.Provider, {
      value: contextVal
    }, children({
      arrayFields,
      add,
      addWithInitValue
    }));
  }

}

ArrayFieldComponent.contextType = _context6.FormUpdaterContext;
var _default = ArrayFieldComponent;
exports.default = _default;