"use strict";

var _context9;

var _WeakMap = require("@babel/runtime-corejs3/core-js-stable/weak-map");

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor");

var _forEachInstanceProperty2 = require("@babel/runtime-corejs3/core-js-stable/instance/for-each");

var _Object$keys = require("@babel/runtime-corejs3/core-js-stable/object/keys");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

var _exportNames = {};
exports.default = void 0;

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _findIndex = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/find-index"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _pick2 = _interopRequireDefault(require("lodash/pick"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _constants = require("@douyinfe/semi-foundation/lib/cjs/tabs/constants");

var _isNullOrUndefined = _interopRequireDefault(require("@douyinfe/semi-foundation/lib/cjs/utils/isNullOrUndefined"));

var _getDataAttr = _interopRequireDefault(require("@douyinfe/semi-foundation/lib/cjs/utils/getDataAttr"));

var _foundation = _interopRequireDefault(require("@douyinfe/semi-foundation/lib/cjs/tabs/foundation"));

var _baseComponent = _interopRequireDefault(require("../_base/baseComponent"));

require("@douyinfe/semi-foundation/lib/cjs/tabs/tabs.css");

var _TabBar = _interopRequireDefault(require("./TabBar"));

var _TabPane = _interopRequireDefault(require("./TabPane"));

var _tabsContext = _interopRequireDefault(require("./tabs-context"));

var _interface = require("./interface");

_forEachInstanceProperty2(_context9 = _Object$keys(_interface)).call(_context9, function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _interface[key]) return;

  _Object$defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _interface[key];
    }
  });
});

function _getRequireWildcardCache(nodeInterop) { if (typeof _WeakMap !== "function") return null; var cacheBabelInterop = new _WeakMap(); var cacheNodeInterop = new _WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { _Object$defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && (0, _indexOf.default)(e).call(e, p) < 0) t[p] = s[p];

  if (s != null && typeof _getOwnPropertySymbols.default === "function") for (var i = 0, p = (0, _getOwnPropertySymbols.default)(s); i < p.length; i++) {
    if ((0, _indexOf.default)(e).call(e, p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

const panePickKeys = ['className', 'style', 'disabled', 'itemKey', 'tab', 'icon'];

class Tabs extends _baseComponent.default {
  constructor(props) {
    super(props);

    this.setContentRef = ref => {
      this.contentRef = {
        current: ref
      };
    };

    this.onTabClick = (activeKey, event) => {
      this.foundation.handleTabClick(activeKey, event);
    };
    /* istanbul ignore next */


    this.rePosChildren = (children, activeKey) => {
      const newChildren = [];

      const falttenChildren = _react.default.Children.toArray(children);

      if (children.length) {
        newChildren.push(...(0, _filter.default)(falttenChildren).call(falttenChildren, child => child.props && child.props.itemKey === activeKey));
        newChildren.push(...(0, _filter.default)(falttenChildren).call(falttenChildren, child => child.props && child.props.itemKey !== activeKey));
      }

      return newChildren;
    };

    this.getActiveItem = () => {
      var _context;

      const {
        activeKey
      } = this.state;
      const {
        children,
        tabList
      } = this.props;

      if (tabList || !(0, _isArray.default)(children)) {
        return children;
      }

      return (0, _filter.default)(_context = _react.default.Children.toArray(children)).call(_context, pane => {
        if ( /*#__PURE__*/(0, _react.isValidElement)(pane) && pane.type && pane.type.isTabPane) {
          return pane.props.itemKey === activeKey;
        }

        return true;
      });
    };

    this.deleteTabItem = (tabKey, event) => {
      event.stopPropagation();
      this.foundation.handleTabDelete(tabKey);
    };

    this.foundation = new _foundation.default(this.adapter);
    this.state = {
      activeKey: this.foundation.getDefaultActiveKey(),
      panes: []
    };
    this.contentRef = /*#__PURE__*/(0, _react.createRef)();
    this.contentHeight = 'auto';
  }

  get adapter() {
    return (0, _assign.default)((0, _assign.default)({}, super.adapter), {
      collectPane: () => {
        var _context2;

        const {
          tabList,
          children
        } = this.props;

        if ((0, _isArray.default)(tabList) && tabList.length) {
          this.setState({
            panes: tabList
          });
          return;
        }

        const panes = (0, _map.default)(_context2 = _react.default.Children).call(_context2, children, child => {
          if (child) {
            const {
              tab,
              icon,
              disabled,
              itemKey,
              closable
            } = child.props;
            return {
              tab,
              icon,
              disabled,
              itemKey,
              closable
            };
          }

          return undefined;
        });
        this.setState({
          panes
        });
      },
      collectActiveKey: () => {
        let panes = [];
        const {
          tabList,
          children,
          activeKey: propsActiveKey
        } = this.props;

        if (typeof propsActiveKey !== 'undefined') {
          return;
        }

        const {
          activeKey
        } = this.state;

        if ((0, _isArray.default)(tabList) && tabList.length) {
          panes = tabList;
        } else {
          var _context3;

          panes = (0, _map.default)(_context3 = _react.default.Children).call(_context3, children, child => {
            if (child) {
              const {
                tab,
                icon,
                disabled,
                itemKey,
                closable
              } = child.props;
              return {
                tab,
                icon,
                disabled,
                itemKey,
                closable
              };
            }

            return undefined;
          });
        }

        if ((0, _findIndex.default)(panes).call(panes, p => p.itemKey === activeKey) === -1) {
          if (panes.length > 0) {
            this.setState({
              activeKey: panes[0].itemKey
            });
          } else {
            this.setState({
              activeKey: ''
            });
          }
        }
      },
      notifyTabClick: (activeKey, event) => {
        this.props.onTabClick(activeKey, event);
      },
      notifyChange: activeKey => {
        this.props.onChange(activeKey);
      },
      setNewActiveKey: activeKey => {
        this.setState({
          activeKey
        });
      },
      getDefaultActiveKeyFromChildren: () => {
        var _context4;

        const {
          tabList,
          children
        } = this.props;
        let activeKey = '';
        const list = tabList ? tabList : (0, _map.default)(_context4 = _react.default.Children.toArray(children)).call(_context4, child => /*#__PURE__*/(0, _react.isValidElement)(child) ? child.props : null);
        (0, _forEach.default)(list).call(list, item => {
          if (item && !activeKey && !item.disabled) {
            activeKey = item.itemKey;
          }
        });
        return activeKey;
      },
      notifyTabDelete: tabKey => {
        this.props.onTabClose && this.props.onTabClose(tabKey);
      }
    });
  }

  static getDerivedStateFromProps(props, state) {
    const states = {};

    if (!(0, _isNullOrUndefined.default)(props.activeKey) && props.activeKey !== state.activeKey) {
      states.activeKey = props.activeKey;
    }

    return states;
  }

  componentDidUpdate(prevProps) {
    var _context5, _context6;

    // Panes state acts on tab bar, no need to compare TabPane children
    const prevChildrenProps = (0, _map.default)(_context5 = _react.default.Children.toArray(prevProps.children)).call(_context5, child => (0, _pick2.default)( /*#__PURE__*/(0, _react.isValidElement)(child) ? child.props : null, panePickKeys));
    const nowChildrenProps = (0, _map.default)(_context6 = _react.default.Children.toArray(this.props.children)).call(_context6, child => (0, _pick2.default)( /*#__PURE__*/(0, _react.isValidElement)(child) ? child.props : null, panePickKeys));
    const isTabListType = this.props.tabList || prevProps.tabList;

    if (!(0, _isEqual2.default)(this.props.tabList, prevProps.tabList)) {
      this.foundation.handleTabListChange();
    } // children变化，tabList方式使用时，啥也不用做
    // children变化，非tabList方式使用，需要重新取activeKey。TabPane可能是异步更新的，若不重新取，未设activeKey时，第一个不会自动激活
    // children changed: do nothing in tabList case
    // children changed: recalc activeKey. TabPane could be updated async. If not recalc the first panel will not be activated


    if (!(0, _isEqual2.default)(prevChildrenProps, nowChildrenProps) && !isTabListType) {
      this.foundation.handleTabPanesChange();
    }
  }

  render() {
    var _context7, _context8;

    const _a = this.props,
          {
      children,
      className,
      collapsible,
      contentStyle,
      keepDOM,
      lazyRender,
      renderTabBar,
      size,
      style,
      tabBarClassName,
      tabBarExtraContent,
      tabBarStyle,
      tabPaneMotion,
      tabPosition,
      type
    } = _a,
          restProps = __rest(_a, ["children", "className", "collapsible", "contentStyle", "keepDOM", "lazyRender", "renderTabBar", "size", "style", "tabBarClassName", "tabBarExtraContent", "tabBarStyle", "tabPaneMotion", "tabPosition", "type"]);

    const {
      panes,
      activeKey
    } = this.state;
    const tabWrapperCls = (0, _classnames.default)(className, {
      [_constants.cssClasses.TABS]: true,
      [(0, _concat.default)(_context7 = "".concat(_constants.cssClasses.TABS, "-")).call(_context7, tabPosition)]: tabPosition
    });
    const tabContentCls = (0, _classnames.default)({
      [_constants.cssClasses.TABS_CONTENT]: true,
      [(0, _concat.default)(_context8 = "".concat(_constants.cssClasses.TABS_CONTENT, "-")).call(_context8, tabPosition)]: tabPosition
    });
    const tabBarProps = {
      activeKey,
      className: tabBarClassName,
      collapsible,
      list: panes,
      onTabClick: this.onTabClick,
      size,
      style: tabBarStyle,
      tabBarExtraContent,
      tabPosition,
      type,
      deleteTabItem: this.deleteTabItem,
      handleKeyDown: this.foundation.handleKeyDown
    };
    const tabBar = renderTabBar ? renderTabBar(tabBarProps, _TabBar.default) : /*#__PURE__*/_react.default.createElement(_TabBar.default, (0, _assign.default)({}, tabBarProps));
    const content = keepDOM ? children : this.getActiveItem();
    return /*#__PURE__*/_react.default.createElement("div", (0, _assign.default)({
      className: tabWrapperCls,
      style: style
    }, (0, _getDataAttr.default)(restProps)), tabBar, /*#__PURE__*/_react.default.createElement(_tabsContext.default.Provider, {
      value: {
        activeKey,
        lazyRender,
        panes,
        tabPaneMotion,
        tabPosition
      }
    }, /*#__PURE__*/_react.default.createElement("div", {
      ref: this.setContentRef,
      className: tabContentCls,
      style: (0, _assign.default)({}, contentStyle)
    }, content)));
  }

}

Tabs.TabPane = _TabPane.default;
Tabs.propTypes = {
  activeKey: _propTypes.default.string,
  className: _propTypes.default.string,
  collapsible: _propTypes.default.bool,
  contentStyle: _propTypes.default.oneOfType([_propTypes.default.object]),
  defaultActiveKey: _propTypes.default.string,
  keepDOM: _propTypes.default.bool,
  lazyRender: _propTypes.default.bool,
  onChange: _propTypes.default.func,
  onTabClick: _propTypes.default.func,
  renderTabBar: _propTypes.default.func,
  size: _propTypes.default.oneOf(_constants.strings.SIZE),
  style: _propTypes.default.object,
  tabBarClassName: _propTypes.default.string,
  tabBarExtraContent: _propTypes.default.node,
  tabBarStyle: _propTypes.default.object,
  tabList: _propTypes.default.array,
  tabPaneMotion: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.object, _propTypes.default.func]),
  tabPosition: _propTypes.default.oneOf(_constants.strings.POSITION_MAP),
  type: _propTypes.default.oneOf(_constants.strings.TYPE_MAP),
  onTabClose: _propTypes.default.func,
  preventScroll: _propTypes.default.bool
};
Tabs.defaultProps = {
  children: [],
  collapsible: false,
  keepDOM: true,
  lazyRender: false,
  onChange: () => undefined,
  onTabClick: () => undefined,
  size: 'large',
  tabPaneMotion: true,
  tabPosition: 'top',
  type: 'line',
  onTabClose: () => undefined
};
var _default = Tabs;
exports.default = _default;