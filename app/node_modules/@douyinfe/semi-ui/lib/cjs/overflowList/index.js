"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _some = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/some"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _map2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/map"));

var _isUndefined2 = _interopRequireDefault(require("lodash/isUndefined"));

var _isNull2 = _interopRequireDefault(require("lodash/isNull"));

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _baseComponent = _interopRequireDefault(require("../_base/baseComponent"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _constants = require("@douyinfe/semi-foundation/lib/cjs/overflowList/constants");

var _resizeObserver = _interopRequireDefault(require("../resizeObserver"));

var _intersectionObserver = _interopRequireDefault(require("./intersectionObserver"));

var _foundation = _interopRequireDefault(require("@douyinfe/semi-foundation/lib/cjs/overflowList/foundation"));

require("@douyinfe/semi-foundation/lib/cjs/overflowList/overflowList.css");

/* eslint-disable arrow-body-style */
const prefixCls = _constants.cssClasses.PREFIX;
const Boundary = _constants.strings.BOUNDARY_MAP;
const OverflowDirection = _constants.strings.OVERFLOW_DIR;
const RenderMode = _constants.strings.MODE_MAP; // reference to https://github.com/palantir/blueprint/blob/1aa71605/packages/core/src/components/overflow-list/overflowList.tsx#L34

class OverflowList extends _baseComponent.default {
  constructor(props) {
    var _this;

    super(props);
    _this = this;
    this.scroller = null;
    this.spacer = null;

    this.isScrollMode = () => {
      const {
        renderMode
      } = this.props;
      return renderMode === RenderMode.SCROLL;
    };

    this.resize = function () {
      let entries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      // if any parent is growing, assume we have more room than before
      const growing = (0, _some.default)(entries).call(entries, entry => {
        const previousWidth = _this.previousWidths.get(entry.target) || 0;
        return entry.contentRect.width > previousWidth;
      });

      _this.repartition(growing);

      (0, _forEach.default)(entries).call(entries, entry => _this.previousWidths.set(entry.target, entry.contentRect.width));
    };

    this.repartition = growing => {
      // if not mounted or scroll mode, we do not
      if ((0, _isNull2.default)(this.spacer) || (0, _isUndefined2.default)(this.spacer) || this.isScrollMode()) {
        return;
      } // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink


      const state = growing ? OverflowDirection.GROW : this.spacer.getBoundingClientRect().width < 0.9 ? OverflowDirection.SHRINK : OverflowDirection.NONE;
      this.foundation.handlePartition(state);
    };

    this.reintersect = entries => {
      this.foundation.handleIntersect(entries);
    };

    this.mergeRef = (ref, node, key) => {
      this.itemRefs[key] = node;

      if (typeof ref === 'function') {
        ref(node);
      } else if (typeof ref === 'object' && ref && 'current' in ref) {
        ref.current = node;
      }
    };

    this.renderOverflow = () => {
      const overflow = this.foundation.getOverflowItem();
      return this.props.overflowRenderer(overflow);
    };

    this.renderItemList = () => {
      var _context;

      const {
        className,
        wrapperClassName,
        wrapperStyle,
        style,
        visibleItemRenderer,
        renderMode,
        collapseFrom
      } = this.props;
      const {
        visible
      } = this.state;
      const overflow = this.renderOverflow();
      const inner = renderMode === RenderMode.SCROLL ? [overflow[0], /*#__PURE__*/_react.default.createElement("div", {
        className: (0, _classnames.default)(wrapperClassName, "".concat(prefixCls, "-scroll-wrapper")),
        ref: ref => {
          this.scroller = ref;
        },
        style: (0, _assign.default)({}, wrapperStyle),
        key: "".concat(prefixCls, "-scroll-wrapper")
      }, (0, _map.default)(_context = (0, _map.default)(visible).call(visible, visibleItemRenderer)).call(_context, (item, ind) => {
        const {
          forwardRef,
          key
        } = item;
        return /*#__PURE__*/_react.default.cloneElement(item, {
          ref: node => this.mergeRef(forwardRef, node, key),
          'data-scrollkey': "".concat(key),
          key
        });
      })), overflow[1]] : [collapseFrom === Boundary.START ? overflow : null, (0, _map.default)(visible).call(visible, visibleItemRenderer), collapseFrom === Boundary.END ? overflow : null, /*#__PURE__*/_react.default.createElement("div", {
        className: "".concat(prefixCls, "-spacer"),
        ref: ref => this.spacer = ref,
        key: "".concat(prefixCls, "-spacer")
      })];

      const list = /*#__PURE__*/_react.default.createElement('div', {
        className: (0, _classnames.default)("".concat(prefixCls), className),
        style
      }, ...inner);

      return list;
    };

    this.state = {
      direction: OverflowDirection.GROW,
      lastOverflowCount: 0,
      overflow: [],
      visible: props.items,
      visibleState: new _map2.default()
    };
    this.foundation = new _foundation.default(this.adapter);
    this.previousWidths = new _map2.default();
    this.itemRefs = {};
    this.itemSizeMap = new _map2.default();
  }

  static getDerivedStateFromProps(props, prevState) {
    const {
      prevProps
    } = prevState;
    const newState = {};
    newState.prevProps = props;

    const needUpdate = name => {
      return !prevProps && name in props || prevProps && !(0, _isEqual2.default)(prevProps[name], props[name]);
    };

    if (needUpdate('items') || needUpdate('style')) {
      // reset visible state if the above props change.
      newState.direction = OverflowDirection.GROW;
      newState.lastOverflowCount = 0;
      newState.overflow = [];
      newState.visible = props.items;
    }

    return newState;
  }

  get adapter() {
    return (0, _assign.default)((0, _assign.default)({}, super.adapter), {
      updateVisibleState: visibleState => {
        this.setState({
          visibleState
        });
      },
      updateStates: states => {
        this.setState((0, _assign.default)({}, states));
      },
      notifyIntersect: res => {
        this.props.onIntersect && this.props.onIntersect(res);
      }
    });
  }

  componentDidMount() {
    this.repartition(false);
  }

  shouldComponentUpdate(_nextProps, nextState) {
    // We want this component to always re-render, even when props haven't changed, so that
    // changes in the renderers' behavior can be reflected.
    // The following statement prevents re-rendering only in the case where the state changes
    // identity (i.e. setState was called), but the state is still the same when
    // shallow-compared to the previous state.
    const currState = (0, _omit2.default)(this.state, 'prevProps');
    const comingState = (0, _omit2.default)(nextState, 'prevProps');
    return !(currState !== comingState && (0, _isEqual2.default)(currState, comingState));
  }

  componentDidUpdate(prevProps, prevState) {
    if (!(0, _isEqual2.default)(prevProps.items, this.props.items)) {
      this.itemRefs = {};
    }

    if (!(0, _isEqual2.default)((0, _omit2.default)(prevState, 'prevProps'), (0, _omit2.default)(this.state, 'prevProps'))) {
      this.repartition(false);
    }

    const {
      direction,
      overflow,
      lastOverflowCount
    } = this.state;

    if ( // if a resize operation has just completed (transition to NONE)
    direction === OverflowDirection.NONE && direction !== prevState.direction && overflow.length !== lastOverflowCount) {
      this.props.onOverflow && this.props.onOverflow(overflow);
    }
  }

  render() {
    const list = this.renderItemList();
    const {
      renderMode
    } = this.props;

    if (renderMode === RenderMode.SCROLL) {
      return /*#__PURE__*/_react.default.createElement(_intersectionObserver.default, {
        onIntersect: this.reintersect,
        root: this.scroller,
        threshold: this.props.threshold,
        items: this.itemRefs
      }, list);
    }

    return /*#__PURE__*/_react.default.createElement(_resizeObserver.default, {
      onResize: this.resize
    }, list);
  }

}

OverflowList.defaultProps = {
  collapseFrom: 'end',
  minVisibleItems: 0,
  overflowRenderer: () => null,
  renderMode: 'collapse',
  threshold: 0.75,
  visibleItemRenderer: () => null
};
OverflowList.propTypes = {
  // if render in scroll mode, key is required in items
  className: _propTypes.default.string,
  collapseFrom: _propTypes.default.oneOf(_constants.strings.BOUNDARY_SET),
  direction: _propTypes.default.oneOf(_constants.strings.POSITION_SET),
  items: _propTypes.default.array,
  minVisibleItems: _propTypes.default.number,
  onIntersect: _propTypes.default.func,
  onOverflow: _propTypes.default.func,
  overflowRenderer: _propTypes.default.func,
  renderMode: _propTypes.default.oneOf(_constants.strings.MODE_SET),
  style: _propTypes.default.object,
  threshold: _propTypes.default.number,
  visibleItemRenderer: _propTypes.default.func,
  wrapperClassName: _propTypes.default.string,
  wrapperStyle: _propTypes.default.object
};
var _default = OverflowList;
exports.default = _default;