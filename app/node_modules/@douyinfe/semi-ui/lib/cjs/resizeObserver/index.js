"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactDom = require("react-dom");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _baseComponent = _interopRequireDefault(require("../_base/baseComponent"));

var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));

class ReactResizeObserver extends _baseComponent.default {
  constructor(props) {
    super(props);

    this.getElement = () => {
      try {
        // using findDOMNode for two reasons:
        // 1. cloning to insert a ref is unwieldy and not performant.
        // 2. ensure that we resolve to an actual DOM node (instead of any JSX ref instance).
        // eslint-disable-next-line
        return (0, _reactDom.findDOMNode)(this.childNode || this);
      } catch (error) {
        // swallow error if findDOMNode is run on unmounted component.
        return null;
      }
    };

    this.mergeRef = (ref, node) => {
      this.childNode = node;

      if (typeof ref === 'function') {
        ref(node);
      } else if (typeof ref === 'object' && ref && 'current' in ref) {
        ref.current = node;
      }
    };

    this.observer = new _resizeObserverPolyfill.default(props.onResize);
  }

  componentDidMount() {
    this.observeElement();
  }

  componentDidUpdate(prevProps) {
    this.observeElement(this.props.observeParent !== prevProps.observeParent);
  }

  componentWillUnmount() {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
  }

  observeElement() {
    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const element = this.getElement();

    if (!(element && element instanceof Element)) {
      // stop everything if not defined
      this.observer.disconnect();
      return;
    }

    if (element === this.element && !force) {
      // abort if given same element -- nothing to update (unless forced)
      return;
    } else {
      // clear observer list if new element
      this.observer.disconnect(); // remember element reference for next time

      this.element = element;
    } // observer callback is invoked immediately when observing new elements


    this.observer.observe(element);

    if (this.props.observeParent && element.parentNode && element.parentNode.ownerDocument && element.parentNode.ownerDocument.defaultView && element.parentNode instanceof element.parentNode.ownerDocument.defaultView.HTMLElement) {
      this._parentNode = element.parentNode;
      this.observer.observe(this._parentNode);
    }
  }

  render() {
    const child = _react.default.Children.only(this.props.children);

    const {
      ref
    } = child;
    return /*#__PURE__*/_react.default.cloneElement(child, {
      ref: node => this.mergeRef(ref, node)
    });
  }

}

exports.default = ReactResizeObserver;
ReactResizeObserver.propTypes = {
  onResize: _propTypes.default.func,
  observeParent: _propTypes.default.bool
};
ReactResizeObserver.defaultProps = {
  onResize: () => {},
  observeParent: false
};