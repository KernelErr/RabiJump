"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _react = _interopRequireDefault(require("react"));

/**
 * The logic of JS for text truncation is referenced from antd typography
 * https://github.com/ant-design/ant-design/blob/master/components/typography/util.tsx
 *
 * For more thinking and analysis about this function, please refer to Feishu document
 * https://bytedance.feishu.cn/docs/doccnqovjjyoKm2U5O13bj30aTh
 */
let ellipsisContainer;

function pxToNumber(value) {
  if (!value) {
    return 0;
  }

  const match = value.match(/^\d*(\.\d*)?/);
  return match ? Number(match[0]) : 0;
}

function styleToString(style) {
  // There are some different behavior between Firefox & Chrome.
  // We have to handle this ourself.
  const styleNames = (0, _slice.default)(Array.prototype).apply(style);
  return (0, _map.default)(styleNames).call(styleNames, name => {
    var _context;

    return (0, _concat.default)(_context = "".concat(name, ": ")).call(_context, style.getPropertyValue(name), ";");
  }).join('');
}

const getRenderText = function (originEle, rows) {
  let content = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  let fixedContent = arguments.length > 3 ? arguments[3] : undefined;
  let ellipsisStr = arguments.length > 4 ? arguments[4] : undefined;
  let suffix = arguments.length > 5 ? arguments[5] : undefined;
  let ellipsisPos // eslint-disable-next-line max-params
  = arguments.length > 6 ? arguments[6] : undefined;

  if (!ellipsisContainer) {
    ellipsisContainer = document.createElement('div');
    ellipsisContainer.setAttribute('aria-hidden', 'true');
    document.body.appendChild(ellipsisContainer);
  } // Get origin style


  const originStyle = window.getComputedStyle(originEle);
  const originCSS = styleToString(originStyle);
  const lineHeight = pxToNumber(originStyle.lineHeight);
  const maxHeight = Math.round(lineHeight * (rows + 1) + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom)); // Set shadow

  ellipsisContainer.setAttribute('style', originCSS);
  ellipsisContainer.style.position = 'fixed';
  ellipsisContainer.style.left = '0';
  ellipsisContainer.style.height = 'auto';
  ellipsisContainer.style.top = '-999999px';
  ellipsisContainer.style.zIndex = '-1000'; // clean up css overflow

  ellipsisContainer.style.textOverflow = 'clip';
  ellipsisContainer.style.webkitLineClamp = 'none'; // Render fake container

  _reactDom.default.render( /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null), ellipsisContainer); // Check if ellipsis in measure div is height enough for content


  function inRange() {
    // console.log('inrange?', ellipsisContainer.scrollHeight, ellipsisContainer.scrollHeight < maxHeight)
    return ellipsisContainer.scrollHeight < maxHeight;
  } // ========================= Find match ellipsis content =========================
  // Create origin content holder


  const ellipsisContentHolder = document.createElement('span');
  const ellipsisTextNode = document.createTextNode(suffix);
  ellipsisContentHolder.appendChild(ellipsisTextNode);
  ellipsisContainer.appendChild(ellipsisContentHolder);
  (0, _map.default)(fixedContent).call(fixedContent, node => node && ellipsisContainer.appendChild(node.cloneNode(true))); // Append before fixed nodes

  function appendChildNode(node) {
    ellipsisContentHolder.insertBefore(node, ellipsisTextNode);
  }

  function getCurrentText(text, pos) {
    const end = text.length;

    if (!pos) {
      return ellipsisStr;
    }

    if (ellipsisPos === 'end' || pos > end - pos) {
      return (0, _slice.default)(text).call(text, 0, pos) + ellipsisStr;
    }

    return (0, _slice.default)(text).call(text, 0, pos) + ellipsisStr + (0, _slice.default)(text).call(text, end - pos, end);
  } // Get maximum text


  function measureText(textNode, fullText) {
    let startLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let endLoc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : fullText.length;
    let lastSuccessLoc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    const midLoc = Math.floor((startLoc + endLoc) / 2);
    const currentText = getCurrentText(fullText, midLoc);
    textNode.textContent = currentText; // console.log('calculating....', currentText);

    if (startLoc >= endLoc - 1 && endLoc > 0) {
      // Loop when step is small
      for (let step = endLoc; step >= startLoc; step -= 1) {
        const currentStepText = getCurrentText(fullText, step);
        textNode.textContent = currentStepText;

        if (inRange() || !currentStepText) {
          return step === fullText.length ? fullText : currentStepText;
        }
      }
    } else if (endLoc === 0) {
      return ellipsisStr;
    }

    if (inRange()) {
      return measureText(textNode, fullText, midLoc, endLoc, midLoc);
    }

    return measureText(textNode, fullText, startLoc, midLoc, lastSuccessLoc);
  }

  const textNode = document.createTextNode(content);
  appendChildNode(textNode);
  const resText = measureText(textNode, content);
  ellipsisContainer.innerHTML = '';
  return resText;
};

var _default = getRenderText;
exports.default = _default;