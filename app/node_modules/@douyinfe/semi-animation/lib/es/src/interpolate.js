import _parseFloat from "@babel/runtime-corejs3/core-js-stable/parse-float";
import _Array$isArray from "@babel/runtime-corejs3/core-js-stable/array/is-array";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";

/**
 *
 * @param {number|number[]|string|string[]} from
 * @param {number|number[]|string|string[]} to
 * @param {number} ratio
 * @param {Function} [parser]
 * @param {Function} [formatter]
 * @returns {any}
*/
// eslint-disable-next-line max-len
export default function interpolate(from, to) {
  let ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let parser = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  let formatter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

  if (typeof parser === 'function') {
    from = parser(from);
    to = parser(to);
  }

  if (typeof from === 'string' || typeof from === 'number') {
    from = [_parseFloat(from)];
  }

  if (typeof to === 'string' || typeof to === 'number') {
    to = [_parseFloat(to)];
  }

  const result = [];

  if (_Array$isArray(from) && _Array$isArray(to)) {
    _forEachInstanceProperty(from).call(from, (fromVal, idx) => {
      fromVal = _parseFloat(fromVal);

      const toVal = _parseFloat(to[idx]);

      result.push((toVal - fromVal) * ratio + fromVal);
    });
  }

  if (typeof formatter === 'function') {
    return formatter(result);
  } else {
    return result;
  }
}