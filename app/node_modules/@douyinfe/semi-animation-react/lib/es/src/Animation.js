import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";
import _forEachInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/for-each";
import _sliceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/slice";
import _reverseInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/reverse";

/* eslint-disable @typescript-eslint/ban-types */

/* eslint-disable react/destructuring-assignment */
import { PureComponent, isValidElement } from 'react';
import PropTypes from 'prop-types';
import { Animation as SemiAnimation, events } from '@douyinfe/semi-animation';
import noop from './utils/noop';
export default class Animation extends PureComponent {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(props);

    this.initAnimation = props => {
      // eslint-disable-next-line eqeqeq
      props = props == null ? this.props : props; // eslint-disable-next-line prefer-const

      let {
        from,
        to,
        config,
        reverse
      } = props;

      if (reverse) {
        [from, to] = [to, from];
      }

      this.animation = new SemiAnimation({
        from: _Object$assign({}, from),
        to: _Object$assign({}, to)
      }, _Object$assign({}, config));

      _forEachInstanceProperty(events).call(events, event => {
        const propName = "on".concat(event[0].toUpperCase() + _sliceInstanceProperty(event).call(event, 1)); // eslint-disable-next-line @typescript-eslint/no-shadow

        this.animation.on(event, props => {
          // avoid memory leak
          if (this._mounted && !this._destroyed) {
            this.setState({
              currentStyle: _Object$assign({}, props)
            });
            this.props[propName](props);
          }
        });
      });

      this._destroyed = false;
    };

    this.bindEvents = () => {
      this.startOrNot = () => {
        const {
          immediate,
          autoStart
        } = this.props;

        if (immediate) {
          this.end();
        } else if (autoStart) {
          this.start();
        }
      };

      this.start = () => {
        this.animation && this.animation.start();
      };

      this.pause = () => {
        this.animation && this.animation.pause();
      };

      this.stop = () => {
        this.animation && this.animation.stop();
      };

      this.end = () => {
        this.animation && this.animation.end();
      };

      this.resume = () => {
        this.animation && this.animation.resume();
      };

      this.reset = () => {
        if (this.animation) {
          this.animation.reset();
          this.startOrNot();
        }
      };

      this.reverse = () => {
        if (this.animation) {
          var _context;

          _reverseInstanceProperty(_context = this.animation).call(_context);

          this.startOrNot();
        }
      };

      this.destroy = () => {
        this._destroyed = true;
        this.animation && this.animation.destroy();
      };
    };

    this.state = {
      currentStyle: {}
    };
    this._mounted = false;
    this._destroyed = false;
    this.initAnimation();
    this.bindEvents();
  }

  startOrNot() {
    throw new Error('Method not implemented.');
  }

  componentDidMount() {
    this._mounted = true;
    const {
      forwardInstance
    } = this.props;

    if (this.animation === null) {
      // didmount/willUnmount may be called twice when React.StrictMode is true in React 18, we need to ensure that this.animation is correct
      this.initAnimation();
      this.bindEvents();
    }

    if (typeof forwardInstance === 'function') {
      forwardInstance(this.animation);
    }

    this.startOrNot();
  }

  componentWillUnmount() {
    this._mounted = false;

    if (this.animation) {
      this.animation.destroy();
      this.animation = null;
    }
  }

  componentDidUpdate() {
    let prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (this.props.reset) {
      if (this.props.from !== prevProps.from || this.props.to !== prevProps.to) {
        this.destroy();
        this.initAnimation();
        this.startOrNot();
      }
    }

    if (this.props.force) {
      if (this.props.to !== prevProps.to) {
        this.initAnimation(_Object$assign(_Object$assign({}, this.props), {
          from: prevProps.to
        }));
        this.startOrNot();
      }
    }
  }

  render() {
    const {
      children
    } = this.props;

    if (typeof children === 'function') {
      return children(this.animation.getCurrentStates());
    } else if ( /*#__PURE__*/isValidElement(children)) {
      return children;
    } else {
      return null;
    }
  }

}
Animation.propTypes = {
  onStart: PropTypes.func,
  onFrame: PropTypes.func,
  onPause: PropTypes.func,
  onResume: PropTypes.func,
  onStop: PropTypes.func,
  onRest: PropTypes.func,
  children: PropTypes.any,
  from: PropTypes.object,
  to: PropTypes.object,
  reverse: PropTypes.bool,
  reset: PropTypes.bool,
  force: PropTypes.bool,
  config: PropTypes.object,
  autoStart: PropTypes.bool,
  forwardInstance: PropTypes.func,
  immediate: PropTypes.bool
};
Animation.defaultProps = {
  autoStart: true,
  force: false,
  onStart: noop,
  onFrame: noop,
  onPause: noop,
  onResume: noop,
  onStop: noop,
  onRest: noop
};