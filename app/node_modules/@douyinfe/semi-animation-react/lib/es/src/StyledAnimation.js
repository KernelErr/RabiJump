var _context;

import _reduceInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/reduce";
import _Object$values from "@babel/runtime-corejs3/core-js-stable/object/values";
import _includesInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/includes";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _Object$assign from "@babel/runtime-corejs3/core-js-stable/object/assign";

/* eslint-disable react/destructuring-assignment */

/* eslint-disable prefer-const */

/* eslint-disable eqeqeq */

/* eslint-disable import/no-duplicates */

/* eslint-disable no-duplicate-imports */
import { PureComponent, isValidElement, cloneElement, Children } from 'react';
import PropTypes from 'prop-types';
import classnames from 'classnames';
import { types as styledTypes, loops, delays, speeds } from '@douyinfe/semi-animation-styled';
import noop from './utils/noop';
import invokeFns from './utils/invokeFns';

const types = _reduceInstanceProperty(_context = _Object$values(styledTypes)).call(_context, (arr, cur) => [...arr, ...cur], []);

export default class StyledAnimation extends PureComponent {
  constructor() {
    var _this;

    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(props);
    _this = this;

    this._generateAnimateEvents = function (child) {
      let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return {
        onAnimationIteration: function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return invokeFns([child && child.props && child.props.onAnimationIteration, props.onFrame], args);
        },
        onAnimationStart: function () {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return invokeFns([child && child.props && child.props.onAnimationStart, props.onStart], args);
        },
        onAnimationEnd: function () {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          return invokeFns([child && child.props && child.props.onAnimationEnd, props.onRest], args);
        }
      };
    };

    this._hasSpeedClass = function () {
      let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props.speed;
      return speed != null && _includesInstanceProperty(speeds).call(speeds, speed);
    };

    this._hasTypeClass = function () {
      let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props.type;
      return type != null && _includesInstanceProperty(types).call(types, type);
    };

    this._hasDelayClass = function () {
      let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props.delay;
      return delay != null && _includesInstanceProperty(delays).call(delays, delay);
    };

    this._hasLoopClass = function () {
      let loop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props.loop;
      return loop != null && _includesInstanceProperty(loops).call(loops, loop);
    };
  }

  render() {
    var _context2, _context3, _context4, _context5;

    let {
      type,
      speed,
      duration,
      delay,
      loop,
      reverse,
      children,
      prefixCls,
      timing,
      className,
      fillMode
    } = this.props;

    const hasTypeClass = this._hasTypeClass();

    const hasSpeedClass = this._hasSpeedClass();

    const hasDelayClass = this._hasDelayClass();

    const hasLoopClass = this._hasLoopClass();

    const animateCls = className || classnames("".concat(prefixCls, "-animated"), {
      [_concatInstanceProperty(_context2 = "".concat(prefixCls, "-")).call(_context2, type)]: Boolean(type),
      [_concatInstanceProperty(_context3 = "".concat(prefixCls, "-speed-")).call(_context3, speed)]: hasSpeedClass,
      [_concatInstanceProperty(_context4 = "".concat(prefixCls, "-delay-")).call(_context4, delay)]: hasDelayClass,
      [_concatInstanceProperty(_context5 = "".concat(prefixCls, "-loop-")).call(_context5, loop)]: hasLoopClass
    });
    const animateStyle = {
      animationTimingFunction: timing,
      animationName: !hasTypeClass && type,
      animationDuration: duration,
      animationDelay: !hasDelayClass && delay,
      animationIterationCount: !hasLoopClass && loop,
      animationDirection: reverse ? 'alternate' : 'normal',
      animationFillMode: fillMode
    };

    if ( /*#__PURE__*/isValidElement(children)) {
      children = _mapInstanceProperty(Children).call(Children, children, child => {
        const animateEvents = this._generateAnimateEvents(child, this.props);

        return /*#__PURE__*/cloneElement(child, _Object$assign({
          className: classnames(child.props.className, animateCls),
          style: _Object$assign(_Object$assign({}, child.props.style), this.props.style)
        }, animateEvents));
      });
    }

    return typeof children === 'function' ? children({
      animateCls,
      animateStyle,
      animateEvents: this._generateAnimateEvents(null, this.props)
    }) : children;
  }

}
StyledAnimation.propTypes = {
  className: PropTypes.string,
  type: PropTypes.oneOfType([PropTypes.string, PropTypes.any]),
  speed: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  delay: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  reverse: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
  loop: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  children: PropTypes.any,
  onStart: PropTypes.func,
  onFrame: PropTypes.func,
  onRest: PropTypes.func,
  prefixCls: PropTypes.string,
  timing: PropTypes.string,
  duration: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  fillMode: PropTypes.string
};
StyledAnimation.defaultProps = {
  prefixCls: 'semi',
  speed: 'faster',
  onFrame: noop,
  onStart: noop,
  onRest: noop
};